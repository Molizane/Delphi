		; This is an implementation of FORTH for the Z80 that
		; should be easily portable to other Z80 systems.
		; It assumes RAM from $9000 to $FFFF and a UART for
		; communication with the host or VDU.
		
FD80          	DATA_STACK	EQU	$FD80		;Data stack grows down
F000          	VOCAB_BASE	EQU	$F000		;Dictionary grows up from here
FEA0          	MASS_STORE	EQU	$FEA0		;Mass storage buffer (default)
A000          	DISK_START	EQU	$A000		;Pseudo disk buffer start
F000          	DISK_END	EQU	$F000		;Pseudo disk buffer end
0200          	BLOCK_SIZE	EQU	$0200		;Pseudo disk block size
0001          	BUFFERS		EQU	$0001		;Pseudo disk buffers per block
		
0000          	MONSTART	EQU	$0000		;Monitor entry address
		
FE00          		ORG	$FE00		;Set up system variable addresses
		
FE00          	SYSTEM					;Start of scratch pad area
FE00          				DS	6		;User bytes
FE06  0000    	S0			DW	0		;Initial value of the data stack pointer
FE08  0000    	R0			DW	0		;Initial value of the return stack pointer
FE0A  0000    	TIB			DW	0		;Address of the terminal input buffer
FE0C  0000    	WIDTH		DW	0		;Number of letters saved in names
FE0E  0000    	WARNING		DW	0		;Error message control number
FE10  0000    	FENCE		DW	0		;Dictionary FORGET protection point
FE12  0000    	DP			DW	0		;The dictionary pointer
FE14  0000    	VOC_LINK	DW	0		;Most recently created vocabulary
FE16  0000    	BLK			DW	0		;Current block number under interpretation
FE18  0000    	TOIN		DW	0		;Offset in the current input text buffer
FE1A  0000    	OUT_		DW	0		;Offset in the current output text buffer
FE1C  0000    	SCR			DW	0		;Screen number last referenced by LIST
FE1E  0000    	OFFSET		DW	0		;Block offset for disk drives
FE20  0000    	CONTEXT		DW	0		;Pointer to the vocabulary within which
								;dictionary search will first begin
FE22  0000    	CURRENT		DW	0		;Pointer to the vocabulary within which
								;new definitions are to be created
FE24  0000    	STATE		DW	0		;Contains state of compillation
FE26  0000    	BASE		DW	0		;Current I/O base address
FE28  0000    	DPL			DW	0		;Number of digits to the right of the
								;decimal point on double integer input
FE2A  0000    	FLD			DW	0		;Field width for formatted number output
FE2C  0000    	CSP			DW	0		;Check stack pointer
FE2E  0000    	RHASH		DW	0		;Location of editor cursor in a text bloxk
FE30  0000    	HLD			DW	0		;Address of current output
FE32          	FLAST		DS	6		;FORTH vocabulary data initialised to FORTH
								;vocabulary
FE38          	ELAST		DS	6		;Editor vocabulary data initialised to
								;EDITOR vocabulary
FE3E  00      	CRFLAG		DB	0		;Carriage return flag
FE3F  00      				DB	0		;User byte
FE40          	PAT			DS	3		;I/O port fetch routine (input)
FE43          	PST			DS	3		;I/O port store routine (output)
FE46  0000    	RPP			DW	0		;Return stack pointer
FE48  0000    	USE			DW	0		;Mass storage buffer address to use
FE4A  0000    	PREV		DW	0		;Mass storage buffer address just used
FE4C  00      	INTFLAG		DB	0		;Interrupt flag
FE4D  00      				DB	0		;User byte
FE4E  0000    	INTVECT		DW	0		;Interrupt vector
FE50  0000    	UTERMINAL	DW	0		;Code field address of word ?TERMINAL
FE52  0000    	UKEY		DW	0		;Code field address of word KEY
FE54  0000    	UEMIT		DW	0		;Code field address of word EMIT
FE56  0000    	URW			DW	0		;Code field address of word R/W
FE58  0000    	UCR			DW	0		;Code field address of word CR
FE5A  0000    	UABORT		DW	0		;Code field address of word ABORT
FE5C  0000    	UCL			DW	0		;Number of characters per input line
FE5E  0000    	UFIRST		DW	0		;Start of pseudo disk buffer
FE60  0000    	ULIMIT		DW	0		;End of pseudo disk buffer
FE62  0000    	UBBUF		DW	0		;Number of bytes per block
FE64  0000    	UBSCR		DW	0		;Number of buffers per block
FE66  0000    	KEYBUF		DW	0		;Double key buffer
FE68  0000    	RAF			DW	0		;Register AF
FE6A  0000    	RBC			DW	0		;Register BC
FE6C  0000    	RDE			DW	0		;Register DE
FE6E  0000    	RHL			DW	0		;Register HL
FE70  0000    	RIX			DW	0		;Register IX
FE72  0000    	RIY			DW	0		;Register IY
FE74  0000    	RAF2		DW	0		;Register AF'
FE76  0000    	RBC2		DW	0		;Register BC'
FE78  0000    	RDE2		DW	0		;Register DE'
FE7A  0000    	RHL2		DW	0		;Register HL'
FE7C  00      				DB	0		;User byte
FE7D  00      	JPCODE		DB	0		;JMP code (C3) for word CALL
FE7E  0000    	JPVECT		DW	0		;JMP vector for word CALL
FE80          				DS	32		;User bytes
		
		;	IO/M Addresses
		
		; This assumes that the uPF IO/M card is fitted.
		
0060          	URTDA		EQU	$60		;8251 UART Data Port
0061          	URTCNT		EQU	$61		;8251 UART Control Port
		
0066          	CTC2		EQU	$66		;CTC Channel 2, Baud rate gen for UART
		
8000          		ORG	$8000			;Start of RAM
		
		;	Setup 8251 9600 baud 8N1	*
		
		; Change this bit to suit your systems port initialisation.
		
8000  3E47    		LD	A,$47				;Counter mode, TC follows, Reset channel
8002  D366    		OUT	(CTC2),A			;CTC2 is baud rate gen for 8251
8004  3E03    		LD	A,$03				;Time const for 9600 baud
8006  D366    		OUT	(CTC2),A			;
8008  211880  		LD	HL,RESTAB			;Reset sequence for 8251
800B  0606    		LD	B,TABEND-RESTAB		;Table length
800D  0E61    		LD	C,URTCNT			;Point to control port
800F  EDB3    		OTIR					;OUT and loop until done
		
8011  AF      		XOR	A					;Clear A
8012  3266FE  		LD	(KEYBUF),A			;Clear buffered key
8015  C3A091  		JP	X_COLD
		
8018          	RESTAB
8018  00000040		DB	$00,$00,$00,$40,$4E,$37
      4E37
801E          	TABEND
		
801E          	BACKSPACE
801E  0800    		DW	$0008			;Backspace chr
		
8020          	WORD1
8020  80FD    		DW	DATA_STACK
8022          	DEF_SYSADDR
8022  00FE    		DW	SYSTEM
8024  80FD    		DW	DATA_STACK
8026  1F00    		DW	$001F			;Word name length (default 31)
8028  0000    		DW	$0000			;Error message control number
802A  00F0    		DW	VOCAB_BASE		;FORGET protection
802C  0BF0    		DW	VOCAB_BASE+$0B		;Dictionary pointer
802E  FC90    		DW	E_FORTH			;Most recently created vocab.
		
8030          	START_TABLE
8030  81A0    		DB	$81,$A0
8032  00F0    		DW	VOCAB_BASE
8034  0000    		DB	$00,$00			;FLAST
8036  81A0    		DB	$81,$A0
8038  6C9A    		DW	W_EDITI
803A  FC90    		DW	E_FORTH			;ELAST
803C  00      		DB	$00			;CRFLAG
803D  00      		DB	$00			;Free
803E  DB00    		IN	A,($00)			;I/O Port input
8040  C9      		RET				;routine
8041  D300    		OUT	($00),A			;I/O Port output
8043  C9      		RET				;routine
8044  00FE    		DW	SYSTEM 			;Return stack pointer
8046  A0FE    		DW	MASS_STORE		;Mass storage buffer to use
8048  A0FE    		DW	MASS_STORE		;Storage buffer just used
804A  00      		DB	$00			;Interrupt flag
804B  00      		DB	$00			;Free
804C  5C91    		DW	C_ABORT			;Interrupt vector
804E  B09A    		DW	CF_UQTERMINAL		;C field address ?TERMINAL
8050  849A    		DW	CF_UKEY			;C field address KEY
8052  8F9A    		DW	CF_UEMIT		;C field address EMIT
8054  9D9A    		DW	CF_UCR			;C field address CR
8056  4694    		DW	CF_URW			;C field address R/W
8058  6691    		DW	CF_UABORT		;C field address ABORT
805A  2000    		DW	$0020			;CHRs per input line
805C  00A0    		DW	DISK_START		;Pseudo disk buf start
805E  00F0    		DW	DISK_END		;Pseudo disk buf end
8060  0002    		DW	BLOCK_SIZE		;Bytes per block
8062  0100    		DW	BUFFERS			;Buffers per block
		
8064          	NEXTS2
8064  D5      		PUSH	DE
8065          	NEXTS1
8065  E5      		PUSH	HL
8066          	NEXT
8066  3A4CFE  		LD	A,(INTFLAG)		;Interrupt flag
8069  CB7F    		BIT	7,A				;Check for interrupt
806B  280E    		JR	Z,NOINT			;No interrupt
806D  CB77    		BIT	6,A				;Interrupt enabled ?
806F  200A    		JR	NZ,NOINT		;No interrupt
8071  2A4EFE  		LD	HL,(INTVECT)	;Get interrupt vector
8074  3E40    		LD	A,$40			;Clear flag byte
8076  324CFE  		LD	(INTFLAG),A		;Interrupt flag into HL
8079  1806    		JR	NEXTADDR		;JP (HL)
807B          	NOINT
807B  0A      		LD	A,(BC)			;effectively LD HL,(BC)
807C  03      		INC	BC				;
807D  6F      		LD	L,A				;
807E  0A      		LD	A,(BC)			;
807F  03      		INC	BC				;BC now points to next vector
8080  67      		LD	H,A				;HL has addr vector
8081          	NEXTADDR
8081  5E      		LD	E,(HL)			;effectively LD HL,(HL)
8082  23      		INC	HL				;
8083  56      		LD	D,(HL) 			;
8084  EB      		EX	DE,HL 			;
8085  E9      		JP	(HL) 			;Jump to it
		
8086          	W_LIT					;Puts next 2 bytes on the stack
8086  834C49D4		DB	$83,'LI','T'+$80
808A  0000    		DW	$0000			;First word in vocabulary
808C          	C_LIT
808C  8E80    		DW	2+$				;Vector to code
808E  0A      		LD	A,(BC)			;Gets next word from (BC)
808F  03      		INC	BC				;then increments BC to point
8090  6F      		LD	L,A				;to the next addr. Pushes the
8091  0A      		LD	A,(BC)			;result onto the stack.
8092  03      		INC	BC				;
8093  67      		LD	H,A				;
8094  C36580  		JP	NEXTS1			;Save & NEXT
		
		
8097          	W_EXECUTE	;Jump to address on stack
8097  87455845		DB	$87,'EXECUT','E'+$80
      435554C5
809F  8680    		DW	W_LIT
80A1          	C_EXECUTE
80A1  A380    		DW	2+$			;Vector to code
80A3  E1      		POP	HL			;Get addr off data stack
80A4  C38180  		JP	NEXTADDR		;Basically JP (HL)
		
		
80A7          	W_BRANCH	;Add following offset to BC
80A7  86425241		DB	$86,'BRANC','H'+$80
      4E43C8
80AE  9780    		DW	W_EXECUTE
80B0          	C_BRANCH
80B0  B280    		DW	2+$			;Vector to code
80B2          	X_BRANCH
80B2  60      		LD	H,B			;Next pointer into HL
80B3  69      		LD	L,C			;
80B4  5E      		LD	E,(HL)			;Get word offset LD DE,(HL)
80B5  23      		INC	HL			;Incr to point at next byte
80B6  56      		LD	D,(HL)			;
80B7  2B      		DEC	HL 			;Restore HL
80B8  19      		ADD	HL,DE			;Calculate new address
80B9  4D      		LD	C,L			;Put it in BC
80BA  44      		LD	B,H			;
80BB  C36680  		JP	NEXT			;Go do it
		
		
80BE          	W_0BRANCH	;Add offset to BC if stack top = 0
80BE  87304252		DB	$87,'0BRANC','H'+$80	;Conditional branch
      414E43C8
80C6  A780    		DW	W_BRANCH
80C8          	C_0BRANCH
80C8  CA80    		DW	2+$			;Vector to code
80CA  E1      		POP	HL			;Get value off stack
80CB  7D      		LD	A,L			;Set flags
80CC  B4      		OR	H			;
80CD  28E3    		JR	Z,X_BRANCH		;If zero then do the branch
80CF  03      		INC	BC			;Else dump branch address
80D0  03      		INC	BC			;
80D1  C36680  		JP	NEXT			;Continue execution
		
80D4          	W_LLOOP		;Increment loop & branch if not done
80D4  863C4C4F		DB	$86,'<LOOP','>'+$80
      4F50BE
80DB  BE80    		DW	W_0BRANCH
80DD          	C_LLOOP
80DD  DF80    		DW	2+$			;Vector to code
80DF  110100  		LD	DE,0001
80E2          	C_ILOOP
80E2  2A46FE  		LD	HL,(RPP)		;Get return stack pointer
80E5  7E      		LD	A,(HL)			;Add DE to value on return stack
80E6  83      		ADD	A,E			;
80E7  77      		LD	(HL),A			;
80E8  5F      		LD	E,A			;
80E9  23      		INC	HL			;
80EA  7E      		LD	A,(HL)			;
80EB  8A      		ADC	A,D			;
80EC  77      		LD	(HL),A			;
80ED  23      		INC	HL			;HL now points to limit value
80EE  14      		INC	D			;Get Ds sign bit
80EF  15      		DEC	D			;
80F0  57      		LD	D,A			;Result now in DE
80F1  FAFB80  		JP	M,DECR_LOOP		;Decrement loop so check > limit
							;otherwies check < limit
80F4  7B      		LD	A,E			;Low byte back
80F5  96      		SUB	(HL)			;Subtract limit low
80F6  7A      		LD	A,D			;High byte back
80F7  23      		INC	HL			;Point to limit high
80F8  9E      		SBC	A,(HL)			;Subtract it
80F9  1805    		JR	TEST_LIMIT		;
80FB          	DECR_LOOP
80FB  7E      		LD	A,(HL)			;Get limit low
80FC  93      		SUB	E			;Subtract index low
80FD  23      		INC	HL			;Point to limit high
80FE  7E      		LD	A,(HL)			;Get it
80FF  9A      		SBC	A,D			;Subtract index high
8100          	TEST_LIMIT
8100  FAB280  		JP	M,X_BRANCH		;Not reached limit so jump
8103  23      		INC	HL			;Drop index & limit from return stack
8104  2246FE  		LD	(RPP),HL		;Save stack pointer
8107  03      		INC	BC			;Skip branch offset
8108  03      		INC	BC			;
8109  C36680  		JP	NEXT
		
810C          	W_PLOOP		;Loop + stack & branch if not done
810C  873C2B4C		DB	$87,'<+LOOP','>'+$80
      4F4F50BE
8114  D480    		DW	W_LLOOP
8116          	C_PLOOP
8116  1881    		DW	2+$			;Vector to code
8118  D1      		POP	DE			;Get value from stack
8119  18C7    		JR	C_ILOOP			;Go do loop increment
		
811B          	W_LDO		;Put start & end loop values on RPP
811B  843C444F		DB	$84,'<DO','>'+$80
      BE
8120  0C81    		DW	 W_PLOOP
8122          	C_LDO
8122  2481    		DW	 2+$
8124  2A46FE  		LD	HL,(RPP)		;Get return stack pointer
8127  2B      		DEC	HL			;Add space for two values
8128  2B      		DEC	HL			;
8129  2B      		DEC	HL			;
812A  2B      		DEC	HL			;
812B  2246FE  		LD	(RPP),HL		;Save new stack pointer
812E  D1      		POP	DE			;Get start value &
812F  73      		LD	(HL),E			;put on return stack top
8130  23      		INC	HL			;
8131  72      		LD	(HL),D			;
8132  23      		INC	HL			;
8133  D1      		POP	DE			;Get end value &
8134  73      		LD	(HL),E			;put on return stack - 1
8135  23      		INC	HL			;
8136  72      		LD	(HL),D			;
8137  C36680  		JP	NEXT
		
813A          	W_I		;Copy LOOP index to data stack
813A  81C9    		DB	$81,'I'+$80
813C  1B81    		DW	 W_LDO
813E          	C_I
813E  4081    		DW	 2+$
8140          	X_I
8140  2A46FE  		LD	HL,(RPP)		;Get return stack pointer
8143          	X_I2
8143  5E      		LD	E,(HL)			;Get LOOP index off return stack
8144  23      		INC	HL			;
8145  56      		LD	D,(HL)			;
8146  D5      		PUSH	DE			;Push onto data stack
8147  C36680  		JP	NEXT
		
814A          	W_DIGIT		;Convert digit n2 using base n1
814A  85444947		DB	$85,'DIGI','T'+$80
      49D4
8150  3A81    		DW	 W_I
8152          	C_DIGIT
8152  5481    		DW	2+$
8154  E1      		POP	HL			;Get base to use
8155  D1      		POP	DE			;Get char
8156  7B      		LD	A,E			;A = char
8157  D630    		SUB	$30			;Subtract 30h
8159  FA7381  		JP	M,NDIGIT		;
815C  FE0A    		CP	$0A			;Greater than 9 ?
815E  FA6881  		JP	M,LESS10		;If not then skip
8161  D607    		SUB	$07			;Convert 'A' to 10
8163  FE0A    		CP	$0A			;Is it 10?
8165  FA7381  		JP	M,NDIGIT		;If not an error occured
8168          	LESS10
8168  BD      		CP	L			;L is 1 digit limit
8169  F27381  		JP	P,NDIGIT		;Out of range for digit
816C  5F      		LD	E,A			;Result into DE
816D  210100  		LD	HL,0001			;Leave TRUE flag
8170  C36480  		JP	NEXTS2			;Save both & NEXT
8173          	NDIGIT
8173  6C      		LD	L,H			;Leave FALSE flag
8174  C36580  		JP	NEXTS1			;Save & NEXT
		
8177          	W_FIND		;Find word & return vector,byte & flag
8177  863C4649		DB	$86,'<FIND','>'+$80
      4E44BE
817E  4A81    		DW	W_DIGIT
8180          	C_FIND
8180  8281    		DW	2+$			;Vector to code
8182  D1      		POP	DE			;Get pointer to next vocabulary word
8183          	COMPARE
8183  E1      		POP	HL			;Copy pointer to word we're looking 4
8184  E5      		PUSH	HL			;
8185  1A      		LD	A,(DE)			;Get 1st vocabulary word letter
8186  AE      		XOR	(HL)			;Compare with what we've got
8187  E63F    		AND	$3F			;Ignore start flag
8189  201F    		JR	NZ,NOT_END_CHR		;No match so skip to next word
818B          	MATCH_NO_END
818B  23      		INC	HL			;Compare next chr
818C  13      		INC	DE			;
818D  1A      		LD	A,(DE)			;
818E  AE      		XOR	(HL)			;
818F  87      		ADD	A,A			;Move bit 7 to C flag
8190  2016    		JR	NZ,NO_MATCH		;No match jump
8192  30F7    		JR	NC,MATCH_NO_END		;Match & not last, so next chr
8194  210500  		LD	HL,0005			;Offset to start of code
8197  19      		ADD	HL,DE			;HL now points to code start for word
8198  E3      		EX	(SP),HL			;Swap with value on stack
8199          	NOT_WORD_BYTE
8199  1B      		DEC	DE			;Search back for word type byte
819A  1A      		LD	A,(DE)			;
819B  B7      		OR	A			;
819C  F29981  		JP	P,NOT_WORD_BYTE		;Not yet so loop
819F  5F      		LD	E,A			;Byte into DE
81A0  1600    		LD	D,$00			;
81A2  210100  		LD	HL,0001			;Leave TRUE flag
81A5  C36480  		JP	NEXTS2			;Save both & NEXT
81A8          	NO_MATCH
81A8  3806    		JR	C,END_CHR		;If last chr then jump
81AA          	NOT_END_CHR
81AA  13      		INC	DE			;Next chr of this vocab word
81AB  1A      		LD	A,(DE)			;Get it
81AC  B7      		OR	A			;Set flags
81AD  F2AA81  		JP	P,NOT_END_CHR		;Loop if not end chr
81B0          	END_CHR
81B0  13      		INC	DE			;Now points to next word vector
81B1  EB      		EX	DE,HL			;Swap
81B2  5E      		LD	E,(HL)			;Vector into DE
81B3  23      		INC	HL			;
81B4  56      		LD	D,(HL)			;
81B5  7A      		LD	A,D			;Check it's not last (first) word
81B6  B3      		OR	E			;
81B7  20CA    		JR	NZ,COMPARE		;No error so loop
81B9  E1      		POP	HL			;Dump pointer
81BA  210000  		LD	HL,0000			;Flag error
81BD  C36580  		JP	NEXTS1			;Save & NEXT
		
81C0          	W_ENCLOSE
81C0  87454E43		DB	$87,'ENCLOS','E'+$80
      4C4F53C5
81C8  7781    		DW	W_FIND
81CA          	C_ENCLOSE
81CA  CC81    		DW	2+$			;Vector to code
81CC  D1      		POP	DE			; get delimiter character
81CD  E1      		POP	HL			; get address 1
81CE  E5      		PUSH	HL			; duplicate it
81CF  7B      		LD	A,E			; delimiter char into A
81D0  57      		LD	D,A			; copy to D
81D1  1EFF    		LD	E,$FF			; -1 for offset
81D3  2B      		DEC	HL			; to allow for first INCR
81D4          	J21E6
81D4  23      		INC	HL			; point to next chr
81D5  1C      		INC	E			; next offset
81D6  BE      		CP	(HL)			; compare chr with (address)
81D7  28FB    		JR	Z,J21E6			; loop if = delimiter chr
81D9  3E0D    		LD	A,$0D			; else set CR
81DB  BE      		CP	(HL)			; compare with (address)
81DC  7A      		LD	A,D			; restore delimiter chr
81DD  28F5    		JR	Z,J21E6			; loop if it was = CR
81DF  1600    		LD	D,$00			; zero high byte
81E1  D5      		PUSH	DE			; save offset
81E2  57      		LD	D,A			; restore delimiter chr
81E3  7E      		LD	A,(HL)			; get byte from address
81E4  A7      		AND	A			; set the flags
81E5  2009    		JR	NZ,J2202		; branch if not null
81E7  1600    		LD	D,$00			; clear high byte
81E9  1C      		INC	E			; point to next addr
81EA  D5      		PUSH	DE			; save address
81EB  1D      		DEC	E			; point to end
81EC  D5      		PUSH	DE			; push address
81ED  C36680  		JP	NEXT			; done
81F0          	J2202
81F0  7A      		LD	A,D			; restore delimiter chr
81F1  23      		INC	HL			; increment address
81F2  1C      		INC	E			; increment offset
81F3  BE      		CP	(HL)			; compare delimiter with (address)
81F4  2810    		JR	Z,J2218			; jump if =
81F6  3E0D    		LD	A,$0D			; else get CR
81F8  BE      		CP	(HL)			; compare with (address)
81F9  280B    		JR	Z,J2218			; jump if =
81FB  7E      		LD	A,(HL)			; else get byte
81FC  A7      		AND	A			; set the flags
81FD  20F1    		JR	NZ,J2202		; loop if not null
81FF  1600    		LD	D,$00			; clear gigh byte
8201  D5      		PUSH	DE			; save address
8202  D5      		PUSH	DE			; save address
8203  C36680  		JP	NEXT			; done
8206          	J2218
8206  1600    		LD	D,$00			; clear high byte
8208  D5      		PUSH	DE			; save address
8209  1C      		INC	E			; increment offset
820A  D5      		PUSH	DE			; save address
820B  C36680  		JP	NEXT			; done
		
820E          	W_EMIT		;Output CHR from stack
820E  84454D49		DB	$84,'EMI','T'+$80
      D4
8213  C081    		DW	W_ENCLOSE
8215          	C_EMIT
8215  7C85    		DW	E_COLON			;Interpret following word sequence
8217  BC87    		DW	C_UEMIT			;Put UEMIT addr on stack
8219  0285    		DW	C_FETCH			;Get UEMIT code field address
821B  A180    		DW	C_EXECUTE		;Jump to address on stack
821D  FB85    		DW	C_1
821F  DA86    		DW	C_OUT
8221  DD84    		DW	C_PLUSSTORE
8223  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8225          	W_KEY		;Wait for key, value on stack
8225  834B45D9		DB	$83,'KE','Y'+$80
8229  0E82    		DW	W_EMIT
822B          	C_KEY
822B  2D82    		DW	2+$			;Vector to code
822D  2A52FE  		LD	HL,(UKEY)		;Get the vector
8230  E9      		JP	(HL)			;Jump to it
		
		;	DW	E_COLON			;Interpret following word sequence
		;	DW	C_UKEY			;Put UKEY addr on stack
		;	DW	C_FETCH			;Get CF_KEY
		;	DW	C_EXECUTE		;Jump to CF_KEY
		;	DW	C_STOP			;Pop BC from return stack (=next)
		
		
8231          	W_TERMINAL
8231  893F5445		DB	$89,'?TERMINA','L'+$80
      524D494E
      41CC
823B  2582    		DW	W_KEY
823D          	C_TERMINAL
823D  7C85    		DW	E_COLON			;Interpret following word sequence
823F  A587    		DW	C_UTERMINAL
8241  0285    		DW	C_FETCH			;Get word from addr on stack
8243  A180    		DW	C_EXECUTE		;Jump to address on stack
8245  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8247          	W_CR		;Output [CR][LF]
8247  8243D2  		DB	$82,'C','R'+$80
824A  3182    		DW	W_TERMINAL
824C          	C_CR
824C  7C85    		DW	E_COLON			;Interpret following word sequence
824E  C687    		DW	C_UCR			;Push UCR addr
8250  0285    		DW	C_FETCH			;Get UCR code field addr
8252  A180    		DW	C_EXECUTE		;Jump to address on stack
8254  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8256          	W_CLS		;Clear screen
8256  83434CD3		DB	$83,'CL','S'+$80
825A  4782    		DW	W_CR
825C          	C_CLS
825C  7C85    		DW	E_COLON			;Interpret following word sequence
825E  8C80    		DW	C_LIT			;Put clear screen code on stack
8260  0C00    		DW	$000C			;
8262  1582    		DW	C_EMIT			;Output it
8264  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8266          	W_CMOVE		;Move block
8266  85434D4F		DB	$85,'CMOV','E'+$80
      56C5
826C  5682    		DW	W_CLS
826E          	C_CMOVE
826E  7082    		DW	2+$			;Vector to code
8270  69      		LD	L,C			;Save BC for now
8271  60      		LD	H,B			;
8272  C1      		POP	BC			;Get no. of bytes to move
8273  D1      		POP	DE			;Get destination address
8274  E3      		EX	(SP),HL			;Get source address
8275  78      		LD	A,B			;Check it's not a 0 length block
8276  B1      		OR	C			;
8277  2802    		JR	Z,NO_BYTES		;If 0 length then do nothing
8279  EDB0    		LDIR				;Move block
827B          	NO_BYTES
827B  C1      		POP	BC			;Get BC back
827C  C36680  		JP	NEXT
		
827F          	W_USTAR		;Unsigned multiply
827F  8255AA  		DB	$82,'U','*'+$80
8282  6682    		DW	W_CMOVE
8284          	C_USTAR
8284  8682    		DW	2+$			;Vector to code
8286  D1      		POP	DE			; get n2
8287  E1      		POP	HL			; get n1
8288  C5      		PUSH	BC			; save BC for now
8289  4C      		LD	C,H			; save H
828A  7D      		LD	A,L			; low byte to multiply by
828B  CDA282  		CALL	HALF_TIMES		; HL = A * DE
828E  E5      		PUSH	HL			; save partial result
828F  67      		LD	H,A			; clear H
8290  79      		LD	A,C			; high byte to multiply by
8291  4C      		LD	C,H			; clear B
8292  CDA282  		CALL	HALF_TIMES		; HL = A * DE
8295  D1      		POP	DE			; get last partial result
8296  41      		LD	B,C			; add partial results
8297  4A      		LD	C,D			; add partial results
8298  09      		ADD	HL,BC			;
8299  CE00    		ADC	A,$00			;
829B  55      		LD	D,L			;
829C  6C      		LD	L,H			;
829D  67      		LD	H,A			;
829E  C1      		POP	BC			; get BC back
829F  C36480  		JP	NEXTS2			; save 32 bit result & NEXT
		
82A2          	HALF_TIMES				;
82A2  210000  		LD	HL,$0000		; clear partial result
82A5  0608    		LD	B,$08			; eight bits to do
82A7          	NEXT_BIT
82A7  29      		ADD	HL,HL			; result * 2
82A8  17      		RLA				; multiply bit into C
82A9  3003    		JR	NC,NO_MUL		; branch if no multiply
82AB  19      		ADD	HL,DE			; add multiplicand
82AC  CE00    		ADC	A,$00			; add in any carry
82AE          	NO_MUL
82AE  10F7    		DJNZ	NEXT_BIT		; decr and loop if not done
82B0  C9      		RET				;
		
82B1          	W_UMOD		;Unsigned divide & MOD
82B1  85552F4D		DB	$85,'U/MO','D'+$80
      4FC4
82B7  7F82    		DW	W_USTAR
82B9          	C_UMOD
82B9  BB82    		DW	2+$			;Vector to code
82BB  210400  		LD	HL,0004
82BE  39      		ADD	HL,SP
82BF  5E      		LD	E,(HL)
82C0  71      		LD	(HL),C
82C1  23      		INC	HL
82C2  56      		LD	D,(HL)
82C3  70      		LD	(HL),B
82C4  C1      		POP	BC
82C5  E1      		POP	HL
82C6  7D      		LD	A,L
82C7  91      		SUB	C
82C8  7C      		LD	A,H
82C9  98      		SBC	A,B
82CA  3808    		JR	C,J22DB
82CC  21FFFF  		LD	HL,$FFFF
82CF  11FFFF  		LD	DE,$FFFF
82D2  1826    		JR	J2301
82D4          	J22DB
82D4  3E10    		LD	A,$10
82D6          	J22DD
82D6  29      		ADD	HL,HL
82D7  17      		RLA
82D8  EB      		EX	DE,HL
82D9  29      		ADD	HL,HL
82DA  3002    		JR	NC,J22E5
82DC  13      		INC	DE
82DD  A7      		AND	A
82DE          	J22E5
82DE  EB      		EX	DE,HL
82DF  1F      		RRA
82E0  F5      		PUSH	AF
82E1  3008    		JR	NC,J22F2
82E3  7D      		LD	A,L
82E4  91      		SUB	C
82E5  6F      		LD	L,A
82E6  7C      		LD	A,H
82E7  98      		SBC	A,B
82E8  67      		LD	H,A
82E9  180A    		JR	J22FC
82EB          	J22F2
82EB  7D      		LD	A,L
82EC  91      		SUB	C
82ED  6F      		LD	L,A
82EE  7C      		LD	A,H
82EF  98      		SBC	A,B
82F0  67      		LD	H,A
82F1  3002    		JR	NC,J22FC
82F3  09      		ADD	HL,BC
82F4  1B      		DEC	DE
82F5          	J22FC
82F5  13      		INC	DE
82F6  F1      		POP	AF
82F7  3D      		DEC	A
82F8  20DC    		JR	NZ,J22DD
82FA          	J2301
82FA  C1      		POP	BC
82FB  E5      		PUSH	HL
82FC  D5      		PUSH	DE
82FD  C36680  		JP	NEXT
		
8300          	W_AND		;AND
8300  83414EC4		DB	$83,'AN','D'+$80
8304  B182    		DW	W_UMOD
8306          	C_AND
8306  0883    		DW	2+$			;Vector to code
8308  D1      		POP	DE			;Get n1 off stack
8309  E1      		POP	HL			;Get n2 off stack
830A  7B      		LD	A,E			;AND lo bytes
830B  A5      		AND	L			;
830C  6F      		LD	L,A			;Result in L
830D  7A      		LD	A,D			;AND hi bytes
830E  A4      		AND	H			;
830F  67      		LD	H,A			;Result in H
8310  C36580  		JP	NEXTS1			;Save & next
		
8313          	W_OR		;OR
8313  824FD2  		DB	$82,'O','R'+$80
8316  0083    		DW	W_AND
8318          	C_OR
8318  1A83    		DW	2+$			;Vector to code
831A  D1      		POP	DE			;Get n1 off stack
831B  E1      		POP	HL			;Get n2 off stack
831C  7B      		LD	A,E			;OR lo bytes
831D  B5      		OR	L			;
831E  6F      		LD	L,A			;Result in L
831F  7A      		LD	A,D			;OR hi bytes
8320  B4      		OR	H			;
8321  67      		LD	H,A			;Result in H
8322  C36580  		JP	NEXTS1			;Save & next
		
8325          	W_XOR		;XOR
8325  83584FD2		DB	$83,'XO','R'+$80
8329  1383    		DW	W_OR
832B          	C_XOR
832B  2D83    		DW	2+$			;Vector to code
832D  D1      		POP	DE			;Get n1 off stack
832E  E1      		POP	HL			;Get n2 off stack
832F  7B      		LD	A,E			;XOR lo bytes
8330  AD      		XOR	L			;
8331  6F      		LD	L,A			;Result in L
8332  7A      		LD	A,D			;XOR hi bytes
8333  AC      		XOR	H			;
8334  67      		LD	H,A			;Result in H
8335  C36580  		JP	NEXTS1			;Save & NEXT
		
8338          	W_SPFETCH	;Stack pointer onto stack
8338  835350C0		DB	$83,'SP','@'+$80
833C  2583    		DW	W_XOR
833E          	C_SPFETCH
833E  4083    		DW	2+$			;Vector to code
8340  210000  		LD	HL,0000			;No offset
8343  39      		ADD	HL,SP			;Add SP to HL
8344  C36580  		JP	NEXTS1			;Save & NEXT
		
8347          	W_SPSTORE	;Set initial stack pointer value
8347  835350A1		DB	$83,'SP','!'+$80
834B  3883    		DW	W_SPFETCH
834D          	C_SPSTORE
834D  4F83    		DW	2+$			;Vector to code
834F  2A2280  		LD	HL,(DEF_SYSADDR)	;Get system base addr
8352  110600  		LD	DE,S0-SYSTEM		;Offset to stack pointer value (0006)
8355  19      		ADD	HL,DE			;Add to base addr
8356  5E      		LD	E,(HL)			;Get SP from ram
8357  23      		INC	HL			;
8358  56      		LD	D,(HL)			;
8359  EB      		EX	DE,HL			;Put into HL
835A  F9      		LD	SP,HL			;Set SP
835B  C36680  		JP	NEXT
		
835E          	W_RPFETCH	;Get return stack pointer
835E  835250C0		DB	$83,'RP','@'+$80
8362  4783    		DW	W_SPSTORE
8364          	C_RPFETCH
8364  6683    		DW	2+$			;Vector to code
8366  2A46FE  		LD	HL,(RPP)		;Return stack pointer into HL
8369  C36580  		JP	NEXTS1			;Save & NEXT
		
836C          	W_RPSTORE	;Set initial return stack pointer
836C  835250A1		DB	$83,'RP','!'+$80
8370  5E83    		DW	W_RPFETCH
8372          	C_RPSTORE
8372  7483    		DW	2+$			;Vector to code
8374  2A2280  		LD	HL,(DEF_SYSADDR)	;Get system base addr
8377  110800  		LD	DE,0008			;Offset to return stack pointer value
837A  19      		ADD	HL,DE			;Add to base addr
837B  5E      		LD	E,(HL)			;Get SP from ram
837C  23      		INC	HL			;
837D  56      		LD	D,(HL)			;
837E  EB      		EX	DE,HL			;Put into HL
837F  2246FE  		LD	(RPP),HL		;Set return SP
8382  C36680  		JP	NEXT
		
8385          	W_STOP		;Pop BC from return stack (=next)
8385  823BD3  		DB	$82,';','S'+$80
8388  6C83    		DW	W_RPSTORE
838A          	C_STOP
838A  8C83    		DW	2+$			;Vector to code
838C          	X_STOP
838C  2A46FE  		LD	HL,(RPP)		;Return stack pointer to HL
838F  4E      		LD	C,(HL)			;Get low byte
8390  23      		INC	HL			;
8391  46      		LD	B,(HL)			;Get high byte
8392  23      		INC	HL			;
8393  2246FE  		LD	(RPP),HL		;Save stack pointer
8396  C36680  		JP	NEXT
		
8399          	W_LEAVE		;Quit loop by making index = limit
8399  854C4541		DB	$85,'LEAV','E'+$80
      56C5
839F  8583    		DW	W_STOP
83A1          	C_LEAVE
83A1  A383    		DW	2+$			;Vector to code
83A3  2A46FE  		LD	HL,(RPP)		;Get return stack pointer
83A6  5E      		LD	E,(HL)			;Get loop limit low
83A7  23      		INC	HL			;
83A8  56      		LD	D,(HL)			;Get loop limit high
83A9  23      		INC	HL			;
83AA  73      		LD	(HL),E			;Set index low to loop limit
83AB  23      		INC	HL			;
83AC  72      		LD	(HL),D			;Set index high to loop limit
83AD  C36680  		JP	NEXT
		
83B0          	W_MOVER		;Move from data to return stack
83B0  823ED2  		DB	$82,'>','R'+$80
83B3  9983    		DW	W_LEAVE
83B5          	C_MOVER
83B5  B783    		DW	2+$			;Vector to code
83B7  D1      		POP	DE			;Get value
83B8  2A46FE  		LD	HL,(RPP)		;Get return stack pointer
83BB  2B      		DEC	HL			;Set new value
83BC  2B      		DEC	HL			;
83BD  2246FE  		LD	(RPP),HL		;Save it
83C0  73      		LD	(HL),E			;Push low byte onto return stack
83C1  23      		INC	HL			;
83C2  72      		LD	(HL),D			;Push high byte onto return stack
83C3  C36680  		JP	NEXT
		
83C6          	W_RMOVE		;Move word from return to data stack
83C6  8252BE  		DB	$82,'R','>'+$80
83C9  B083    		DW	W_MOVER
83CB          	C_RMOVE
83CB  CD83    		DW	2+$			;Vector to code
83CD  2A46FE  		LD	HL,(RPP)		;Get return stack pointer
83D0  5E      		LD	E,(HL)			;Pop word off return stack
83D1  23      		INC	HL			;
83D2  56      		LD	D,(HL)			;
83D3  23      		INC	HL			;
83D4  2246FE  		LD	(RPP),HL		;Save new return stack pointer
83D7  D5      		PUSH	DE			;Push on data stack
83D8  C36680  		JP	NEXT
		
83DB          	W_RFETCH	;Return stack top to data stack
83DB  8252C0  		DB	$82,'R','@'+$80
83DE  C683    		DW	W_RMOVE
83E0          	C_RFETCH
83E0  4081    		DW	X_I			;Return stack top to data stack
		
		
83E2          	W_0EQUALS	;=0
83E2  8230BD  		DB	$82,'0','='+$80
83E5  DB83    		DW	W_RFETCH
83E7          	C_0EQUALS
83E7  E983    		DW	2+$			;Vector to code
83E9          	X_0EQUALS
83E9  E1      		POP	HL			;Get value from stack
83EA  7D      		LD	A,L			;set flags
83EB  B4      		OR	H			;
83EC  210000  		LD	HL,0000			;Not = 0 flag
83EF  2001    		JR	NZ,NO_ZERO		;
83F1  23      		INC	HL			;= 0 flag
83F2          	NO_ZERO
83F2  C36580  		JP	NEXTS1			;Save & NEXT
		
83F5          	W_NOT		;Convert flag, same as 0=
83F5  834E4FD4		DB	$83,'NO','T'+$80
83F9  E283    		DW	W_0EQUALS
83FB          	C_NOT
83FB  E983    		DW	X_0EQUALS
		
83FD          	W_0LESS		;Less than 0
83FD  8230BC  		DB	$82,'0','<'+$80
8400  F583    		DW	W_NOT
8402          	C_0LESS
8402  0484    		DW	2+$			;Vector to code
8404  E1      		POP	HL			;Get value
8405  29      		ADD	HL,HL			;S bit into C
8406  210000  		LD	HL,0000			;Wasn't < 0 flag
8409  3001    		JR	NC,NOT_LT0		;
840B  23      		INC	HL			;Was < 0 flag
840C          	NOT_LT0				;
840C  C36580  		JP	NEXTS1			;Save & NEXT
		
840F          	W_PLUS			;n1 + n2
840F  81AB    		DB	$81,'+'+$80
8411  FD83    		DW	W_0LESS
8413          	C_PLUS
8413  1584    		DW	2+$			;Vector to code
8415  D1      		POP	DE			;Get n2
8416  E1      		POP	HL			;Get n1
8417  19      		ADD	HL,DE			;Add them
8418  C36580  		JP	NEXTS1			;Save & NEXT
		
841B          	W_DPLUS		;32 bit add
841B  8244AB  		DB	$82,'D','+'+$80
841E  0F84    		DW	W_PLUS
8420          	C_DPLUS
8420  2284    		DW	2+$			;Vector to code
8422  210600  		LD	HL,0006			; offset to low word
8425  39      		ADD	HL,SP			; add stack pointer
8426  5E      		LD	E,(HL)			; get d1 low word low byte
8427  71      		LD	(HL),C			; save BC low byte
8428  23      		INC	HL			; point to high byte
8429  56      		LD	D,(HL)			; get d1 low word high byte
842A  70      		LD	(HL),B			; save BC high byte
842B  C1      		POP	BC			; get high word d2
842C  E1      		POP	HL			; get low word d2
842D  19      		ADD	HL,DE			; add low words
842E  EB      		EX	DE,HL			; save result low word in DE
842F  E1      		POP	HL			; get d1 high word
8430  7D      		LD	A,L			; copy d1 high word low byte
8431  89      		ADC	A,C			; add d2 high word low byte
							; + carry from low word add
8432  6F      		LD	L,A			; result from high word low byte into L
8433  7C      		LD	A,H			; copy d1 high word low byte
8434  88      		ADC	A,B			; add d2 high word low byte
							; + carry from high word low byte add
8435  67      		LD	H,A			; result from high word high byte into H
8436  C1      		POP	BC			; restore BC
8437  C36480  		JP	NEXTS2			;Save 32 bit result & NEXT
		
843A          	W_NEGATE	;Form 2s complement of n
843A  864E4547		DB	$86,'NEGAT','E'+$80
      4154C5
8441  1B84    		DW	W_DPLUS
8443          	C_NEGATE
8443  4584    		DW	2+$			;Vector to code
8445  E1      		POP	HL			;Get number
8446  7D      		LD	A,L			;Low byte into A
8447  2F      		CPL				;Complement it
8448  6F      		LD	L,A			;Back into L
8449  7C      		LD	A,H			;High byte into A
844A  2F      		CPL				;Complement it
844B  67      		LD	H,A			;Back into H
844C  23      		INC	HL			;+1
844D  C36580  		JP	NEXTS1			;Save & NEXT
		
8450          	W_DNEGATE	;Form 2s complement of 32 bit n
8450  87444E45		DB	$87,'DNEGAT','E'+$80
      474154C5
8458  3A84    		DW	W_NEGATE
845A          	C_DNEGATE
845A  5C84    		DW	2+$			;Vector to code
845C  E1      		POP	HL			; get high word
845D  D1      		POP	DE			; get low word
845E  97      		SUB	A			; clear A
845F  93      		SUB	E			; negate low word low byte
8460  5F      		LD	E,A			; copy back to E
8461  3E00    		LD	A,$00			; clear A
8463  9A      		SBC	A,D			; negate low word high byte
8464  57      		LD	D,A			; copy back to D
8465  3E00    		LD	A,$00			; clear A
8467  9D      		SBC	A,L			; negate high word low byte
8468  6F      		LD	L,A			; copy back to L
8469  3E00    		LD	A,$00			; clear A
846B  9C      		SBC	A,H			; negate high word high byte
846C  67      		LD	H,A			; copy back to H
846D  C36480  		JP	NEXTS2			;Save 32 bit result & NEXT
		
8470          	W_OVER		;Copy 2nd down to top of stack
8470  844F5645		DB	$84,'OVE','R'+$80
      D2
8475  5084    		DW	W_DNEGATE
8477          	C_OVER
8477  7984    		DW	2+$			;Vector to code
8479  D1      		POP	DE			;Get top
847A  E1      		POP	HL			;Get next
847B  E5      		PUSH	HL			;Save it back
847C  C36480  		JP	NEXTS2			;Save both & NEXT
		
847F          	W_DROP		;Drop top value from stack
847F  8444524F		DB	$84,'DRO','P'+$80
      D0
8484  7084    		DW	W_OVER
8486          	C_DROP
8486  8884    		DW	2+$			;Vector to code
8488  E1      		POP	HL			;Get top value
8489  C36680  		JP	NEXT
		
848C          	W_2DROP		;Drop top two values from stack
848C  85324452		DB	$85,'2DRO','P'+$80
      4FD0
8492  7F84    		DW	W_DROP
8494          	C_2DROP
8494  9684    		DW	2+$			;Vector to code
8496  E1      		POP	HL			;Get top value
8497  E1      		POP	HL			;Get top value
8498  C36680  		JP	NEXT
		
849B          	W_SWAP		;Swap top 2 values on stack
849B  84535741		DB	$84,'SWA','P'+$80
      D0
84A0  8C84    		DW	W_2DROP
84A2          	C_SWAP
84A2  A484    		DW	2+$			;Vector to code
84A4  E1      		POP	HL			;Get top value
84A5  E3      		EX	(SP),HL			;Exchanhe with next down
84A6  C36580  		JP	NEXTS1			;Save & NEXT
		
84A9          	W_DUP		;Duplicate top value on stack
84A9  834455D0		DB	$83,'DU','P'+$80
84AD  9B84    		DW	W_SWAP
84AF          	C_DUP
84AF  B184    		DW	2+$			;Vector to code
84B1  E1      		POP	HL			;Get value off stack
84B2  E5      		PUSH	HL			;Copy it back
84B3  C36580  		JP	NEXTS1			;Save & NEXT
		
84B6          	W_2DUP		;Dup top 2 values on stack
84B6  84324455		DB	$84,'2DU','P'+$80
      D0
84BB  A984    		DW	W_DUP
84BD          	C_2DUP
84BD  BF84    		DW	2+$			;Vector to code
84BF  E1      		POP	HL			;Get top two values from stack
84C0  D1      		POP	DE			;
84C1  D5      		PUSH	DE			;Copy them back
84C2  E5      		PUSH	HL			;
84C3  C36480  		JP	NEXTS2			;Save both & NEXT
		
84C6          	W_BOUNDS	;Convert address & n to start & end
84C6  86424F55		DB	$86,'BOUND','S'+$80
      4E44D3
84CD  B684    		DW	W_2DUP
84CF          	C_BOUNDS
84CF  D184    		DW	2+$			;Vector to code
84D1  E1      		POP	HL			; get n
84D2  D1      		POP	DE			; get addr
84D3  19      		ADD	HL,DE			; add addr to n
84D4  EB      		EX	DE,HL			; swap them
84D5  C36480  		JP	NEXTS2			; save both & NEXT
		
84D8          	W_PLUSSTORE	;Add n1 to addr
84D8  822BA1  		DB	$82,'+','!'+$80
84DB  C684    		DW	W_BOUNDS
84DD          	C_PLUSSTORE
84DD  DF84    		DW	2+$			;Vector to code
84DF  E1      		POP	HL			;Get addr
84E0  D1      		POP	DE			;Get DE
84E1  7E      		LD	A,(HL)			;Add low bytes
84E2  83      		ADD	A,E			;
84E3  77      		LD	(HL),A			;Store result
84E4  23      		INC	HL			;Point to high byte
84E5  7E      		LD	A,(HL)			;Add high bytes
84E6  8A      		ADC	A,D			;
84E7  77      		LD	(HL),A			;Store result
84E8  C36680  		JP	NEXT
		
84EB          	W_TOGGLE	;XOR (addr) with byte
84EB  86544F47		DB	$86,'TOGGL','E'+$80
      474CC5
84F2  D884    		DW	W_PLUSSTORE
84F4          	C_TOGGLE
84F4  F684    		DW	2+$			;Vector to code
84F6  D1      		POP	DE			;Get byte
84F7  E1      		POP	HL			;Get addr
84F8  7E      		LD	A,(HL)			;Get byte from addr
84F9  AB      		XOR	E			;Toggle it
84FA  77      		LD	(HL),A			;Save result
84FB  C36680  		JP	NEXT
		
84FE          	W_FETCH		;Get word from addr on stack
84FE  81C0    		DB	$81,'@'+$80
8500  EB84    		DW	W_TOGGLE
8502          	C_FETCH
8502  0485    		DW	2+$			;Vector to code
8504  E1      		POP	HL			;Get addr
8505  5E      		LD	E,(HL)			;Get low byte
8506  23      		INC	HL			;
8507  56      		LD	D,(HL)			;Get high byte
8508  D5      		PUSH	DE			;Save it
8509  C36680  		JP	NEXT
		
850C          	W_CFETCH	;Get byte from addr on stack
850C  8243C0  		DB	$82,'C','@'+$80
850F  FE84    		DW	W_FETCH
8511          	C_CFETCH
8511  1385    		DW	2+$			;Vector to code
8513  E1      		POP	HL			;Get addr
8514  6E      		LD	L,(HL)			;Get byte
8515  2600    		LD	H,$00			;Top byte = 0
8517  C36580  		JP	NEXTS1			;Save & NEXT
		
851A          	W_2FETCH	;Get word from addr+2 and addr
851A  8232C0  		DB	$82,'2','@'+$80
851D  0C85    		DW	W_CFETCH
851F          	C_2FETCH
851F  2185    		DW	2+$			;Vector to code
8521  E1      		POP	HL			;Get addr
8522  110200  		LD	DE,0002			;Plus 2 bytes
8525  19      		ADD	HL,DE			;Get 2nd word first
8526  5E      		LD	E,(HL)			;Low byte
8527  23      		INC	HL			;
8528  56      		LD	D,(HL)			;High byte
8529  D5      		PUSH	DE			;Save it
852A  11FDFF  		LD	DE,$FFFD		;Minus 2 bytes
852D  19      		ADD	HL,DE			;Get 1st word
852E  5E      		LD	E,(HL)			;Low byte
852F  23      		INC	HL			;
8530  56      		LD	D,(HL)			;High byte
8531  D5      		PUSH	DE			;Save it
8532  C36680  		JP	NEXT
		
8535          	W_STORE		;Store word at addr
8535  81A1    		DB	$81,'!'+$80
8537  1A85    		DW	W_2FETCH
8539          	C_STORE
8539  3B85    		DW	2+$			;Vector to code
853B  E1      		POP	HL			;Get addr
853C  D1      		POP	DE			;Get word
853D  73      		LD	(HL),E			;Store low byte
853E  23      		INC	HL			;
853F  72      		LD	(HL),D			;Store high byte
8540  C36680  		JP	NEXT
		
8543          	W_CSTORE	;Store byte at addr
8543  8243A1  		DB	$82,'C','!'+$80
8546  3585    		DW	W_STORE
8548          	C_CSTORE
8548  4A85    		DW	2+$			;Vector to code
854A  E1      		POP	HL			;Get addr
854B  D1      		POP	DE			;Get byte
854C  73      		LD	(HL),E			;Save it
854D  C36680  		JP	NEXT
		
8550          	W_2STORE	;Store 2 words at addr (+2)
8550  8232A1  		DB	$82,'2','!'+$80
8553  4385    		DW	W_CSTORE
8555          	C_2STORE
8555  5785    		DW	2+$			;Vector to code
8557  E1      		POP	HL			;Get addr
8558  D1      		POP	DE			;Get word
8559  73      		LD	(HL),E			;Save low byte
855A  23      		INC	HL			;
855B  72      		LD	(HL),D			;Save high byte
855C  23      		INC	HL			;
855D  D1      		POP	DE			;Get next word
855E  73      		LD	(HL),E			;Save low byte
855F  23      		INC	HL			;
8560  72      		LD	(HL),D			;Save high byte
8561  C36680  		JP	NEXT
		
8564          	W_COLON
8564  8180    		DB	$81,$80
8566  5085    		DW	W_2STORE
8568          	C_COLON
8568  7C85    		DW	E_COLON			;Interpret following word sequence
856A  D38A    		DW	C_QEXEC			;Error not if not in execute mode
856C  8E8A    		DW	C_CSPSTORE		;Set current stack pointer value
856E  0D87    		DW	C_CURRENT		;Get CURRENT addr
8570  0285    		DW	C_FETCH			;Get word from addr on stack
8572  FF86    		DW	C_CONTEXT		;Make CONTEXT current vocab
8574  3985    		DW	C_STORE			;Store word at addr
8576  778F    		DW	C_XXX1			;Puts name into dictionary
8578  588B    		DW	C_RIGHTBRKT		;Set STATE to compile
857A  AB8B    		DW	C_CCODE			;Execute following machine code
		
857C          	E_COLON
857C  2A46FE  		LD	HL,(RPP)		;Get return stack pointer
857F  2B      		DEC	HL			;Put BC on return stack
8580  70      		LD	(HL),B			;
8581  2B      		DEC	HL			;
8582  71      		LD	(HL),C			;
8583  2246FE  		LD	(RPP),HL		;Save new pointer
8586  13      		INC	DE
8587  4B      		LD	C,E
8588  42      		LD	B,D
8589  C36680  		JP	NEXT
		
858C          	W_SEMICOLON	;Terminate compilation
858C  C1BB    		DB	$C1,';'+$80
858E  6485    		DW	W_COLON
8590          	C_SEMICOLON
8590  7C85    		DW	E_COLON			;Interpret following word sequence
8592  BB8A    		DW	C_QCOMP			;Check we're allready compiling
8594  FD8A    		DW	C_WHATSTACK		;Check stack pointer, error if not ok
8596  348B    		DW	C_COMPILE		;Compile next word into dictionary
8598  8A83    		DW	C_STOP			;
859A  6D8B    		DW	C_SMUDGE		;Smudge bit to O.K.
859C  4A8B    		DW	C_LEFTBRKT		;Set STATE to execute
859E  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
85A0          	W_CONSTANT
85A0  88434F4E		DB	$88,'CONSTAN','T'+$80
      5354414E
      D4
85A9  8C85    		DW	W_SEMICOLON
85AB          	C_CONSTANT
85AB  7C85    		DW	E_COLON			;Interpret following word sequence
85AD  778F    		DW	C_XXX1
85AF  6D8B    		DW	C_SMUDGE
85B1  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
85B3  AB8B    		DW	C_CCODE			;Execute following machine code
		
85B5          	X_CONSTANT				;Put next word on stack
85B5  13      		INC	DE			;Adjust pointer
85B6  EB      		EX	DE,HL			;Get next word
85B7  5E      		LD	E,(HL)			;
85B8  23      		INC	HL			;
85B9  56      		LD	D,(HL)			;
85BA  D5      		PUSH	DE			;Put on stack
85BB  C36680  		JP	NEXT
		
85BE          	W_VARIABLE
85BE  88564152		DB	$88,'VARIABL','E'+$80
      4941424C
      C5
85C7  A085    		DW	W_CONSTANT
85C9          	C_VARIABLE
85C9  7C85    		DW	E_COLON			;Interpret following word sequence
85CB  F385    		DW	C_ZERO			;Put zero on stack
85CD  AB85    		DW	C_CONSTANT
85CF  AB8B    		DW	C_CCODE			;Execute following machine code
		
85D1          	X_VARIABLE
85D1  13      		INC	DE
85D2  D5      		PUSH	DE
85D3  C36680  		JP	NEXT
		
85D6          	W_USER
85D6  84555345		DB	$84,'USE','R'+$80
      D2
85DB  BE85    		DW	W_VARIABLE
85DD          	C_USER
85DD  7C85    		DW	E_COLON			;Interpret following word sequence
85DF  AB85    		DW	C_CONSTANT
85E1  AB8B    		DW	C_CCODE			;Execute following machine code
		
85E3          	X_USER
85E3  13      		INC	DE			;Adjust to next word
85E4  EB      		EX	DE,HL
85E5  5E      		LD	E,(HL)
85E6  23      		INC	HL
85E7  56      		LD	D,(HL)
85E8  2A2280  		LD	HL,(DEF_SYSADDR)
85EB  19      		ADD	HL,DE
85EC  C36580  		JP	NEXTS1			;Save & NEXT
		
85EF          	W_ZERO		;Put zero on stack
85EF  81B0    		DB	$81,'0'+$80
85F1  D685    		DW	W_USER
85F3          	C_ZERO
85F3  B585    		DW	X_CONSTANT		;Put next word on stack
85F5  0000    		DW	$0000
		
85F7          	W_1		;Put 1 on stack
85F7  81B1    		DB	$81,'1'+$80
85F9  EF85    		DW	W_ZERO
85FB          	C_1
85FB  B585    		DW	X_CONSTANT		;Put next word on stack
85FD  0100    		DW	$0001
		
85FF          	W_2
85FF  81B2    		DB	$81,'2'+$80
8601  F785    		DW	W_1
8603          	C_2
8603  B585    		DW	X_CONSTANT		;Put next word on stack
8605  0200    		DW	$0002
		
8607          	W_3
8607  81B3    		DB	$81,'3'+$80
8609  FF85    		DW	W_2
860B          	C_3
860B  B585    		DW	X_CONSTANT		;Put next word on stack
860D  0300    		DW	$0003
		
860F          	W_BL		;Leaves ASCII for blank on stack
860F  8242CC  		DB	$82,'B','L'+$80
8612  0786    		DW	W_3
8614          	C_BL
8614  B585    		DW	X_CONSTANT		;Put next word on stack
8616  2000    		DW	$0020
		
8618          	W_CL
8618  83432FCC		DB	$83,'C/','L'+$80
861C  0F86    		DW	W_BL
861E          	C_CL
861E  7C85    		DW	E_COLON			;Interpret following word sequence
8620  6087    		DW	C_UCL
8622  0285    		DW	C_FETCH			;Get word from addr on stack
8624  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8626          	W_FIRST
8626  85464952		DB	$85,'FIRS','T'+$80
      53D4
862C  1886    		DW	W_CL
862E          	C_FIRST
862E  7C85    		DW	E_COLON			;Interpret following word sequence
8630  6D87    		DW	C_UFIRST		;Put UFIRST addr on stack
8632  0285    		DW	C_FETCH			;Get word from addr on stack
8634  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8636          	W_LIMIT
8636  854C494D		DB	$85,'LIMI','T'+$80
      49D4
863C  2686    		DW	W_FIRST
863E          	C_LIMIT
863E  7C85    		DW	E_COLON			;Interpret following word sequence
8640  7A87    		DW	C_ULIMIT		;Put ULIMIT on stack
8642  0285    		DW	C_FETCH			;Get word from addr on stack
8644  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8646          	W_BBUF
8646  85422F42		DB	$85,'B/BU','F'+$80
      55C6
864C  3686    		DW	W_LIMIT
864E          	C_BBUF
864E  7C85    		DW	E_COLON			;Interpret following word sequence
8650  8787    		DW	C_UBBUF
8652  0285    		DW	C_FETCH			;Get word from addr on stack
8654  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8656          	W_BSCR
8656  85422F53		DB	$85,'B/SC','R'+$80
      43D2
865C  4686    		DW	W_BBUF
865E          	C_BSCR
865E  7C85    		DW	E_COLON			;Interpret following word sequence
8660  9487    		DW	C_UBSCR			;Number of buffers per block
8662  0285    		DW	C_FETCH			;Get word from addr on stack
8664  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8666          	W_S0		;Push S0 (initial data stack pointer)
8666  8253B0  		DB	$82,'S','0'+$80
8669  5686    		DW	W_BSCR
866B          	C_S0
866B  E385    		DW	X_USER			;Put next word on stack then do next
866D  0600    		DW	S0-SYSTEM
		
866F          	W_R0
866F  8252B0  		DB	$82,'R','0'+$80
8672  6686    		DW	W_S0
8674          	C_R0
8674  E385    		DW	X_USER			;Put next word on stack then do next
8676  0800    		DW	R0-SYSTEM
		
8678          	W_TIB
8678  835449C2		DB	$83,'TI','B'+$80
867C  6F86    		DW	W_R0
867E          	C_TIB
867E  E385    		DW	X_USER			;Put next word on stack then do next
8680  0A00    		DW	TIB-SYSTEM
		
8682          	W_WIDTH
8682  85574944		DB	$85,'WIDT','H'+$80
      54C8
8688  7886    		DW	W_TIB
868A          	C_WIDTH
868A  E385    		DW	X_USER			;Put next word on stack then do next
868C  0C00    		DW	WIDTH-SYSTEM
		
868E          	W_WARNING	;Put WARNING addr on stack
868E  87574152		DB	$87,'WARNIN','G'+$80
      4E494EC7
8696  8286    		DW	W_WIDTH
8698          	C_WARNING
8698  E385    		DW	X_USER			;Put next word on stack then do next
869A  0E00    		DW	WARNING-SYSTEM
		
869C          	W_FENCE
869C  8546454E		DB	$85,'FENC','E'+$80
      43C5
86A2  8E86    		  	DW	W_WARNING
86A4          	C_FENCE
86A4  E385    		DW	X_USER			;Put next word on stack then do next
86A6  1000    		DW	FENCE-SYSTEM
		
86A8          	W_DP		;Dictionary pointer addr on stack
86A8  8244D0  		DB	$82,'D','P'+$80
86AB  9C86    		DW	W_FENCE
86AD          	C_DP
86AD  E385    		DW	X_USER			;Put next word on stack then do next
86AF  1200    		DW	DP-SYSTEM
		
86B1          	W_VOC_LINK
86B1  88564F43		DB	$88,'VOC-LIN','K'+$80
      2D4C494E
      CB
86BA  A886    		DW	W_DP
86BC          	C_VOC_LINK
86BC  E385    		DW	X_USER			;Put next word on stack then do next
86BE  1400    		DW	VOC_LINK-SYSTEM
		
86C0          	W_BLK
86C0  83424CCB		DB	$83,'BL','K'+$80
86C4  B186    		DW	W_VOC_LINK
86C6          	C_BLK
86C6  E385    		DW	X_USER			;Put next word on stack then do next
86C8  1600    		DW	BLK-SYSTEM
		
86CA          	W_TOIN
86CA  833E49CE		DB	$83,'>I','N'+$80
86CE  C086    		DW	W_BLK
86D0          	C_TOIN
86D0  E385    		DW	X_USER			;Put next word on stack then do next
86D2  1800    		DW	TOIN-SYSTEM
		
86D4          	W_OUT		;Put OUT buffer count addr on stack
86D4  834F55D4		DB	$83,'OU','T'+$80
86D8  CA86    		DW	W_TOIN
86DA          	C_OUT
86DA  E385    		DW	X_USER			;Put next word on stack then do next
86DC  1A00    		DW	OUT_-SYSTEM
		
86DE          	W_SCR
86DE  835343D2		DB	$83,'SC','R'+$80
86E2  D486    		DW	W_OUT
86E4          	C_SCR
86E4  E385    		DW	X_USER			;Put next word on stack then do next
86E6  1C00    		DW	SCR-SYSTEM
		
86E8          	W_OFFSET	;Put disk block offset on stack
86E8  864F4646		DB	$86,'OFFSE','T'+$80
      5345D4
86EF  DE86    		DW	W_SCR
86F1          	C_OFFSET
86F1  E385    		DW	X_USER			;Put next word on stack then do next
86F3  1E00    		DW	OFFSET-SYSTEM
		
86F5          	W_CONTEXT
86F5  87434F4E		DB	$87,'CONTEX','T'+$80
      544558D4
86FD  E886    		DW	W_OFFSET
86FF          	C_CONTEXT
86FF  E385    		DW	X_USER			;Put next word on stack then do next
8701  2000    		DW	CONTEXT-SYSTEM
		
8703          	W_CURRENT
8703  87435552		DB	$87,'CURREN','T'+$80
      52454ED4
870B  F586    		DW	W_CONTEXT
870D          	C_CURRENT
870D  E385    		DW	X_USER			;Put next word on stack then do next
870F  2200    		DW	CURRENT-SYSTEM
		
8711          	W_STATE		;Push STATE addr
8711  85535441		DB	$85,'STAT','E'+$80
      54C5
8717  0387    		DW	W_CURRENT
8719          	C_STATE
8719  E385    		DW	X_USER			;Put next word on stack then do next
871B  2400    		DW	STATE-SYSTEM
		
871D          	W_BASE		;Put BASE addr on stack
871D  84424153		DB	$84,'BAS','E'+$80
      C5
8722  1187    		DW	W_STATE
8724          	C_BASE
8724  E385    		DW	X_USER			;Put next word on stack then do next
8726  2600    		DW	BASE-SYSTEM
		
8728          	W_DPL
8728  834450CC		DB	$83,'DP','L'+$80
872C  1D87    		DW	W_BASE
872E          	C_DPL
872E  E385    		DW	X_USER			;Put next word on stack then do next
8730  2800    		DW	DPL-SYSTEM
		
8732          	W_FLD
8732  83464CC4		DB	$83,'FL','D'+$80
8736  2887    		DW	W_DPL
8738          	C_FLD
8738  E385    		DW	X_USER			;Put next word on stack then do next
873A  2A00    		DW	FLD-SYSTEM
		
873C          	W_CSP		;Push check stack pointer addr
873C  834353D0		DB	$83,'CS','P'+$80
8740  3287    		DW	W_FLD
8742          	C_CSP
8742  E385    		DW	X_USER			;Put next word on stack then do next
8744  2C00    		DW	CSP-SYSTEM
		
8746          	W_RHASH
8746  8252A3  		DB	$82,'R','#'+$80
8749  3C87    		DW	W_CSP
874B          	C_RHASH
874B  E385    		DW	X_USER			;Put next word on stack then do next
874D  2E00    		DW	RHASH-SYSTEM
		
874F          	W_HLD
874F  83484CC4		DB	$83,'HL','D'+$80
8753  4687    		DW	W_RHASH
8755          	C_HLD
8755  E385    		DW	X_USER			;Put next word on stack then do next
8757  3000    		DW	HLD-SYSTEM
		
8759          	W_UCL
8759  8455432F		DB	$84,'UC/','L'+$80
      CC
875E  4F87    		DW	W_HLD
8760          	C_UCL
8760  E385    		DW	X_USER			;Put next word on stack then do next
8762  5C00    		DW	UCL-SYSTEM
		
8764          	W_UFIRST
8764  86554649		DB	$86,'UFIRS','T'+$80
      5253D4
876B  5987    		DW	W_UCL
876D          	C_UFIRST
876D  E385    		DW	X_USER			;Put next word on stack then do next
876F  5E00    		DW	UFIRST-SYSTEM
		
8771          	W_ULIMIT
8771  86554C49		DB	$86,'ULIMI','T'+$80
      4D49D4
8778  6487    		DW	W_UFIRST
877A          	C_ULIMIT
877A  E385    		DW	X_USER			;Put next word on stack then do next
877C  6000    		DW	ULIMIT-SYSTEM
		
877E          	W_UBBUF
877E  8655422F		DB	$86,'UB/BU','F'+$80
      4255C6
8785  7187    		DW	W_ULIMIT
8787          	C_UBBUF
8787  E385    		DW	X_USER			;Put next word on stack then do next
8789  6200    		DW	UBBUF-SYSTEM
		
878B          	W_UBSCR
878B  8655422F		DB	$86,'UB/SC','R'+$80
      5343D2
8792  7E87    		DW	W_UBBUF
8794          	C_UBSCR
8794  E385    		DW	X_USER			;Put next word on stack then do next
8796  6400    		DW	UBSCR-SYSTEM
		
8798          	W_UTERMINAL
8798  8A553F54		DB	$8A,'U?TERMINA','L'+$80
      45524D49
      4E41CC
87A3  8B87    		DW	W_UBSCR
87A5          	C_UTERMINAL
87A5  E385    		DW	X_USER			;Put next word on stack then do next
87A7  5000    		DW	UTERMINAL-SYSTEM
		
87A9          	W_UKEY		;Put UKEY addr on stack
87A9  84554B45		DB	$84,'UKE','Y'+$80
      D9
87AE  9887    		DW	W_UTERMINAL
87B0          	C_UKEY
87B0  E385    		DW	X_USER			;Put next word on stack then do next
87B2  5200    		DW	UKEY-SYSTEM
		
87B4          	W_UEMIT		;Put UEMIT addr on stack
87B4  8555454D		DB	$85,'UEMI','T'+$80
      49D4
87BA  A987    		DW	W_UKEY
87BC          	C_UEMIT
87BC  E385    		DW	X_USER			;Put next word on stack then do next
87BE  5400    		DW	UEMIT-SYSTEM
		
87C0          	W_UCR		;Push UCR addr
87C0  835543D2		DB	$83,'UC','R'+$80
87C4  B487    		DW	W_UEMIT
87C6          	C_UCR
87C6  E385    		DW	X_USER			;Put next word on stack then do next
87C8  5800    		DW	UCR-SYSTEM
		
87CA          	W_URW
87CA  8455522F		DB	$84,'UR/','W'+$80
      D7
87CF  C087    		DW	W_UCR
87D1          	C_URW
87D1  E385    		DW	X_USER			;Put next word on stack then do next
87D3  5600    		DW	URW-SYSTEM
		
87D5          	W_UABORT	;Put UABORT on stack
87D5  86554142		DB	$86,'UABOR','T'+$80
      4F52D4
87DC  CA87    		DW	W_URW
87DE          	C_UABORT
87DE  E385    		DW	X_USER			;Put next word on stack then do next
87E0  5A00    		DW	UABORT-SYSTEM
		
87E2          	W_RAF
87E2  835241C6		DB	$83,'RA','F'+$80
87E6  D587    		DW	W_UABORT
87E8          	C_RAF
87E8  E385    		DW	X_USER			;Put next word on stack then do next
87EA  6800    		DW	RAF-SYSTEM
		
87EC          	W_RBC
87EC  835242C3		DB	$83,'RB','C'+$80
87F0  E287    		DW	W_RAF
87F2          	C_RBC
87F2  E385    		DW	X_USER			;Put next word on stack then do next
87F4  6A00    		DW	RBC-SYSTEM
		
87F6          	W_RDE
87F6  835244C5		DB	$83,'RD','E'+$80
87FA  EC87    		DW	W_RBC
87FC          	C_RDE
87FC  E385    		DW	X_USER			;Put next word on stack then do next
87FE  6C00    		DW	RDE-SYSTEM
		
8800          	W_RHL
8800  835248CC		DB	$83,'RH','L'+$80
8804  F687    		DW	W_RDE
8806          	C_RHL
8806  E385    		DW	X_USER			;Put next word on stack then do next
8808  6E00    		DW	RHL-SYSTEM
		
880A          	W_RIX
880A  835249D8		DB	$83,'RI','X'+$80
880E  0088    		DW	W_RHL
8810          	C_RIX
8810  E385    		DW	X_USER			;Put next word on stack then do next
8812  7000    		DW	RIX-SYSTEM
		
8814          	W_RIY
8814  835249D9		DB	$83,'RI','Y'+$80
8818  0A88    		DW	W_RIX
881A          	C_RIY
881A  E385    		DW	X_USER			;Put next word on stack then do next
881C  7200    		DW	RIY-SYSTEM
		
881E          	W_RAF2
881E  84524146		DB	$84,'RAF',$2C+$80
      AC
8823  1488    		DW	W_RIY
8825          	C_RAF2
8825  E385    		DW	X_USER			;Put next word on stack then do next
8827  7400    		DW	RAF2-SYSTEM
		
8829          	W_RBC2
8829  84524243		DB	$84,'RBC',$2C+$80
      AC
882E  1E88    		DW	W_RAF2
8830          	C_RBC2
8830  E385    		DW	X_USER			;Put next word on stack then do next
8832  7600    		DW	RBC2-SYSTEM
		
8834          	W_RDE2
8834  84524445		DB	$84,'RDE',$2C+$80
      AC
8839  2988    		DW	W_RBC2
883B          	C_RDE2
883B  E385    		DW	X_USER			;Put next word on stack then do next
883D  7800    		DW	RDE2-SYSTEM
		
883F          	W_RHL2
883F  8452484C		DB	$84,'RHL',$2C+$80
      AC
8844  3488    		DW	W_RDE2
8846          	C_RHL2
8846  E385    		DW	X_USER			;Put next word on stack then do next
8848  7A00    		DW	RHL2-SYSTEM
		
884A          	W_RA
884A  8252C1  		DB	$82,'R','A'+$80
884D  3F88    		DW	W_RHL2
884F          	C_RA
884F  E385    		DW	X_USER			;Put next word on stack then do next
8851  6900    		DW	RAF+1-SYSTEM
		
8853          	W_RF
8853  8252C6  		DB	$82,'R','F'+$80
8856  4A88    		DW	W_RA
8858          	C_RF
8858  E385    		DW	X_USER			;Put next word on stack then do next
885A  6800    		DW	RAF-SYSTEM
		
885C          	W_RB
885C  8252C2  		DB	$82,'R','B'+$80
885F  5388    		DW	W_RF
8861          	C_RB
8861  E385    		DW	X_USER			;Put next word on stack then do next
8863  6B00    		DW	RBC+1-SYSTEM
		
8865          	W_RC
8865  8252C3  		DB	$82,'R','C'+$80
8868  5C88    		DW	W_RB
886A          	C_RC
886A  E385    		DW	X_USER			;Put next word on stack then do next
886C  6A00    		DW	RBC-SYSTEM
		
886E          	W_RD
886E  8252C4  		DB	$82,'R','D'+$80
8871  6588    		DW	W_RC
8873          	C_RD
8873  E385    		DW	X_USER			;Put next word on stack then do next
8875  6D00    		DW	RDE+1-SYSTEM
		
8877          	W_RE
8877  8252C5  		DB	$82,'R','E'+$80
887A  6E88    		DW	W_RD
887C          	C_RE
887C  E385    		DW	X_USER			;Put next word on stack then do next
887E  6C00    		DW	RDE-SYSTEM
		
8880          	W_RH
8880  8252C8  		DB	$82,'R','H'+$80
8883  7788    		DW	W_RE
8885          	C_RH
8885  E385    		DW	X_USER			;Put next word on stack then do next
8887  6F00    		DW	RHL+1-SYSTEM
		
8889          	W_RL
8889  8252CC  		DB	$82,'R','L'+$80
888C  8088    		DW	W_RH
888E          	C_RL
888E  E385    		DW	X_USER			;Put next word on stack then do next
8890  6E00    		DW	RHL-SYSTEM
		
8892          	W_CALL
8892  8443414C		DB	$84,'CAL','L'+$80
      CC
8897  8988    		DW	W_RL
8899          	C_CALL
8899  9B88    		DW	2+$			;Vector to code
889B  E1      		POP	HL			;Address of routine CALLed
889C  D5      		PUSH	DE			;Save register
889D  C5      		PUSH	BC			;Save register
889E  3EC3    		LD	A,$C3			;Hex code for JMP
88A0  327DFE  		LD	(JPCODE),A		;Save it
88A3  227EFE  		LD	(JPVECT),HL		;Save jump vector
88A6  2A68FE  		LD	HL,(RAF)		;Get register AF
88A9  E5      		PUSH	HL			;Onto stack
88AA  F1      		POP	AF			;POP into AF
88AB  ED4B6AFE		LD	BC,(RBC)		;Get register BC
88AF  ED5B6CFE		LD	DE,(RDE)		;Get register DE
88B3  2A6EFE  		LD	HL,(RHL)		;Get register HL
88B6  DD2A70FE		LD	IX,(RIX)		;Get register IX
88BA  FD2A72FE		LD	IY,(RIY)		;Get register IY
88BE  CD7DFE  		CALL	JPCODE			;Call jump to code
88C1  FD2272FE		LD	(RIY),IY		;Save register IY
88C5  DD2270FE		LD	(RIX),IX		;Save register IX
88C9  ED436AFE		LD	(RBC),BC		;Save register BC
88CD  ED536CFE		LD	(RDE),DE		;Save register DE
88D1  226EFE  		LD	(RHL),HL		;Save register HL
88D4  F5      		PUSH	AF			;Save register AF
88D5  E1      		POP	HL			;Into HL
88D6  2268FE  		LD	(RAF),HL		;Into memory
88D9  C1      		POP	BC			;Restore BC
88DA  D1      		POP	DE			;Restore DE
88DB  C36680  		JP	NEXT			;
		
88DE          	W_1PLUS		;1 plus
88DE  8231AB  		DB	$82,'1','+'+$80
88E1  9288    		DW	W_CALL
88E3          	C_1PLUS
88E3  E588    		DW	2+$			;Vector to code
88E5  E1      		POP	HL			; get n
88E6  23      		INC	HL			; add 1
88E7  C36580  		JP	NEXTS1			; save result & NEXT
		
88EA          	W_2PLUS		;2 plus
88EA  8232AB  		DB	$82,'2','+'+$80
88ED  DE88    		DW	W_1PLUS
88EF          	C_2PLUS
88EF  F188    		DW	2+$			;Vector to code
88F1  E1      		POP	HL			; get n
88F2  23      		INC	HL			; add 1
88F3  23      		INC	HL			; add 2
88F4  C36580  		JP	NEXTS1			; save result & NEXT
		
88F7          	W_1MINUS	;1 minus
88F7  8231AD  		DB	$82,'1','-'+$80
88FA  EA88    		DW	W_2PLUS
88FC          	C_1MINUS
88FC  FE88    		DW	2+$			;Vector to code
88FE  E1      		POP	HL			; get n
88FF  2B      		DEC	HL			; add 1
8900  C36580  		JP	NEXTS1			; save result & NEXT
		
8903          	W_2MINUS	;2 minus
8903  8232AD  		DB	$82,'2','-'+$80
8906  F788    		DW	W_1MINUS
8908          	C_2MINUS
8908  0A89    		DW	2+$			;Vector to code
890A  E1      		POP	HL			; get n
890B  2B      		DEC	HL			; subtract 1
890C  2B      		DEC	HL			; subtract 2
890D  C36580  		JP	NEXTS1			; save result & NEXT
		
8910          	W_HERE		;Dictionary pointer onto stack
8910  84484552		DB	$84,'HER','E'+$80
      C5
8915  0389    		DW	W_2MINUS
8917          	C_HERE
8917  7C85    		DW	E_COLON			;Interpret following word sequence
8919  AD86    		DW	C_DP			;Dictionary pointer addr on stack
891B  0285    		DW	C_FETCH			;Get word from addr on stack
891D  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
891F          	W_ALLOT
891F  85414C4C		DB	$85,'ALLO','T'+$80
      4FD4
8925  1089    		DW	W_HERE
8927          	C_ALLOT
8927  7C85    		DW	E_COLON			;Interpret following word sequence
8929  AD86    		DW	C_DP			;Dictionary pointer addr on stack
892B  DD84    		DW	C_PLUSSTORE		;Add n1 to addr
892D  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
892F          	W_COMMA		;Reserve 2 bytes and save n
892F  81AC    		DB	$81,','+$80
8931  1F89    		DW	W_ALLOT
8933          	C_COMMA
8933  7C85    		DW	E_COLON			;Interpret following word sequence
8935  1789    		DW	C_HERE			;Next free dictionary pointer onto stack
8937  3985    		DW	C_STORE			;Store word at addr
8939  0386    		DW	C_2			;
893B  2789    		DW	C_ALLOT			;Move pointer
893D  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
893F          	W_CCOMMA
893F  8243AC  		DB	$82,'C',','+$80
8942  2F89    		DW	W_COMMA
8944          	C_CCOMMA
8944  7C85    		DW	E_COLON			;Interpret following word sequence
8946  1789    		DW	C_HERE			;Dictionary pointer onto stack
8948  4885    		DW	C_CSTORE		;Store byte at addr
894A  FB85    		DW	C_1			;Put 1 on stack
894C  2789    		DW	C_ALLOT
894E  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8950          	W_MINUS
8950  81AD    		DB	$81,'-'+$80
8952  3F89    		DW	W_CCOMMA
8954          	C_MINUS
8954  5689    		DW	2+$			;Vector to code
8956  D1      		POP	DE			; get n1
8957  E1      		POP	HL			; get n2
8958  CD5E89  		CALL	MINUS16			; call subtract routine
895B  C36580  		JP	NEXTS1			; save & NEXT
		
895E          	MINUS16
895E  7D      		LD	A,L			; gel low byte
895F  93      		SUB	E			; subtract low bytes
8960  6F      		LD	L,A			; save low byte result
8961  7C      		LD	A,H			; get high byte
8962  9A      		SBC	A,D			; subtract high bytes
8963  67      		LD	H,A			; save high byte result
8964  C9      		RET				;
		
8965          	W_EQUALS
8965  81BD    		DB	$81,'='+$80
8967  5089    		DW	W_MINUS
8969          	C_EQUALS
8969  7C85    		DW	E_COLON			;Interpret following word sequence
896B  5489    		DW	C_MINUS
896D  E783    		DW	C_0EQUALS		;=0
896F  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8971          	W_LESSTHAN
8971  81BC    		DB	$81,'<'+$80
8973  6589    		DW	W_EQUALS
8975          	C_LESSTHAN
8975  7789    		DW	2+$			;Vector to code
8977  D1      		POP	DE
8978  E1      		POP	HL
8979  7A      		LD	A,D
897A  AC      		XOR	H
897B  FA8189  		JP	M,J298C
897E  CD5E89  		CALL	MINUS16
8981          	J298C
8981  24      		INC	H
8982  25      		DEC	H
8983  FA8C89  		JP	M,J2997
8986  210000  		LD	HL,0000
8989  C36580  		JP	NEXTS1			;Save & NEXT
898C          	J2997
898C  210100  		LD	HL,0001
898F  C36580  		JP	NEXTS1			;Save & NEXT
		
8992          	W_ULESS		;IF stack-1 < stack_top leave true flag
8992  8255BC  		DB	$82,'U','<'+$80
8995  7189    		DW	W_LESSTHAN
8997          	C_ULESS
8997  7C85    		DW	E_COLON			;Interpret following word sequence
8999  BD84    		DW	C_2DUP			;Dup top 2 values on stack
899B  2B83    		DW	C_XOR			;Exclusive OR them
899D  0284    		DW	C_0LESS			;Less than 0
899F  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
89A1  0C00    		DW	B0000-$			;000Ch
89A3  8684    		DW	C_DROP			;Drop top value from stack
89A5  0284    		DW	C_0LESS			;Less than 0
89A7  E783    		DW	C_0EQUALS		;=0
89A9  B080    		DW	C_BRANCH		;Add following offset to BC
89AB  0600    		DW	B0001-$			;0006h
89AD          	B0000
89AD  5489    		DW	C_MINUS
89AF  0284    		DW	C_0LESS			;Less than 0
89B1          	B0001
89B1  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
89B3          	W_GREATER
89B3  81BE    		DB	$81,'>'+$80
89B5  9289    		DW	W_ULESS
89B7          	C_GREATER
89B7  7C85    		DW	E_COLON			;Interpret following word sequence
89B9  A284    		DW	C_SWAP			;Swap top 2 values on stack
89BB  7589    		DW	C_LESSTHAN
89BD  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
89BF          	W_ROT		;3rd valu down to top of stack
89BF  83524FD4		DB	$83,'RO','T'+$80
89C3  B389    		DW	W_GREATER
89C5          	C_ROT
89C5  C789    		DW	2+$			;Vector to code
89C7  D1      		POP	DE			;Top value
89C8  E1      		POP	HL			;Next one down
89C9  E3      		EX	(SP),HL			;Exchange with third
89CA  C36480  		JP	NEXTS2			;Save both & NEXT
		
89CD          	W_PICK
89CD  84504943		DB	$84,'PIC','K'+$80
      CB
89D2  BF89    		DW	W_ROT
89D4          	C_PICK
89D4  7C85    		DW	E_COLON			;Interpret following word sequence
89D6  AF84    		DW	C_DUP			;Duplicate top value on stack
89D8  1384    		DW	C_PLUS			;n1 + n2
89DA  3E83    		DW	C_SPFETCH		;Stack pointer onto stack
89DC  1384    		DW	C_PLUS			;n1 + n2
89DE  0285    		DW	C_FETCH			;Get word from addr on stack
89E0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
89E2          	W_SPACE
89E2  85535041		DB	$85,'SPAC','E'+$80
      43C5
89E8  CD89    		DW	W_PICK
89EA          	C_SPACE
89EA  7C85    		DW	E_COLON			;Interpret following word sequence
89EC  1486    		DW	C_BL			;Leaves ASCII for space on stack
89EE  1582    		DW	C_EMIT			;Output CHR from stack
89F0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
89F2          	W_QUERYDUP
89F2  843F4455		DB	$84,'?DU','P'+$80
      D0
89F7  E289    		DW	W_SPACE
89F9          	C_QUERYDUP
89F9  7C85    		DW	E_COLON			;Interpret following word sequence
89FB  AF84    		DW	C_DUP			;Duplicate top value on stack
89FD  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
89FF  0400    		DW	B0002-$			;$0004
8A01  AF84    		DW	C_DUP			;Duplicate top value on stack
8A03          	B0002
8A03  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8A05          	W_TRAVERSE
8A05  88545241		DB	$88,'TRAVERS','E'+$80
      56455253
      C5
8A0E  F289    		DW	W_QUERYDUP
8A10          	C_TRAVERSE
8A10  7C85    		DW	E_COLON			;Interpret following word sequence
8A12  A284    		DW	C_SWAP			;Swap top 2 values on stack
8A14          	B0054
8A14  7784    		DW	C_OVER			;Copy 2nd down to top of stack
8A16  1384    		DW	C_PLUS			;n1 + n2
8A18  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8A1A  7F00    		DW	$007F
8A1C  7784    		DW	C_OVER			;Copy 2nd down to top of stack
8A1E  1185    		DW	C_CFETCH		;Get byte from addr on stack
8A20  7589    		DW	C_LESSTHAN
8A22  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8A24  F0FF    		DW	B0054-$			;FFF0h
8A26  A284    		DW	C_SWAP			;Swap top 2 values on stack
8A28  8684    		DW	C_DROP			;Drop top value from stack
8A2A  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8A2C          	W_LATEST
8A2C  864C4154		DB	$86,'LATES','T'+$80
      4553D4
8A33  058A    		DW	W_TRAVERSE
8A35          	C_LATEST
8A35  7C85    		DW	E_COLON			;Interpret following word sequence
8A37  0D87    		DW	C_CURRENT
8A39  0285    		DW	C_FETCH			;Get word from addr on stack
8A3B  0285    		DW	C_FETCH			;Get word from addr on stack
8A3D  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8A3F          	W_LFA
8A3F  834C46C1		DB	$83,'LF','A'+$80
8A43  2C8A    		DW	W_LATEST
8A45          	C_LFA
8A45  7C85    		DW	E_COLON			;Interpret following word sequence
8A47  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8A49  0400    		DW	$0004
8A4B  5489    		DW	C_MINUS
8A4D  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8A4F          	W_CFA
8A4F  834346C1		DB	$83,'CF','A'+$80
8A53  3F8A    		DW	W_LFA
8A55          	C_CFA
8A55  578A    		DW	2+$			;Vector to code
8A57  E1      		POP	HL			; get n
8A58  2B      		DEC	HL			; subtract 1
8A59  2B      		DEC	HL			; subtract 2
8A5A  C36580  		JP	NEXTS1			; save result & NEXT
8A5D          	W_NFA
8A5D  834E46C1		DB	$83,'NF','A'+$80
8A61  4F8A    		DW	W_CFA
8A63          	C_NFA
8A63  7C85    		DW	E_COLON			;Interpret following word sequence
8A65  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8A67  0500    		DW	$0005
8A69  5489    		DW	C_MINUS
8A6B  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8A6D  FFFF    		DW	$FFFF
8A6F  108A    		DW	C_TRAVERSE
8A71  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8A73          	W_PFA					;Convert NFA to PFA
8A73  835046C1		DB	$83,'PF','A'+$80
8A77  5D8A    		DW	W_NFA
8A79          	C_PFA
8A79  7C85    		DW	E_COLON			;Interpret following word sequence
8A7B  FB85    		DW	C_1			;Traverse up memory
8A7D  108A    		DW	C_TRAVERSE		;End of name on stack
8A7F  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8A81  0500    		DW	$0005			;Offset to start of word code
8A83  1384    		DW	C_PLUS			;n1 + n2
8A85  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8A87          	W_CSPSTORE
8A87  84214353		DB	$84,'!CS','P'+$80
      D0
8A8C  738A    		DW	W_PFA
8A8E          	C_CSPSTORE
8A8E  7C85    		DW	E_COLON			;Interpret following word sequence
8A90  3E83    		DW	C_SPFETCH		;Stack pointer onto stack
8A92  4287    		DW	C_CSP			;Push check stack pointer addr
8A94  3985    		DW	C_STORE			;Store word at addr
8A96  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8A98          	W_QERROR
8A98  863F4552		DB	$86,'?ERRO','R'+$80
      524FD2
8A9F  878A    		DW	W_CSPSTORE
8AA1          	C_QERROR
8AA1  7C85    		DW	E_COLON			;Interpret following word sequence
8AA3  A284    		DW	C_SWAP			;Swap top 2 values on stack
8AA5  C880    		DW	C_0BRANCH		;Branch if no error
8AA7  0800    		DW	B0003-$			;0008h
8AA9  328F    		DW	C_ERROR
8AAB  B080    		DW	C_BRANCH		;Add following offset to BC
8AAD  0400    		DW	B0004-$			;$0004
8AAF          	B0003
8AAF  8684    		DW	C_DROP			;Drop error no.
8AB1          	B0004
8AB1  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8AB3          	W_QCOMP		;Error if not in compile mode
8AB3  853F434F		DB	$85,'?COM','P'+$80
      4DD0
8AB9  988A    		DW	W_QERROR
8ABB          	C_QCOMP
8ABB  7C85    		DW	E_COLON			;Interpret following word sequence
8ABD  1987    		DW	C_STATE			;Push STATE addr
8ABF  0285    		DW	C_FETCH			;Get word from addr on stack
8AC1  E783    		DW	C_0EQUALS		;=0
8AC3  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8AC5  1100    		DW	$0011			;Error message number
8AC7  A18A    		DW	C_QERROR		;Error if state <> 0
8AC9  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8ACB          	W_QEXEC		;Error not if not in execute mode
8ACB  853F4558		DB	$85,'?EXE','C'+$80
      45C3
8AD1  B38A    		DW	W_QCOMP
8AD3          	C_QEXEC
8AD3  7C85    		DW	E_COLON			;Interpret following word sequence
8AD5  1987    		DW	C_STATE			;Push STATE addr
8AD7  0285    		DW	C_FETCH			;Get word from addr on stack
8AD9  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8ADB  1200    		DW	$0012			;Error not if not in execute mode
8ADD  A18A    		DW	C_QERROR		;
8ADF  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8AE1          	W_QPAIRS
8AE1  863F5041		DB	$86,'?PAIR','S'+$80
      4952D3
8AE8  CB8A    		DW	W_QEXEC
8AEA          	C_QPAIRS
8AEA  7C85    		DW	E_COLON			;Interpret following word sequence
8AEC  5489    		DW	C_MINUS
8AEE  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8AF0  1300    		DW	$0013
8AF2  A18A    		DW	C_QERROR
8AF4  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8AF6          	W_WHATSTACK	;Check stack pointer, error if not ok
8AF6  843F4353		DB	$84,'?CS','P'+$80
      D0
8AFB  E18A    		DW	W_QPAIRS
8AFD          	C_WHATSTACK
8AFD  7C85    		DW	E_COLON			;Interpret following word sequence
8AFF  3E83    		DW	C_SPFETCH		;Stack pointer onto stack
8B01  4287    		DW	C_CSP			;Push check stack pointer addr
8B03  0285    		DW	C_FETCH			;Get check stack pointer
8B05  5489    		DW	C_MINUS			;If ok then result is 0
8B07  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8B09  1400    		DW	$0014			;Error no if not ok
8B0B  A18A    		DW	C_QERROR		;Error if stack top -1 <> 0
8B0D  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8B0F          	W_QLOADING
8B0F  883F4C4F		DB	$88,'?LOADIN','G'+$80
      4144494E
      C7
8B18  F68A    		DW	W_WHATSTACK
8B1A          	C_QLOADING
8B1A  7C85    		DW	E_COLON			;Interpret following word sequence
8B1C  C686    		DW	C_BLK
8B1E  0285    		DW	C_FETCH			;Get word from addr on stack
8B20  E783    		DW	C_0EQUALS		;=0
8B22  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8B24  1600    		DW	$0016
8B26  A18A    		DW	C_QERROR
8B28  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8B2A          	W_COMPILE
8B2A  87434F4D		DB	$87,'COMPIL','E'+$80
      50494CC5
8B32  0F8B    		DW	W_QLOADING
8B34          	C_COMPILE
8B34  7C85    		DW	E_COLON			;Interpret following word sequence
8B36  BB8A    		DW	C_QCOMP			;Error if not in compile mode
8B38  CB83    		DW	C_RMOVE			;Move word from return to data stack
8B3A  AF84    		DW	C_DUP			;Bump return address and put back
8B3C  EF88    		DW	C_2PLUS			;
8B3E  B583    		DW	C_MOVER			;
8B40  0285    		DW	C_FETCH			;Get word from addr on stack
8B42  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
8B44  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8B46          	W_LEFTBRKT	;Set STATE to execute
8B46  81DB    		DB	$81,'['+$80
8B48  2A8B    		DW	W_COMPILE
8B4A          	C_LEFTBRKT
8B4A  7C85    		DW	E_COLON			;Interpret following word sequence
8B4C  F385    		DW	C_ZERO			;Put zero on stack
8B4E  1987    		DW	C_STATE			;Push STATE addr
8B50  3985    		DW	C_STORE			;Store word at addr
8B52  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8B54          	W_RIGHTBRKT	;Set STATE to compile
8B54  81DD    		DB	$81,']'+$80
8B56  468B    		DW	W_LEFTBRKT
8B58          	C_RIGHTBRKT
8B58  7C85    		DW	E_COLON			;Interpret following word sequence
8B5A  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8B5C  C000    		DW	$00C0
8B5E  1987    		DW	C_STATE			;Push STATE addr
8B60  3985    		DW	C_STORE			;Set STATE to execute
8B62  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8B64          	W_SMUDGE
8B64  86534D55		DB	$86,'SMUDG','E'+$80
      4447C5
8B6B  548B    		DW	W_RIGHTBRKT
8B6D          	C_SMUDGE
8B6D  7C85    		DW	E_COLON			;Interpret following word sequence
8B6F  358A    		DW	C_LATEST		;Push top words NFA
8B71  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8B73  2000    		DW	$0020
8B75  F484    		DW	C_TOGGLE		;XOR (addr) with byte
8B77  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8B79          	W_HEX
8B79  834845D8		DB	$83,'HE','X'+$80
8B7D  648B    		DW	W_SMUDGE
8B7F          	C_HEX
8B7F  7C85    		DW	E_COLON			;Interpret following word sequence
8B81  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8B83  1000    		DW	$0010
8B85  2487    		DW	C_BASE			;Put BASE addr on stack
8B87  3985    		DW	C_STORE			;Store word at addr
8B89  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8B8B          	W_DECIMAL	;Sets decimal mode
8B8B  87444543		DB	$87,'DECIMA','L'+$80
      494D41CC
8B93  798B    		DW	W_HEX
8B95          	C_DECIMAL
8B95  7C85    		DW	E_COLON			;Interpret following word sequence
8B97  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8B99  0A00    		DW	$000A			;Sets decimal value
8B9B  2487    		DW	C_BASE			;Put BASE addr on stack
8B9D  3985    		DW	C_STORE			;Store word at addr
8B9F  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8BA1          	W_CCODE		;Stop compillation & terminate word
8BA1  873C3B43		DB	$87,'<;CODE','>'+$80
      4F4445BE
8BA9  8B8B    		DW	W_DECIMAL
8BAB          	C_CCODE
8BAB  7C85    		DW	E_COLON			;Interpret following word sequence
8BAD  CB83    		DW	C_RMOVE			;Move word from return to data stack
8BAF  358A    		DW	C_LATEST		;Push top words NFA
8BB1  798A    		DW	C_PFA			;Convert NFA to PFA
8BB3  558A    		DW	C_CFA			;Convert PFA to CFA
8BB5  3985    		DW	C_STORE			;Store word at addr
8BB7  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8BB9          	W_SCCODE
8BB9  C53B434F		DB	$C5,';COD','E'+$80
      44C5
8BBF  A18B    		DW	W_CCODE
8BC1          	C_SCCODE
8BC1  7C85    		DW	E_COLON			;Interpret following word sequence
8BC3  FD8A    		DW	C_WHATSTACK		;Check stack pointer, error if not ok
8BC5  348B    		DW	C_COMPILE		;Compile next word into dictionary
8BC7  AB8B    		DW	C_CCODE
8BC9  4A8B    		DW	C_LEFTBRKT		;Set STATE to execute
8BCB  689A    		DW	C_TASK
8BCD  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8BCF          	W_CREATE
8BCF  86435245		DB	$86,'CREAT','E'+$80
      4154C5
8BD6  B98B    		DW	W_SCCODE
8BD8          	C_CREATE
8BD8  7C85    		DW	E_COLON			;Interpret following word sequence
8BDA  F385    		DW	C_ZERO			;Put zero on stack
8BDC  AB85    		DW	C_CONSTANT
8BDE  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8BE0          	W_DOES
8BE0  85444F45		DB	$85,'DOES','>'+$80
      53BE
8BE6  CF8B    		DW	W_CREATE
8BE8          	C_DOES
8BE8  7C85    		DW	E_COLON			;Interpret following word sequence
8BEA  CB83    		DW	C_RMOVE			;Move word from return to data stack
8BEC  358A    		DW	C_LATEST		;Push top words NFA
8BEE  798A    		DW	C_PFA			;Convert NFA to PFA
8BF0  3985    		DW	C_STORE			;Store word at addr
8BF2  AB8B    		DW	C_CCODE			;Execute following machine code
		
8BF4          	X_DOES
8BF4  2A46FE  		LD	HL,(RPP)		;Get return stack pointer
8BF7  2B      		DEC	HL			;Push next pointer
8BF8  70      		LD	(HL),B			;
8BF9  2B      		DEC	HL			;
8BFA  71      		LD	(HL),C			;
8BFB  2246FE  		LD	(RPP),HL
8BFE  13      		INC	DE
8BFF  EB      		EX	DE,HL
8C00  4E      		LD	C,(HL)
8C01  23      		INC	HL
8C02  46      		LD	B,(HL)
8C03  23      		INC	HL
8C04  C36580  		JP	NEXTS1			;Save & NEXT
		
8C07          	W_COUNT		;Convert string at addr to addr + length
8C07  85434F55		DB	$85,'COUN','T'+$80
      4ED4
8C0D  E08B    		DW	W_DOES
8C0F          	C_COUNT
8C0F  7C85    		DW	E_COLON			;Interpret following word sequence
8C11  AF84    		DW	C_DUP			;Duplicate address
8C13  E388    		DW	C_1PLUS			;Add 1 (points to string start)
8C15  A284    		DW	C_SWAP			;Get address back
8C17  1185    		DW	C_CFETCH		;Get byte from addr on stack
8C19  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8C1B          	W_TYPE		;Output n bytes from addr
8C1B  84545950		DB	$84,'TYP','E'+$80
      C5
8C20  078C    		DW	W_COUNT
8C22          	C_TYPE
8C22  7C85    		DW	E_COLON			;Interpret following word sequence
8C24  F989    		DW	C_QUERYDUP		;Copy length if length <> 0
8C26  C880    		DW	C_0BRANCH		;Branch if length = 0
8C28  1800    		DW	B0005-$			;0018h
8C2A  7784    		DW	C_OVER			;Copy address to stack top
8C2C  1384    		DW	C_PLUS			;Add to length
8C2E  A284    		DW	C_SWAP			;Swap top 2 values on stack
8C30  2281    		DW	C_LDO			;Put start & end loop values on RPP
8C32          	B004F
8C32  3E81    		DW	C_I			;Copy LOOP index to data stack
8C34  1185    		DW	C_CFETCH		;Get byte from string
8C36  1582    		DW	C_EMIT			;Output CHR from stack
8C38  DD80    		DW	C_LLOOP			;Increment loop & branch if not done
8C3A  F8FF    		DW	B004F-$			;FFF8h
8C3C  B080    		DW	C_BRANCH		;Done so branch to next
8C3E  0400    		DW	B0006-$			;$0004
8C40          	B0005
8C40  8684    		DW	C_DROP			;Drop string address
8C42          	B0006
8C42  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8C44          	W_TRAILING
8C44  892D5452		DB	$89,'-TRAILIN','G'+$80
      41494C49
      4EC7
8C4E  1B8C    		DW	W_TYPE
8C50          	C_TRAILING
8C50  7C85    		DW	E_COLON			;Interpret following word sequence
8C52  AF84    		DW	C_DUP			;Duplicate top value on stack
8C54  F385    		DW	C_ZERO			;Put zero on stack
8C56  2281    		DW	C_LDO			;Put start & end loop values on RPP
8C58          	B0009
8C58  7784    		DW	C_OVER			;Copy 2nd down to top of stack
8C5A  7784    		DW	C_OVER			;Copy 2nd down to top of stack
8C5C  1384    		DW	C_PLUS			;n1 + n2
8C5E  FB85    		DW	C_1			;Put 1 on stack
8C60  5489    		DW	C_MINUS
8C62  1185    		DW	C_CFETCH		;Get byte from addr on stack
8C64  1486    		DW	C_BL			;Leaves ASCII for space on stack
8C66  5489    		DW	C_MINUS
8C68  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8C6A  0800    		DW	B0007-$			;0008h
8C6C  A183    		DW	C_LEAVE			;Quit loop by making index = limit
8C6E  B080    		DW	C_BRANCH		;Add following offset to BC
8C70  0600    		DW	B0008-$			;0006h
8C72          	B0007
8C72  FB85    		DW	C_1			;Put 1 on stack
8C74  5489    		DW	C_MINUS
8C76          	B0008
8C76  DD80    		DW	C_LLOOP			;Increment loop & branch if not done
8C78  E0FF    		DW	B0009-$			;FFE0h
8C7A  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8C7C          	W_CQUOTE	;Output following string
8C7C  843C2E22		DB	$84,'<.',$22,'>'+$80
      BE
8C81  448C    		DW	W_TRAILING
8C83          	C_CQUOTE
8C83  7C85    		DW	E_COLON			;Interpret following word sequence
8C85  E083    		DW	C_RFETCH		;Copy return stack top to data stack
8C87  0F8C    		DW	C_COUNT			;Convert string at addr to addr + length
8C89  AF84    		DW	C_DUP			;Duplicate top value on stack
8C8B  E388    		DW	C_1PLUS			;1 plus
8C8D  CB83    		DW	C_RMOVE			;Move word from return to data stack
8C8F  1384    		DW	C_PLUS			;Add length of string +1
8C91  B583    		DW	C_MOVER			;Move value from data to return stack
8C93  228C    		DW	C_TYPE			;Output n bytes from addr
8C95  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8C97          	W_QUOTE		;Accept following text
8C97  C22EA2  		DB	$C2,'.',$22+$80
8C9A  7C8C    		DW	W_CQUOTE
8C9C          	C_QUOTE
8C9C  7C85    		DW	E_COLON			;Interpret following word sequence
8C9E  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8CA0  2200    		DW	$0022
8CA2  1987    		DW	C_STATE			;Push STATE addr
8CA4  0285    		DW	C_FETCH			;Get word from addr on stack
8CA6  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8CA8  1200    		DW	B000A-$			;0012h
8CAA  348B    		DW	C_COMPILE		;Compile next word into dictionary
8CAC  838C    		DW	C_CQUOTE		;
8CAE  058E    		DW	C_WORD
8CB0  1185    		DW	C_CFETCH		;Get byte from addr on stack
8CB2  E388    		DW	C_1PLUS			;1 plus
8CB4  2789    		DW	C_ALLOT
8CB6  B080    		DW	C_BRANCH		;Add following offset to BC
8CB8  0800    		DW	B000B-$			;0008h
8CBA          	B000A
8CBA  058E    		DW	C_WORD
8CBC  0F8C    		DW	C_COUNT			;Convert string at addr to addr + length
8CBE  228C    		DW	C_TYPE			;Output n bytes from addr
8CC0          	B000B
8CC0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8CC2          	W_EXPECT
8CC2  86455850		DB	$86,'EXPEC','T'+$80
      4543D4
8CC9  978C    		DW	W_QUOTE
8CCB          	C_EXPECT
8CCB  7C85    		DW	E_COLON			;Interpret following word sequence
8CCD  7784    		DW	C_OVER			;Copy buffer start addr
8CCF  1384    		DW	C_PLUS			;Add to length to give start,end
8CD1  7784    		DW	C_OVER			;Copy start
8CD3  2281    		DW	C_LDO			;Put start & end loop values on RPP
8CD5          	B0012
8CD5  2B82    		DW	C_KEY			;Wait for key, value on stack
8CD7  AF84    		DW	C_DUP			;Duplicate key value
8CD9  8C80    		DW	C_LIT			;Push backspace addr
8CDB  1E80    		DW	BACKSPACE		;
8CDD  0285    		DW	C_FETCH			;Get backspace value
8CDF  6989    		DW	C_EQUALS		;Was it backspace ?
8CE1  C880    		DW	C_0BRANCH		;If not then jump
8CE3  2A00    		DW	B000C-$			;002Ah
8CE5  8684    		DW	C_DROP			;Drop top value from stack
8CE7  AF84    		DW	C_DUP			;Duplicate top value on stack
8CE9  3E81    		DW	C_I			;Copy LOOP index to data stack
8CEB  6989    		DW	C_EQUALS
8CED  AF84    		DW	C_DUP			;Duplicate top value on stack
8CEF  CB83    		DW	C_RMOVE			;Move word from return to data stack
8CF1  0386    		DW	C_2
8CF3  5489    		DW	C_MINUS
8CF5  1384    		DW	C_PLUS			;n1 + n2
8CF7  B583    		DW	C_MOVER			;Move value from data to return stack
8CF9  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8CFB  0A00    		DW	B000D-$			;000Ah
8CFD  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8CFF  0700    		DW	$0007
8D01  B080    		DW	C_BRANCH		;Add following offset to BC
8D03  0600    		DW	B000E-$			;0006h
8D05          	B000D
8D05  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8D07  0800    		DW	$0008
8D09          	B000E
8D09  B080    		DW	C_BRANCH		;Add following offset to BC
8D0B  2800    		DW	B000F-$			;0028h
8D0D          	B000C
8D0D  AF84    		DW	C_DUP			;Duplicate key value
8D0F  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8D11  0D00    		DW	$000D			;CR
8D13  6989    		DW	C_EQUALS		;Was it cariage return
8D15  C880    		DW	C_0BRANCH		;If not then jump
8D17  0E00    		DW	B0010-$			;000Eh
8D19  A183    		DW	C_LEAVE			;Quit loop by making index = limit
8D1B  8684    		DW	C_DROP			;Drop top value from stack
8D1D  1486    		DW	C_BL			;Leaves ASCII for space on stack
8D1F  F385    		DW	C_ZERO			;Put zero on stack
8D21  B080    		DW	C_BRANCH		;Add following offset to BC
8D23  0400    		DW	B0011-$			;$0004
8D25          	B0010
8D25  AF84    		DW	C_DUP			;Duplicate key value
8D27          	B0011
8D27  3E81    		DW	C_I			;Copy LOOP index to data stack
8D29  4885    		DW	C_CSTORE		;Store byte at addr
8D2B  F385    		DW	C_ZERO			;Put zero on stack
8D2D  3E81    		DW	C_I			;Copy LOOP index to data stack
8D2F  E388    		DW	C_1PLUS			;1 plus
8D31  3985    		DW	C_STORE			;Store word at addr
8D33          	B000F
8D33  1582    		DW	C_EMIT			;Output CHR from stack
8D35  DD80    		DW	C_LLOOP			;Increment loop & branch if not done
8D37  9EFF    		DW	B0012-$			;FF9Eh
8D39  8684    		DW	C_DROP			;Drop top value from stack
8D3B  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8D3D          	W_QUERY
8D3D  85515545		DB	$85,'QUER','Y'+$80
      52D9
8D43  C28C    		DW	W_EXPECT
8D45          	C_QUERY
8D45  7C85    		DW	E_COLON			;Interpret following word sequence
8D47  7E86    		DW	C_TIB			;Put TIB addr on stack
8D49  0285    		DW	C_FETCH			;Get word from addr on stack
8D4B  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8D4D  5000    		DW	$0050			;Max line length 50h
8D4F  CB8C    		DW	C_EXPECT		;Get line
8D51  F385    		DW	C_ZERO			;Put zero on stack
8D53  D086    		DW	C_TOIN			;Current input buffer offset
8D55  3985    		DW	C_STORE			;Store word at addr
8D57  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8D59          	W_NULL
8D59  C180    		DB	$C1,$80
8D5B  3D8D    		DW	W_QUERY
8D5D          	C_NULL
8D5D  7C85    		DW	E_COLON			;Interpret following word sequence
8D5F  C686    		DW	C_BLK
8D61  0285    		DW	C_FETCH			;Get word from addr on stack
8D63  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8D65  2A00    		DW	B0013-$			;002Ah
8D67  FB85    		DW	C_1			;Put 1 on stack
8D69  C686    		DW	C_BLK
8D6B  DD84    		DW	C_PLUSSTORE		;Add n1 to addr
8D6D  F385    		DW	C_ZERO			;Put zero on stack
8D6F  D086    		DW	C_TOIN			;Current input buffer offset
8D71  3985    		DW	C_STORE			;Store word at addr
8D73  C686    		DW	C_BLK
8D75  0285    		DW	C_FETCH			;Get word from addr on stack
8D77  5E86    		DW	C_BSCR			;Number of buffers per block on stack
8D79  FB85    		DW	C_1			;Put 1 on stack
8D7B  5489    		DW	C_MINUS
8D7D  0683    		DW	C_AND			;AND
8D7F  E783    		DW	C_0EQUALS		;=0
8D81  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8D83  0800    		DW	B0014-$			;0008h
8D85  D38A    		DW	C_QEXEC			;Error not if not in execute mode
8D87  CB83    		DW	C_RMOVE			;Move word from return to data stack
8D89  8684    		DW	C_DROP			;Drop top value from stack
8D8B          	B0014
8D8B  B080    		DW	C_BRANCH		;Add following offset to BC
8D8D  0600    		DW	B0015-$			;0006h
8D8F          	B0013
8D8F  CB83    		DW	C_RMOVE			;Move word from return to data stack
8D91  8684    		DW	C_DROP			;Drop top value from stack
8D93          	B0015
8D93  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8D95          	W_FILL		;Fill with byte n bytes from addr
8D95  8446494C		DB	$84,'FIL','L'+$80
      CC
8D9A  598D    		DW	W_NULL
8D9C          	C_FILL
8D9C  9E8D    		DW	2+$			;Vector to code
8D9E  69      		LD	L,C			;Save BC for now
8D9F  60      		LD	H,B			;
8DA0  D1      		POP	DE			; get byte
8DA1  C1      		POP	BC			; get n
8DA2  E3      		EX	(SP),HL			; get addr and save BC
8DA3  EB      		EX	DE,HL			;
8DA4          	NEXT_BYTE
8DA4  78      		LD	A,B			;Test count
8DA5  B1      		OR	C			;
8DA6  2806    		JR	Z,NO_COUNT		;If 0 we're done
8DA8  7D      		LD	A,L			;Byte into A
8DA9  12      		LD	(DE),A			;Save byte
8DAA  13      		INC	DE			;Next addr
8DAB  0B      		DEC	BC			;Decr count
8DAC  18F6    		JR	NEXT_BYTE		;Loop
8DAE          	NO_COUNT
8DAE  C1      		POP	BC			;Get BC back
8DAF  C36680  		JP	NEXT
		
8DB2          	W_ERASE		;Fill addr & length from stack with 0
8DB2  85455241		DB	$85,'ERAS','E'+$80
      53C5
8DB8  958D    		DW	W_FILL
8DBA          	C_ERASE
8DBA  7C85    		DW	E_COLON			;Interpret following word sequence
8DBC  F385    		DW	C_ZERO			;Put zero on stack
8DBE  9C8D    		DW	C_FILL			;Fill with byte n bytes from addr
8DC0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8DC2          	W_BLANKS	;Fill addr & length from stack with [SP]
8DC2  86424C41		DB	$86,'BLANK','S'+$80
      4E4BD3
8DC9  B28D    		DW	W_ERASE
8DCB          	C_BLANKS
8DCB  7C85    		DW	E_COLON			;Interpret following word sequence
8DCD  1486    		DW	C_BL			;Leaves ASCII for space on stack
8DCF  9C8D    		DW	C_FILL			;Fill with byte n bytes from addr
8DD1  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8DD3          	W_HOLD
8DD3  84484F4C		DB	$84,'HOL','D'+$80
      C4
8DD8  C28D    		DW	W_BLANKS
8DDA          	C_HOLD
8DDA  7C85    		DW	E_COLON			;Interpret following word sequence
8DDC  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8DDE  FFFF    		DW	$FFFF
8DE0  5587    		DW	C_HLD
8DE2  DD84    		DW	C_PLUSSTORE		;Add n1 to addr
8DE4  5587    		DW	C_HLD
8DE6  0285    		DW	C_FETCH			;Get word from addr on stack
8DE8  4885    		DW	C_CSTORE		;Store byte at addr
8DEA  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8DEC          	W_PAD
8DEC  835041C4		DB	$83,'PA','D'+$80
8DF0  D38D    		DW	W_HOLD
8DF2          	C_PAD
8DF2  7C85    		DW	E_COLON			;Interpret following word sequence
8DF4  1789    		DW	C_HERE			;Dictionary pointer onto stack
8DF6  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8DF8  4400    		DW	$0044
8DFA  1384    		DW	C_PLUS			;n1 + n2
8DFC  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8DFE          	W_WORD
8DFE  84574F52		DB	$84,'WOR','D'+$80
      C4
8E03  EC8D    		DW	W_PAD
8E05          	C_WORD
8E05  7C85    		DW	E_COLON			;Interpret following word sequence
8E07  C686    		DW	C_BLK
8E09  0285    		DW	C_FETCH			;Get word from addr on stack
8E0B  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8E0D  0C00    		DW	B0016-$			;000Ch
8E0F  C686    		DW	C_BLK
8E11  0285    		DW	C_FETCH			;Get word from addr on stack
8E13  1E94    		DW	C_BLOCK
8E15  B080    		DW	C_BRANCH		;Add following offset to BC
8E17  0600    		DW	B0017-$			;0006h
8E19          	B0016
8E19  7E86    		DW	C_TIB
8E1B  0285    		DW	C_FETCH			;Get word from addr on stack
8E1D          	B0017
8E1D  D086    		DW	C_TOIN			;Current input buffer offset
8E1F  0285    		DW	C_FETCH			;Get word from addr on stack
8E21  1384    		DW	C_PLUS			;n1 + n2
8E23  A284    		DW	C_SWAP			;Swap top 2 values on stack
8E25  CA81    		DW	C_ENCLOSE
8E27  1789    		DW	C_HERE			;Dictionary pointer onto stack
8E29  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8E2B  2200    		DW	$0022
8E2D  CB8D    		DW	C_BLANKS
8E2F  D086    		DW	C_TOIN			;Current input buffer offset
8E31  DD84    		DW	C_PLUSSTORE		;Add n1 to addr
8E33  7784    		DW	C_OVER			;Copy 2nd down to top of stack
8E35  5489    		DW	C_MINUS
8E37  B583    		DW	C_MOVER			;Move value from data to return stack
8E39  E083    		DW	C_RFETCH		;Return stack top to data stack
8E3B  1789    		DW	C_HERE			;Dictionary pointer onto stack
8E3D  4885    		DW	C_CSTORE		;Store byte at addr
8E3F  1384    		DW	C_PLUS			;n1 + n2
8E41  1789    		DW	C_HERE			;Dictionary pointer onto stack
8E43  E388    		DW	C_1PLUS			;1 plus
8E45  CB83    		DW	C_RMOVE			;Move word from return to data stack
8E47  6E82    		DW	C_CMOVE			;Move block
8E49  1789    		DW	C_HERE			;Dictionary pointer onto stack
8E4B  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8E4D          	W_CONVERT
8E4D  87434F4E		DB	$87,'CONVER','T'+$80
      564552D4
8E55  FE8D    		DW	W_WORD
8E57          	C_CONVERT
8E57  7C85    		DW	E_COLON			;Interpret following word sequence
8E59          	B001A
8E59  E388    		DW	C_1PLUS			;1 plus
8E5B  AF84    		DW	C_DUP			;Duplicate top value on stack
8E5D  B583    		DW	C_MOVER			;Move value from data to return stack
8E5F  1185    		DW	C_CFETCH		;Get byte from addr on stack
8E61  2487    		DW	C_BASE			;Put BASE addr on stack
8E63  0285    		DW	C_FETCH			;Get word from addr on stack
8E65  5281    		DW	C_DIGIT			;Convert digit n2 using base n1
8E67  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8E69  2C00    		DW	B0018-$			;002Ch
8E6B  A284    		DW	C_SWAP			;Swap top 2 values on stack
8E6D  2487    		DW	C_BASE			;Put BASE addr on stack
8E6F  0285    		DW	C_FETCH			;Get word from addr on stack
8E71  8482    		DW	C_USTAR
8E73  8684    		DW	C_DROP			;Drop top value from stack
8E75  C589    		DW	C_ROT			;3rd value down to top of stack
8E77  2487    		DW	C_BASE			;Put BASE addr on stack
8E79  0285    		DW	C_FETCH			;Get word from addr on stack
8E7B  8482    		DW	C_USTAR
8E7D  2084    		DW	C_DPLUS
8E7F  2E87    		DW	C_DPL
8E81  0285    		DW	C_FETCH			;Get word from addr on stack
8E83  E388    		DW	C_1PLUS			;1 plus
8E85  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8E87  0800    		DW	B0019-$			;0008h
8E89  FB85    		DW	C_1			;Put 1 on stack
8E8B  2E87    		DW	C_DPL
8E8D  DD84    		DW	C_PLUSSTORE		;Add n1 to addr
8E8F          	B0019
8E8F  CB83    		DW	C_RMOVE			;Move word from return to data stack
8E91  B080    		DW	C_BRANCH		;Add following offset to BC
8E93  C6FF    		DW	B001A-$			;FFC6h
8E95          	B0018
8E95  CB83    		DW	C_RMOVE			;Move word from return to data stack
8E97  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8E99          	W_NUMBER
8E99  864E554D		DB	$86,'NUMBE','R'+$80
      4245D2
8EA0  4D8E    		DW	W_CONVERT
8EA2          	C_NUMBER
8EA2  7C85    		DW	E_COLON			;Interpret following word sequence
8EA4  F385    		DW	C_ZERO			;Put zero on stack
8EA6  F385    		DW	C_ZERO			;Put zero on stack
8EA8  C589    		DW	C_ROT			;3rd value down to top of stack
8EAA  AF84    		DW	C_DUP			;Duplicate top value on stack
8EAC  E388    		DW	C_1PLUS			;1 plus
8EAE  1185    		DW	C_CFETCH		;Get byte from addr on stack
8EB0  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8EB2  2D00    		DW	$002D			;'-'
8EB4  6989    		DW	C_EQUALS		;Is first chr = '-'
8EB6  AF84    		DW	C_DUP			;Duplicate negative flag
8EB8  B583    		DW	C_MOVER			;Move value from data to return stack
8EBA  1384    		DW	C_PLUS			;n1 + n2
8EBC  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8EBE  FFFF    		DW	$FFFF			; -1
8EC0          	B001C
8EC0  2E87    		DW	C_DPL
8EC2  3985    		DW	C_STORE			;Store word at addr
8EC4  578E    		DW	C_CONVERT
8EC6  AF84    		DW	C_DUP			;Duplicate top value on stack
8EC8  1185    		DW	C_CFETCH		;Get byte from addr on stack
8ECA  1486    		DW	C_BL			;Leaves ASCII for space on stack
8ECC  5489    		DW	C_MINUS
8ECE  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8ED0  1600    		DW	B001B-$			;0016h
8ED2  AF84    		DW	C_DUP			;Duplicate top value on stack
8ED4  1185    		DW	C_CFETCH		;Get byte from addr on stack
8ED6  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8ED8  2E00    		DW	$002E			;'.'
8EDA  5489    		DW	C_MINUS
8EDC  F385    		DW	C_ZERO			;Put zero on stack
8EDE  A18A    		DW	C_QERROR
8EE0  F385    		DW	C_ZERO			;Put zero on stack
8EE2  B080    		DW	C_BRANCH		;Add following offset to BC
8EE4  DCFF    		DW	B001C-$			;FFDCh
8EE6          	B001B
8EE6  8684    		DW	C_DROP			;Drop top value from stack
8EE8  CB83    		DW	C_RMOVE			;Move word from return to data stack
8EEA  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8EEC  0400    		DW	B001D-$			;$0004
8EEE  5A84    		DW	C_DNEGATE
8EF0          	B001D
8EF0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8EF2          	W_MFIND
8EF2  852D4649		DB	$85,'-FIN','D'+$80
      4EC4
8EF8  998E    		DW	W_NUMBER
8EFA          	C_MFIND
8EFA  7C85    		DW	E_COLON			;Interpret following word sequence
8EFC  1486    		DW	C_BL			;Leaves ASCII for space on stack
8EFE  058E    		DW	C_WORD
8F00  FF86    		DW	C_CONTEXT
8F02  0285    		DW	C_FETCH			;Get word from addr on stack
8F04  0285    		DW	C_FETCH			;Get word from addr on stack
8F06  8081    		DW	C_FIND			;Find word & return vector,byte & flag
8F08  AF84    		DW	C_DUP			;Duplicate top value on stack
8F0A  E783    		DW	C_0EQUALS		;=0
8F0C  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8F0E  0A00    		DW	B001E-$			;000Ah
8F10  8684    		DW	C_DROP			;Drop top value from stack
8F12  1789    		DW	C_HERE			;Dictionary pointer onto stack
8F14  358A    		DW	C_LATEST		;Push top words NFA
8F16  8081    		DW	C_FIND			;Find word & return vector,byte & flag
8F18          	B001E
8F18  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8F1A          	W_CABORT
8F1A  873C4142		DB	$87,'<ABORT','>'+$80
      4F5254BE
8F22  F28E    		DW	W_MFIND
8F24          	C_CABORT
8F24  7C85    		DW	E_COLON			;Interpret following word sequence
8F26  5C91    		DW	C_ABORT
8F28  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8F2A          	W_ERROR
8F2A  85455252		DB	$85,'ERRO','R'+$80
      4FD2
8F30  1A8F    		DW	W_CABORT
8F32          	C_ERROR
8F32  7C85    		DW	E_COLON			;Interpret following word sequence
8F34  9886    		DW	C_WARNING		;Put WARNING addr on stack
8F36  0285    		DW	C_FETCH			;Get word from addr on stack
8F38  0284    		DW	C_0LESS			;Less than 0 leaves true
8F3A  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8F3C  0400    		DW	B001F-$			;$0004
8F3E  248F    		DW	C_CABORT
8F40          	B001F
8F40  1789    		DW	C_HERE			;Dictionary pointer onto stack
8F42  0F8C    		DW	C_COUNT			;Convert string at addr to addr + length
8F44  228C    		DW	C_TYPE			;Output n bytes from addr
8F46  838C    		DW	C_CQUOTE		;Output following string
8F48  02      		DB	S_END7-S_START7
8F49          	S_START7
8F49  3F20    		DB	'? '		;
8F4B          	S_END7
8F4B  6493    		DW	C_MESSAGE		;Output message
8F4D  4D83    		DW	C_SPSTORE		;Set initial stack pointer value
8F4F  C686    		DW	C_BLK
8F51  0285    		DW	C_FETCH			;Get word from addr on stack
8F53  F989    		DW	C_QUERYDUP
8F55  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8F57  0800    		DW	B0020-$			;0008h
8F59  D086    		DW	C_TOIN			;Current input buffer offset
8F5B  0285    		DW	C_FETCH			;Get word from addr on stack
8F5D  A284    		DW	C_SWAP			;Swap top 2 values on stack
8F5F          	B0020
8F5F  2F91    		DW	C_QUIT
		
8F61          	W_ID		;Print definition name from name field addr
8F61  834944AE		DB	$83,'ID','.'+$80
8F65  2A8F    		DW	W_ERROR
8F67          	C_ID
8F67  7C85    		DW	E_COLON			;Interpret following word sequence
8F69  0F8C    		DW	C_COUNT			;Convert string at addr to addr + length
8F6B  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8F6D  1F00    		DW	$001F			;Max length is 1Fh
8F6F  0683    		DW	C_AND			;AND lenght with 1Fh
8F71  228C    		DW	C_TYPE			;Output n bytes from addr
8F73  EA89    		DW	C_SPACE			;Output space
8F75  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8F77          	C_XXX1
8F77  7C85    		DW	E_COLON			;Interpret following word sequence
8F79  FA8E    		DW	C_MFIND			;Find name returns PFA,length,true or false
8F7B  C880    		DW	C_0BRANCH		;Branch if name not found
8F7D  1000    		DW	B0021-$			;0010h
8F7F  8684    		DW	C_DROP			;Drop length
8F81  638A    		DW	C_NFA			;Convert PFA to NFA
8F83  678F    		DW	C_ID			;Print definition name from name field addr
8F85  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8F87  0400    		DW	$0004			;Message 4, name defined twice
8F89  6493    		DW	C_MESSAGE		;Output message
8F8B  EA89    		DW	C_SPACE			;Output space
8F8D          	B0021
8F8D  1789    		DW	C_HERE			;Dictionary pointer onto stack
8F8F  AF84    		DW	C_DUP			;Duplicate top value on stack
8F91  1185    		DW	C_CFETCH		;Get byte from addr on stack
8F93  8A86    		DW	C_WIDTH
8F95  0285    		DW	C_FETCH			;Get word from addr on stack
8F97  4192    		DW	C_MIN
8F99  E388    		DW	C_1PLUS			;1 plus
8F9B  2789    		DW	C_ALLOT			;Which ever is smallest width or namelength
8F9D  AF84    		DW	C_DUP			;Duplicate top value on stack
8F9F  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8FA1  A000    		DW	$00A0
8FA3  F484    		DW	C_TOGGLE		;XOR (addr) with byte
8FA5  1789    		DW	C_HERE			;Dictionary pointer onto stack
8FA7  FB85    		DW	C_1			;Put 1 on stack
8FA9  5489    		DW	C_MINUS
8FAB  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8FAD  8000    		DW	$0080
8FAF  F484    		DW	C_TOGGLE		;XOR (addr) with byte
8FB1  358A    		DW	C_LATEST		;Push top words NFA
8FB3  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
8FB5  0D87    		DW	C_CURRENT
8FB7  0285    		DW	C_FETCH			;Get word from addr on stack
8FB9  3985    		DW	C_STORE			;Store word at addr
8FBB  1789    		DW	C_HERE			;Dictionary pointer onto stack
8FBD  EF88    		DW	C_2PLUS			;2 plus
8FBF  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
8FC1  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8FC3          	W_CCOMPILE
8FC3  895B434F		DB	$89,'[COMPILE',']'+$80
      4D50494C
      45DD
8FCD  618F    		DW	W_ID
8FCF          	C_CCOMPILE
8FCF  7C85    		DW	E_COLON			;Interpret following word sequence
8FD1  FA8E    		DW	C_MFIND
8FD3  E783    		DW	C_0EQUALS		;=0
8FD5  F385    		DW	C_ZERO			;Put zero on stack
8FD7  A18A    		DW	C_QERROR
8FD9  8684    		DW	C_DROP			;Drop top value from stack
8FDB  558A    		DW	C_CFA			;Convert PFA to CFA
8FDD  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
8FDF  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8FE1          	W_LITERAL
8FE1  C74C4954		DB	$C7,'LITERA','L'+$80
      455241CC
8FE9  C38F    		DW	W_CCOMPILE
8FEB          	C_LITERAL
8FEB  7C85    		DW	E_COLON			;Interpret following word sequence
8FED  1987    		DW	C_STATE			;Push STATE addr
8FEF  0285    		DW	C_FETCH			;Get word from addr on stack
8FF1  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
8FF3  0800    		DW	B0022-$			;0008h
8FF5  348B    		DW	C_COMPILE		;Compile next word into dictionary
8FF7  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
8FF9  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
8FFB          	B0022
8FFB  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
8FFD          	W_DLITERAL
8FFD  C8444C49		DB	$C8,'DLITERA','L'+$80
      54455241
      CC
9006  E18F    		DW	W_LITERAL
9008          	C_DLITERAL
9008  7C85    		DW	E_COLON			;Interpret following word sequence
900A  1987    		DW	C_STATE			;Push STATE addr
900C  0285    		DW	C_FETCH			;Get word from addr on stack
900E  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
9010  0800    		DW	B0023-$			;0008h
9012  A284    		DW	C_SWAP			;Swap top 2 values on stack
9014  EB8F    		DW	C_LITERAL
9016  EB8F    		DW	C_LITERAL
9018          	B0023
9018  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
901A          	W_QSTACK
901A  863F5354		DB	$86,'?STAC','K'+$80
      4143CB
9021  FD8F    		DW	W_DLITERAL
9023          	C_QSTACK
9023  7C85    		DW	E_COLON			;Interpret following word sequence
9025  3E83    		DW	C_SPFETCH		;Stack pointer onto stack
9027  6B86    		DW	C_S0			;Push S0 (initial data stack pointer)
9029  0285    		DW	C_FETCH			;Get word from addr on stack
902B  A284    		DW	C_SWAP			;Swap top 2 values on stack
902D  9789    		DW	C_ULESS			;IF stack-1 < stack_top leave true flag
902F  FB85    		DW	C_1			;Put 1 on stack
9031  A18A    		DW	C_QERROR
9033  3E83    		DW	C_SPFETCH		;Stack pointer onto stack
9035  1789    		DW	C_HERE			;Dictionary pointer onto stack
9037  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
9039  8000    		DW	$0080
903B  1384    		DW	C_PLUS			;n1 + n2
903D  9789    		DW	C_ULESS			;IF stack-1 < stack_top leave true flag
903F  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
9041  0700    		DW	$0007
9043  A18A    		DW	C_QERROR
9045  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9047          	W_INTERPRET
9047  89494E54		DB	$89,'INTERPRE','T'+$80
      45525052
      45D4
9051  1A90    		DW	W_QSTACK
9053          	C_INTERPRET
9053  7C85    		DW	E_COLON			;Interpret following word sequence
9055          	B002A
9055  FA8E    		DW	C_MFIND			;Find name returns PFA,length,true or false
9057  C880    		DW	C_0BRANCH		;Branch if name not found
9059  1E00    		DW	NO_NAME-$		;
905B  1987    		DW	C_STATE			;STATE addr on stack
905D  0285    		DW	C_FETCH			;Get STATE
905F  7589    		DW	C_LESSTHAN		;Is it quit compile word ?
9061  C880    		DW	C_0BRANCH		;If so then branch
9063  0A00    		DW	B0025-$			;
9065  558A    		DW	C_CFA			;Convert PFA to CFA
9067  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
9069  B080    		DW	C_BRANCH		;Add following offset to BC
906B  0600    		DW	B0026-$			;
906D          	B0025
906D  558A    		DW	C_CFA			;Convert PFA to CFA
906F  A180    		DW	C_EXECUTE		;Jump to address on stack
9071          	B0026
9071  2390    		DW	C_QSTACK		;Error message if stack underflow
9073  B080    		DW	C_BRANCH		;Add following offset to BC
9075  1C00    		DW	B0027-$			;
9077          	NO_NAME
9077  1789    		DW	C_HERE			;Dictionary pointer onto stack
9079  A28E    		DW	C_NUMBER		;Convert string at addr to double
907B  2E87    		DW	C_DPL			;
907D  0285    		DW	C_FETCH			;Get word from addr on stack
907F  E388    		DW	C_1PLUS			;1 plus
9081  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
9083  0800    		DW	B0028-$			;
9085  0890    		DW	C_DLITERAL
9087  B080    		DW	C_BRANCH		;Add following offset to BC
9089  0600    		DW	B0029-$			;
908B          	B0028
908B  8684    		DW	C_DROP			;Drop top value from stack
908D  EB8F    		DW	C_LITERAL
908F          	B0029
908F  2390    		DW	C_QSTACK		;Error message if stack underflow
9091          	B0027
9091  B080    		DW	C_BRANCH		;Add following offset to BC
9093  C2FF    		DW	B002A-$			;FFC2h
		
9095          	W_IMMEDIATE
9095  89494D4D		DB	$89,'IMMEDIAT','E'+$80
      45444941
      54C5
909F  4790    		DW	W_INTERPRET
90A1          	C_IMMEDIATE
90A1  7C85    		DW	E_COLON			;Interpret following word sequence
90A3  358A    		DW	C_LATEST		;Push top words NFA
90A5  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
90A7  4000    		DW	$0040
90A9  F484    		DW	C_TOGGLE		;XOR (addr) with byte
90AB  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
90AD          	W_VOCABULARY
90AD  8A564F43		DB	$8A,'VOCABULAR','Y'+$80
      4142554C
      4152D9
90B8  9590    		DW	W_IMMEDIATE
90BA          	C_VOCABULARY
90BA  7C85    		DW	E_COLON			;Interpret following word sequence
90BC  D88B    		DW	C_CREATE
90BE  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
90C0  81A0    		DW	$A081
90C2  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
90C4  0D87    		DW	C_CURRENT
90C6  0285    		DW	C_FETCH			;Get word from addr on stack
90C8  558A    		DW	C_CFA			;Convert PFA to CFA
90CA  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
90CC  1789    		DW	C_HERE			;Dictionary pointer onto stack
90CE  BC86    		DW	C_VOC_LINK
90D0  0285    		DW	C_FETCH			;Get word from addr on stack
90D2  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
90D4  BC86    		DW	C_VOC_LINK
90D6  3985    		DW	C_STORE			;Store word at addr
90D8  E88B    		DW	C_DOES
90DA  EF88    		DW	C_2PLUS			;2 plus
90DC  FF86    		DW	C_CONTEXT
90DE  3985    		DW	C_STORE			;Store word at addr
90E0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
90E2          	C_LINK
90E2  EF88    		DW	C_2PLUS			;2 plus
90E4  0285    		DW	C_FETCH			;Get word from addr on stack
90E6  FF86    		DW	C_CONTEXT
90E8  3985    		DW	C_STORE			;Store word at addr
90EA  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
90EC          	W_FORTH
90EC  C5464F52		DB	$C5,'FORT','H'+$80
      54C8
90F2  AD90    		DW	W_VOCABULARY
90F4          	C_FORTH
90F4  F48B    		DW	X_DOES
90F6  E290    		DW	C_LINK
		
90F8  81A0    		DB	$81,' '+$80
90FA  34FE    		DW	FLAST+2
90FC          	E_FORTH
90FC  0000    		DW	$0000
		
90FE          	W_DEFINITIONS	;Set CURRENT as CONTEXT vocabulary
90FE  8B444546		DB	$8B,'DEFINITION','S'+$80
      494E4954
      494F4ED3
910A  EC90    		DW	W_FORTH
910C          	C_DEFINITIONS
910C  7C85    		DW	E_COLON			;Interpret following word sequence
910E  FF86    		DW	C_CONTEXT		;Get CONTEXT addr
9110  0285    		DW	C_FETCH			;Get word from addr on stack
9112  0D87    		DW	C_CURRENT		;Get CURRENT addr
9114  3985    		DW	C_STORE			;Set CURRENT as the context vocabulary
9116  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9118          	W_OPENBRKT
9118  C1A8    		DB	$C1,'('+$80
911A  FE90    		DW	W_DEFINITIONS
911C          	C_OPENBRKT
911C  7C85    		DW	E_COLON			;Interpret following word sequence
911E  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
9120  2900    		DW	$0029
9122  058E    		DW	C_WORD
9124  8684    		DW	C_DROP			;Drop top value from stack
9126  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
		;		This it the last thing ever executed and is the interpreter
		;		outer loop. This NEVER quits.
		
9128          	W_QUIT
9128  84515549		DB	$84,'QUI','T'+$80
      D4
912D  1891    		DW	W_OPENBRKT
912F          	C_QUIT
912F  7C85    		DW	E_COLON			;Interpret following word sequence
9131  F385    		DW	C_ZERO			;Put zero on stack
9133  C686    		DW	C_BLK			;Get current BLK pointer
9135  3985    		DW	C_STORE			;Set BLK to 0
9137  4A8B    		DW	C_LEFTBRKT		;Set STATE to execute
9139          	B002C
9139  7283    		DW	C_RPSTORE		;Set initial return stack pointer
913B  4C82    		DW	C_CR			;Output [CR][LF]
913D  458D    		DW	C_QUERY			;Get string from input, ends in CR
913F  5390    		DW	C_INTERPRET		;Interpret input stream
9141  1987    		DW	C_STATE			;Push STATE addr
9143  0285    		DW	C_FETCH			;Get word from addr on stack
9145  E783    		DW	C_0EQUALS		;=0
9147  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
9149  0700    		DW	S_END8-$		;0007h
914B  838C    		DW	C_CQUOTE		;Output following string
914D  02      		DB	S_END8-S_START8
914E          	S_START8
914E  4F4B    		DB	'OK'
9150          	S_END8
9150  B080    		DW	C_BRANCH		;Add following offset to BC
9152  E7FF    		DW	B002C-$			;FFE7h
		
9154          	W_ABORT
9154  8541424F		DB	$85,'ABOR','T'+$80
      52D4
915A  2891    		DW	W_QUIT
915C          	C_ABORT
915C  7C85    		DW	E_COLON			;Interpret following word sequence
915E  DE87    		DW	C_UABORT		;Put UABORT on stack
9160  0285    		DW	C_FETCH			;Get word from addr on stack
9162  A180    		DW	C_EXECUTE		;Jump to address on stack
9164  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9166          	CF_UABORT
9166  7C85    		DW	E_COLON			;Interpret following word sequence
9168  4D83    		DW	C_SPSTORE		;Set initial stack pointer value
916A  958B    		DW	C_DECIMAL		;Sets decimal mode
916C  2390    		DW	C_QSTACK		;Error message if stack underflow
916E  4C82    		DW	C_CR			;Output [CR][LF]
9170  838C    		DW	C_CQUOTE		;Output following string
9172  0E      		DB	S_END1-S_START1		;String length
9173          	S_START1
9173  0C2A205A		DB	$0C,'* Z80 FORTH *'
      38302046
      4F525448
      202A
9181          	S_END1
9181  F490    		DW	C_FORTH
9183  0C91    		DW	C_DEFINITIONS			;Set CURRENT as CONTEXT vocabulary
9185  2F91    		DW	C_QUIT
		
9187          	W_WARM
9187  84574152		DB	$84,'WAR','M'+$80
      CD
918C  5491    		DW	W_ABORT
918E          	C_WARM
918E  7C85    		DW	E_COLON					;Interpret following word sequence
9190  8C80    		DW	C_LIT					;Puts next 2 bytes on the stack
9192  2080    		DW	WORD1					;Start of detault table
9194  8C80    		DW	C_LIT					;Puts next 2 bytes on the stack
9196  06FE    		DW	S0						;S0 addr
9198  8C80    		DW	C_LIT					;Puts next 2 bytes on the stack
919A  1000    		DW	START_TABLE-WORD1		;(000Ch) Table length
919C  6E82    		DW	C_CMOVE					;Move block
919E  5C91    		DW	C_ABORT
		
91A0          	X_COLD
91A0  213080  		LD	HL,START_TABLE			;Copy table to ram
91A3  1132FE  		LD	DE,FLAST				;Where the table's going
91A6  013400  		LD	BC,NEXTS2-START_TABLE	;Bytes to copy
91A9  EDB0    		LDIR						;
91AB  21619A  		LD	HL,W_TASK				;Copy TASK to ram
91AE  1100F0  		LD	DE,VOCAB_BASE			;Where it's going
91B1  010B00  		LD	BC,W_TASKEND-W_TASK		;Bytes to copy
91B4  EDB0    		LDIR						;
91B6  01C091  		LD	BC,FIRSTWORD			;BC to first forth word
91B9  2A2080  		LD	HL,(WORD1)				;Get stack pointer
91BC  F9      		LD	SP,HL					;Set it
91BD  C36680  		JP	NEXT
		
91C0          	FIRSTWORD
91C0  CB91    		DW	C_COLD
		
91C2          	W_COLD
91C2  84434F4C		DB	$84,'COL','D'+$80
      C4
91C7  8791    		DW	W_WARM
91C9  A091    		DW	X_COLD
91CB          	C_COLD
91CB  7C85    		DW	E_COLON					;Interpret following word sequence
91CD  F993    		DW	C_EBUFFERS				;Clear pseudo disk buffer
91CF  F385    		DW	C_ZERO					;Put zero on stack
91D1  F186    		DW	C_OFFSET				;Put disk block offset on stack
91D3  3985    		DW	C_STORE					;Clear disk block offset
91D5  8C80    		DW	C_LIT					;Puts next 2 bytes on the stack
91D7  2080    		DW	WORD1					;Start of default table
91D9  8C80    		DW	C_LIT					;Puts next 2 bytes on the stack
91DB  06FE    		DW	S0						;S0 addr
91DD  8C80    		DW	C_LIT					;Puts next 2 bytes on the stack
91DF  1000    		DW	START_TABLE-WORD1		;Block length on stack (0010h)
91E1  6E82    		DW	C_CMOVE					;Move block
91E3  5C91    		DW	C_ABORT
		
91E5          	W_SINGTODUB						;Change single number to double
91E5  84532D3E		DB	$84,'S->','D'+$80
      C4
91EA  C291    		DW	W_COLD
91EC          	C_SINGTODUB
91EC  EE91    		DW	2+$						;Vector to code
91EE  D1      		POP	DE						;Get number
91EF  210000  		LD	HL,$0000				;Assume +ve extend
91F2  7A      		LD	A,D						;Check sign
91F3  E680    		AND	$80						;
91F5  2801    		JR	Z,IS_POS				;Really +ve so jump
91F7  2B      		DEC	HL						;Make -ve extension
91F8          	IS_POS	
91F8  C36480  		JP	NEXTS2					;Save both & NEXT
		
91FB          	W_PLUSMINUS
91FB  822BAD  		DB	$82,'+','-'+$80
91FE  E591    		DW	W_SINGTODUB
9200          	C_PLUSMINUS
9200  7C85    		DW	E_COLON					;Interpret following word sequence
9202  0284    		DW	C_0LESS					;Less than 0
9204  C880    		DW	C_0BRANCH				;Add offset to BC if stack top = 0
9206  0400    		DW	B002D-$					;$0004
9208  4384    		DW	C_NEGATE				;Form 2s complement of n
920A          	B002D		
920A  8A83    		DW	C_STOP					;Pop BC from return stack (=next)
		
920C          	W_DPLUSMINUS					;Add sign of n to double
920C  83442BAD		DB	$83,'D+','-'+$80
9210  FB91    		DW	W_PLUSMINUS
9212          	C_DPLUSMINUS
9212  7C85    		DW	E_COLON					;Interpret following word sequence
9214  0284    		DW	C_0LESS					;Less than 0
9216  C880    		DW	C_0BRANCH				;Add offset to BC if stack top = 0
9218  0400    		DW	B002E-$					;$0004
921A  5A84    		DW	C_DNEGATE		
921C          	B002E		
921C  8A83    		DW	C_STOP					;Pop BC from return stack (=next)
		
921E          	W_ABS
921E  834142D3		DB	$83,'AB','S'+$80
9222  0C92    		DW	W_DPLUSMINUS
9224          	C_ABS
9224  7C85    		DW	E_COLON					;Interpret following word sequence
9226  AF84    		DW	C_DUP					;Duplicate top value on stack
9228  0092    		DW	C_PLUSMINUS
922A  8A83    		DW	C_STOP					;Pop BC from return stack (=next)
		
922C          	W_DABS
922C  84444142		DB	$84,'DAB','S'+$80
      D3
9231  1E92    		DW	W_ABS
9233          	C_DABS
9233  7C85    		DW	E_COLON					;Interpret following word sequence
9235  AF84    		DW	C_DUP					;Duplicate top value on stack
9237  1292    		DW	C_DPLUSMINUS			;Add sign of n to double
9239  8A83    		DW	C_STOP					;Pop BC from return stack (=next)
		
923B          	W_MIN
923B  834D49CE		DB	$83,'MI','N'+$80
923F  2C92    		DW	W_DABS
9241          	C_MIN
9241  7C85    		DW	E_COLON					;Interpret following word sequence
9243  BD84    		DW	C_2DUP					;Dup top 2 values on stack
9245  B789    		DW	C_GREATER		
9247  C880    		DW	C_0BRANCH				;Add offset to BC if stack top = 0
9249  0400    		DW	B002F-$					;$0004
924B  A284    		DW	C_SWAP					;Swap top 2 values on stack
924D          	B002F		
924D  8684    		DW	C_DROP					;Drop top value from stack
924F  8A83    		DW	C_STOP					;Pop BC from return stack (=next)
		
9251          	W_MAX
9251  834D41D8		DB	$83,'MA','X'+$80
9255  3B92    		DW	W_MIN
9257          	C_MAX
9257  7C85    		DW	E_COLON			;Interpret following word sequence
9259  BD84    		DW	C_2DUP			;Dup top 2 values on stack
925B  7589    		DW	C_LESSTHAN
925D  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
925F  0400    		DW	B0030-$			;$0004
9261  A284    		DW	C_SWAP			;Swap top 2 values on stack
9263          	B0030
9263  8684    		DW	C_DROP			;Drop top value from stack
9265  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9267          	W_MTIMES
9267  824DAA  		DB	$82,'M','*'+$80
926A  5192    		DW	W_MAX
926C          	C_MTIMES
926C  7C85    		DW	E_COLON			;Interpret following word sequence
926E  BD84    		DW	C_2DUP			;Dup top 2 values on stack
9270  2B83    		DW	C_XOR			;Works out sign of result
9272  B583    		DW	C_MOVER			;Move value from data to return stack
9274  2492    		DW	C_ABS
9276  A284    		DW	C_SWAP			;Swap top 2 values on stack
9278  2492    		DW	C_ABS
927A  8482    		DW	C_USTAR
927C  CB83    		DW	C_RMOVE			;Move word from return to data stack
927E  1292    		DW	C_DPLUSMINUS		;Add sign of n to double
9280  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9282          	W_MDIV
9282  824DAF  		DB	$82,'M','/'+$80
9285  6792    		DW	W_MTIMES
9287          	C_MDIV
9287  7C85    		DW	E_COLON			;Interpret following word sequence
9289  7784    		DW	C_OVER			;Copy 2nd down to top of stack
928B  B583    		DW	C_MOVER			;Move value from data to return stack
928D  B583    		DW	C_MOVER			;Move value from data to return stack
928F  3392    		DW	C_DABS
9291  E083    		DW	C_RFETCH		;Return stack top to data stack
9293  2492    		DW	C_ABS
9295  B982    		DW	C_UMOD			;Unsigned divide & MOD
9297  CB83    		DW	C_RMOVE			;Move word from return to data stack
9299  E083    		DW	C_RFETCH		;Return stack top to data stack
929B  2B83    		DW	C_XOR			;XOR
929D  0092    		DW	C_PLUSMINUS
929F  A284    		DW	C_SWAP			;Swap top 2 values on stack
92A1  CB83    		DW	C_RMOVE			;Move word from return to data stack
92A3  0092    		DW	C_PLUSMINUS
92A5  A284    		DW	C_SWAP			;Swap top 2 values on stack
92A7  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
92A9          	W_TIMES
92A9  81AA    		DB	$81,'*'+$80
92AB  8292    		DW	W_MDIV
92AD          	C_TIMES
92AD  7C85    		DW	E_COLON			;Interpret following word sequence
92AF  6C92    		DW	C_MTIMES
92B1  8684    		DW	C_DROP			;Drop top value from stack
92B3  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
92B5          	W_DIVMOD
92B5  842F4D4F		DB	$84,'/MO','D'+$80
      C4
92BA  A992    		DW	W_TIMES
92BC          	C_DIVMOD
92BC  7C85    		DW	E_COLON			;Interpret following word sequence
92BE  B583    		DW	C_MOVER			;Move value from data to return stack
92C0  EC91    		DW	C_SINGTODUB		;Change single number to double
92C2  CB83    		DW	C_RMOVE			;Move word from return to data stack
92C4  8792    		DW	C_MDIV
92C6  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
92C8          	W_DIV
92C8  81AF    		DB	$81,'/'+$80
92CA  B592    		DW	W_DIVMOD
92CC          	C_DIV
92CC  7C85    		DW	E_COLON			;Interpret following word sequence
92CE  BC92    		DW	C_DIVMOD
92D0  A284    		DW	C_SWAP			;Swap top 2 values on stack
92D2  8684    		DW	C_DROP			;Drop top value from stack
92D4  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
92D6          	W_MOD
92D6  834D4FC4		DB	$83,'MO','D'+$80
92DA  C892    		DW	W_DIV
92DC          	C_MOD
92DC  7C85    		DW	E_COLON			;Interpret following word sequence
92DE  BC92    		DW	C_DIVMOD
92E0  8684    		DW	C_DROP			;Drop top value from stack
92E2  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
92E4          	W_TIMESDIVMOD
92E4  852A2F4D		DB	$85,'*/MO','D'+$80
      4FC4
92EA  D692    		DW	W_MOD
92EC          	C_TIMESDIVMOD
92EC  7C85    		DW	E_COLON			;Interpret following word sequence
92EE  B583    		DW	C_MOVER			;Move value from data to return stack
92F0  6C92    		DW	C_MTIMES
92F2  CB83    		DW	C_RMOVE			;Move word from return to data stack
92F4  8792    		DW	C_MDIV
92F6  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
92F8          	W_TIMESDIV
92F8  822AAF  		DB	$82,'*','/'+$80
92FB  E492    		DW	W_TIMESDIVMOD
92FD          	C_TIMESDIV
92FD  7C85    		DW	E_COLON			;Interpret following word sequence
92FF  EC92    		DW	C_TIMESDIVMOD
9301  A284    		DW	C_SWAP			;Swap top 2 values on stack
9303  8684    		DW	C_DROP			;Drop top value from stack
9305  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9307          	W_MDIVMOD
9307  854D2F4D		DB	$85,'M/MO','D'+$80
      4FC4
930D  F892    		DW	W_TIMESDIV
930F          	C_MDIVMOD
930F  7C85    		DW	E_COLON			;Interpret following word sequence
9311  B583    		DW	C_MOVER			;Move value from data to return stack
9313  F385    		DW	C_ZERO			;Put zero on stack
9315  E083    		DW	C_RFETCH		;Return stack top to data stack
9317  B982    		DW	C_UMOD			;Unsigned divide & MOD
9319  CB83    		DW	C_RMOVE			;Move word from return to data stack
931B  A284    		DW	C_SWAP			;Swap top 2 values on stack
931D  B583    		DW	C_MOVER			;Move value from data to return stack
931F  B982    		DW	C_UMOD			;Unsigned divide & MOD
9321  CB83    		DW	C_RMOVE			;Move word from return to data stack
9323  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9325          	W_CLINE
9325  863C4C49		DB	$86,'<LINE','>'+$80
      4E45BE
932C  0793    		DW	W_MDIVMOD
932E          	C_CLINE
932E  7C85    		DW	E_COLON			;Interpret following word sequence
9330  B583    		DW	C_MOVER			;Move value from data to return stack
9332  1E86    		DW	C_CL			;Put characters/line on stack
9334  4E86    		DW	C_BBUF			;Put bytes per block on stack
9336  EC92    		DW	C_TIMESDIVMOD
9338  CB83    		DW	C_RMOVE			;Move word from return to data stack
933A  5E86    		DW	C_BSCR			;Number of buffers per block on stack
933C  AD92    		DW	C_TIMES
933E  1384    		DW	C_PLUS			;n1 + n2
9340  1E94    		DW	C_BLOCK
9342  1384    		DW	C_PLUS			;n1 + n2
9344  1E86    		DW	C_CL			;Put characters/line on stack
9346  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9348          	W_DOTLINE
9348  852E4C49		DB	$85,'.LIN','E'+$80
      4EC5
934E  2593    		DW	W_CLINE
9350          	C_DOTLINE
9350  7C85    		DW	E_COLON			;Interpret following word sequence
9352  2E93    		DW	C_CLINE
9354  508C    		DW	C_TRAILING
9356  228C    		DW	C_TYPE			;Output n bytes from addr
9358  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
935A          	W_MESSAGE
935A  874D4553		DB	$87,'MESSAG','E'+$80
      534147C5
9362  4893    		DW	W_DOTLINE
9364          	C_MESSAGE
9364  7C85    		DW	E_COLON			;Interpret following word sequence
9366  9886    		DW	C_WARNING		;Put WARNING addr on stack
9368  0285    		DW	C_FETCH			;Get WARNING value
936A  C880    		DW	C_0BRANCH		;If WARNING = 0 output MSG # n
936C  1E00    		DW	B0031-$			;001Eh
936E  F989    		DW	C_QUERYDUP
9370  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
9372  1400    		DW	B0032-$			;0014h
9374  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
9376  0400    		DW	$0004
9378  F186    		DW	C_OFFSET		;Put disk block offset on stack
937A  0285    		DW	C_FETCH			;Get word from addr on stack
937C  5E86    		DW	C_BSCR			;Number of buffers per block on stack
937E  CC92    		DW	C_DIV
9380  5489    		DW	C_MINUS
9382  5093    		DW	C_DOTLINE		;Output line from screen
9384  EA89    		DW	C_SPACE			;Output space
9386          	B0032
9386  B080    		DW	C_BRANCH		;Add following offset to BC
9388  0D00    		DW	B0033-$			;000Dh
938A          	B0031
938A  838C    		DW	C_CQUOTE		;Output following string
938C  06      			DB	S_END2-S_START2
938D          	S_START2
938D  4D534720		DB	'MSG # '
      2320
9393          	S_END2
9393  5197    		DW	C_DOT
9395          	B0033
9395  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9397          	W_PORTIN	;Fetch data from port
9397  8250C0  		DB	$82,'P','@'+$80
939A  5A93    		DW	W_MESSAGE
939C          	C_PORTIN
939C  9E93    		DW	2+$			;Vector to code
939E  D1      		POP	DE			;Get port addr
939F  2141FE  		LD	HL,PAT+1		;Save in port in code
93A2  73      		LD	(HL),E			;
93A3  CD40FE  		CALL	PAT			;Call port in routine
93A6  6F      		LD	L,A			;Save result
93A7  2600    		LD	H,$00			;
93A9  C36580  		JP	NEXTS1			;Save & NEXT
		
93AC          	W_PORTOUT	;Save data to port
93AC  8250A1  		DB	$82,'P','!'+$80
93AF  9793    		DW	W_PORTIN
93B1          	C_PORTOUT
93B1  B393    		DW	2+$			;Vector to code
93B3  D1      		POP	DE			;Get port addr
93B4  2144FE  		LD	HL,PST+1		;Save in port out code
93B7  73      		LD	(HL),E			;
93B8  E1      		POP	HL			;
93B9  7D      		LD	A,L			;Byte to A
93BA  CD43FE  		CALL	PST			;Call port out routine
93BD  C36680  		JP	NEXT
		
93C0          	W_USE
93C0  835553C5		DB	$83,'US','E'+$80
93C4  AC93    		DW	W_PORTOUT
93C6          	C_USE
93C6  E385    		DW	X_USER			;Put next word on stack then do next
93C8  4800    		DW	USE-SYSTEM
		
93CA          	W_PREV
93CA  84505245		DB	$84,'PRE','V'+$80
      D6
93CF  C093    		DW	W_USE
93D1          	C_PREV
93D1  E385    		DW	X_USER			;Put next word on stack then do next
93D3  4A00    		DW	PREV-SYSTEM
		
93D5          	W_PLUSBUF
93D5  842B4255		DB	$84,'+BU','F'+$80
      C6
93DA  CA93    		DW	W_PREV
93DC          	C_PLUSBUF
93DC  6680    		DW	NEXT
		
93DE          	W_UPDATE
93DE  86555044		DB	$86,'UPDAT','E'+$80
      4154C5
93E5  D593    		DW	W_PLUSBUF
93E7          	C_UPDATE
93E7  6680    		DW	NEXT
		
93E9          	W_EBUFFERS	;Clear pseudo disk buffer
93E9  8D454D50		DB	$8D,'EMPTY-BUFFER','S'+$80
      54592D42
      55464645
      52D3
93F7  DE93    		DW	W_UPDATE
93F9          	C_EBUFFERS
93F9  7C85    		DW	E_COLON			;Interpret following word sequence
93FB  2E86    		DW	C_FIRST			;Start of pseudo disk onto stack
93FD  3E86    		DW	C_LIMIT			;End of pseudo disk onto stack
93FF  7784    		DW	C_OVER			;Start to top of stack
9401  5489    		DW	C_MINUS			;Work out buffer length
9403  BA8D    		DW	C_ERASE			;Fill addr & length from stack with 0
9405  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9407          	W_BUFFER
9407  86425546		DB	$86,'BUFFE','R'+$80
      4645D2
940E  E993    		DW	W_EBUFFERS
9410          	C_BUFFER
9410  7C85    		DW	E_COLON			;Interpret following word sequence
9412  1E94    		DW	C_BLOCK
9414  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9416          	W_BLOCK		;Put address of block n (+ offset) on stack
9416  85424C4F		DB	$85,'BLOC','K'+$80
      43CB
941C  0794    		DW	W_BUFFER
941E          	C_BLOCK
941E  7C85    		DW	E_COLON			;Interpret following word sequence
9420  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
9422  2800    		DW	DISK_END/BLOCK_SIZE-DISK_START/BLOCK_SIZE
							;Max number of blocks
9424  DC92    		DW	C_MOD			;MOD to max number
9426  F186    		DW	C_OFFSET		;Put address of disk block offset on stack
9428  0285    		DW	C_FETCH			;Get disk block offset
942A  1384    		DW	C_PLUS			;Add offset to block #
942C  4E86    		DW	C_BBUF			;Put bytes per block on stack
942E  AD92    		DW	C_TIMES			;Bytes times block number
9430  2E86    		DW	C_FIRST			;Put address of first block on stack
9432  1384    		DW	C_PLUS			;Add address of first to byte offset
9434  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9436          	W_RW
9436  83522FD7		DB	$83,'R/','W'+$80
943A  1694    		DW	W_BLOCK
943C          	C_RW
943C  7C85    		DW	E_COLON			;Interpret following word sequence
943E  D187    		DW	C_URW			;
9440  0285    		DW	C_FETCH			;Get word from addr on stack
9442  A180    		DW	C_EXECUTE		;Jump to address on stack
9444  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
9446          	CF_URW
9446  7C85    		DW	E_COLON			;Interpret following word sequence
9448  8684    		DW	C_DROP			;Drop top value from stack
944A  8684    		DW	C_DROP			;Drop top value from stack
944C  8684    		DW	C_DROP			;Drop top value from stack
944E  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9450          	W_FLUSH
9450  85464C55		DB	$85,'FLUS','H'+$80
      53C8
9456  3694    		DW	W_RW
9458          	C_FLUSH
9458  7C85    		DW	E_COLON			;Interpret following word sequence
945A  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
945C          	W_DUMP
945C  8444554D		DB	$84,'DUM','P'+$80
      D0
9461  5094    		DW	W_FLUSH
9463          	C_DUMP
9463  7C85    		DW	E_COLON			;Interpret following word sequence
9465  F385    		DW	C_ZERO			;Put zero on stack
9467  2281    		DW	C_LDO			;Put start & end loop values on RPP
9469          	B0051
9469  4C82    		DW	C_CR			;Output [CR][LF]
946B  AF84    		DW	C_DUP			;Duplicate top value on stack
946D  F385    		DW	C_ZERO			;Put zero on stack
946F  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
9471  0500    		DW	$0005
9473  0F97    		DW	C_DDOTR
9475  EA89    		DW	C_SPACE			;Output space
9477  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
9479  0400    		DW	$0004
947B  A284    		DW	C_SWAP			;Swap top 2 values on stack
947D  7784    		DW	C_OVER			;Copy 2nd down to top of stack
947F  F385    		DW	C_ZERO			;Put zero on stack
9481  2281    		DW	C_LDO			;Put start & end loop values on RPP
9483          	B0050
9483  AF84    		DW	C_DUP			;Duplicate top value on stack
9485  1185    		DW	C_CFETCH		;Get byte from addr on stack
9487  0B86    		DW	C_3
9489  3297    		DW	C_DOTR
948B  E388    		DW	C_1PLUS			;1 plus
948D  DD80    		DW	C_LLOOP			;Increment loop & branch if not done
948F  F4FF    		DW	B0050-$			;FFF4h
9491  A284    		DW	C_SWAP			;Swap top 2 values on stack
9493  1681    		DW	C_PLOOP			;Loop + stack & branch if not done
9495  D4FF    		DW	B0051-$			;FFD4h
9497  8684    		DW	C_DROP			;Drop top value from stack
9499  4C82    		DW	C_CR			;Output [CR][LF]
949B  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
949D          	W_LOAD
949D  844C4F41		DB	$84,'LOA','D'+$80
      C4
94A2  5C94    		DW	W_DUMP
94A4          	C_LOAD
94A4  7C85    		DW	E_COLON			;Interpret following word sequence
94A6  C686    		DW	C_BLK			;Get current block number (0 = keyboard)
94A8  0285    		DW	C_FETCH			;Get word from addr on stack
94AA  B583    		DW	C_MOVER			;Save it for now
94AC  D086    		DW	C_TOIN			;Current input buffer offset
94AE  0285    		DW	C_FETCH			;Get word from addr on stack
94B0  B583    		DW	C_MOVER			;Save it for now
94B2  F385    		DW	C_ZERO			;Put zero on stack
94B4  D086    		DW	C_TOIN			;Current input buffer offset
94B6  3985    		DW	C_STORE			;Set to zero
94B8  5E86    		DW	C_BSCR			;Number of buffers per block on stack
94BA  AD92    		DW	C_TIMES			;Multiply block to load by buffers/block
94BC  C686    		DW	C_BLK			;Get BLK pointer
94BE  3985    		DW	C_STORE			;Make load block current input stream
94C0  5390    		DW	C_INTERPRET		;Interpret input stream
94C2  CB83    		DW	C_RMOVE			;Move word from return to data stack
94C4  D086    		DW	C_TOIN			;Current input buffer offset
94C6  3985    		DW	C_STORE			;Store word at addr
94C8  CB83    		DW	C_RMOVE			;Move word from return to data stack
94CA  C686    		DW	C_BLK			;Current block
94CC  3985    		DW	C_STORE			;Store word at addr
94CE  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
94D0          	W_NEXTSCREEN
94D0  C32D2DBE		DB	$C3,'--','>'+$80
94D4  9D94    		DW	W_LOAD
94D6          	C_NEXTSCREEN
94D6  7C85    		DW	E_COLON			;Interpret following word sequence
94D8  1A8B    		DW	C_QLOADING
94DA  F385    		DW	C_ZERO			;Put zero on stack
94DC  D086    		DW	C_TOIN			;Current input buffer offset
94DE  3985    		DW	C_STORE			;Store word at addr
94E0  5E86    		DW	C_BSCR			;Number of buffers per block on stack
94E2  C686    		DW	C_BLK
94E4  0285    		DW	C_FETCH			;Get word from addr on stack
94E6  7784    		DW	C_OVER			;Copy 2nd down to top of stack
94E8  DC92    		DW	C_MOD
94EA  5489    		DW	C_MINUS
94EC  C686    		DW	C_BLK
94EE  DD84    		DW	C_PLUSSTORE		;Add n1 to addr
94F0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
94F2          	W_TICK
94F2  81AC    		DB	$81,$2C+$80
94F4  D094    		DW	W_NEXTSCREEN
94F6          	C_TICK
94F6  7C85    		DW	E_COLON			;Interpret following word sequence
94F8  FA8E    		DW	C_MFIND			;Find name returns PFA,length,true or false
94FA  E783    		DW	C_0EQUALS		;=0
94FC  F385    		DW	C_ZERO			;Put zero on stack
94FE  A18A    		DW	C_QERROR
9500  8684    		DW	C_DROP			;Drop top value from stack
9502  EB8F    		DW	C_LITERAL
9504  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9506          	W_FORGET
9506  86464F52		DB	$86,'FORGE','T'+$80
      4745D4
950D  F294    		DW	W_TICK
950F          	C_FORGET
950F  7C85    		DW	E_COLON			;Interpret following word sequence
9511  0D87    		DW	C_CURRENT
9513  0285    		DW	C_FETCH			;Get word from addr on stack
9515  FF86    		DW	C_CONTEXT
9517  0285    		DW	C_FETCH			;Get word from addr on stack
9519  5489    		DW	C_MINUS
951B  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
951D  1800    		DW	$0018
951F  A18A    		DW	C_QERROR
9521  F694    		DW	C_TICK
9523  AF84    		DW	C_DUP			;Duplicate top value on stack
9525  A486    		DW	C_FENCE
9527  0285    		DW	C_FETCH			;Get word from addr on stack
9529  7589    		DW	C_LESSTHAN
952B  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
952D  1500    		DW	$0015
952F  A18A    		DW	C_QERROR
9531  AF84    		DW	C_DUP			;Duplicate top value on stack
9533  638A    		DW	C_NFA			;Convert PFA to NFA
9535  AD86    		DW	C_DP			;Dictionary pointer addr on stack
9537  3985    		DW	C_STORE			;Store word at addr
9539  458A    		DW	C_LFA
953B  0285    		DW	C_FETCH			;Get word from addr on stack
953D  FF86    		DW	C_CONTEXT
953F  0285    		DW	C_FETCH			;Get word from addr on stack
9541  3985    		DW	C_STORE			;Store word at addr
9543  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9545          	W_BACK
9545  84424143		DB	$84,'BAC','K'+$80
      CB
954A  0695    		DW	W_FORGET
954C          	C_BACK
954C  7C85    		DW	E_COLON			;Interpret following word sequence
954E  1789    		DW	C_HERE			;Dictionary pointer onto stack
9550  5489    		DW	C_MINUS
9552  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
9554  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9556          	W_BEGIN
9556  C5424547		DB	$C5,'BEGI','N'+$80
      49CE
955C  4595    		DW	W_BACK
955E          	C_BEGIN
955E  7C85    		DW	E_COLON			;Interpret following word sequence
9560  BB8A    		DW	C_QCOMP			;Error if not in compile mode
9562  1789    		DW	C_HERE			;Dictionary pointer onto stack
9564  FB85    		DW	C_1			;Put 1 on stack
9566  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9568          	W_ENDIF
9568  C5454E44		DB	$C5,'ENDI','F'+$80
      49C6
956E  5695    		DW	W_BEGIN
9570          	C_ENDIF
9570  7C85    		DW	E_COLON			;Interpret following word sequence
9572  BB8A    		DW	C_QCOMP			;Error if not in compile mode
9574  0386    		DW	C_2
9576  EA8A    		DW	C_QPAIRS
9578  1789    		DW	C_HERE			;Dictionary pointer onto stack
957A  7784    		DW	C_OVER			;Copy 2nd down to top of stack
957C  5489    		DW	C_MINUS
957E  A284    		DW	C_SWAP			;Swap top 2 values on stack
9580  3985    		DW	C_STORE			;Store word at addr
9582  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9584          	W_THEN
9584  C4544845		DB	$C4,'THE','N'+$80
      CE
9589  6895    		DW	W_ENDIF
958B          	C_THEN
958B  7C85    		DW	E_COLON			;Interpret following word sequence
958D  7095    		DW	C_ENDIF
958F  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9591          	W_DO
9591  C244CF  		DB	$C2,'D','O'+$80
9594  8495    		DW	W_THEN
9596          	C_DO
9596  7C85    		DW	E_COLON			;Interpret following word sequence
9598  348B    		DW	C_COMPILE		;Compile next word into dictionary
959A  2281    		DW	C_LDO			;Put start & end loop values on RPP
959C  1789    		DW	C_HERE			;Dictionary pointer onto stack
959E  0B86    		DW	C_3
95A0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
95A2          	W_LOOP
95A2  C44C4F4F		DB	$C4,'LOO','P'+$80
      D0
95A7  9195    		DW	W_DO
95A9          	C_LOOP
95A9  7C85    		DW	E_COLON			;Interpret following word sequence
95AB  0B86    		DW	C_3
95AD  EA8A    		DW	C_QPAIRS
95AF  348B    		DW	C_COMPILE		;Compile next word into dictionary
95B1  DD80    		DW	C_LLOOP			;Increment loop & branch if not done
95B3  4C95    		DW	C_BACK
95B5  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
95B7          	W_PLUSLOOP
95B7  C52B4C4F		DB	$C5,'+LOO','P'+$80
      4FD0
95BD  A295    		DW	W_LOOP
95BF          	C_PLUSLOOP
95BF  7C85    		DW	E_COLON			;Interpret following word sequence
95C1  0B86    		DW	C_3
95C3  EA8A    		DW	C_QPAIRS
95C5  348B    		DW	C_COMPILE		;Compile next word into dictionary
95C7  1681    		DW	C_PLOOP			;Loop + stack & branch if not done
95C9  4C95    		DW	C_BACK
95CB  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
95CD          	W_UNTIL
95CD  C5554E54		DB	$C5,'UNTI','L'+$80
      49CC
95D3  B795    		DW	W_PLUSLOOP
95D5          	C_UNTIL
95D5  7C85    		DW	E_COLON			;Interpret following word sequence
95D7  FB85    		DW	C_1			;Put 1 on stack
95D9  EA8A    		DW	C_QPAIRS
95DB  348B    		DW	C_COMPILE		;Compile next word into dictionary
95DD  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
95DF  4C95    		DW	C_BACK
95E1  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
95E3          	W_END
95E3  C3454EC4		DB	$C3,'EN','D'+$80
95E7  CD95    		DW	W_UNTIL
95E9          	C_END
95E9  7C85    		DW	E_COLON			;Interpret following word sequence
95EB  D595    		DW	C_UNTIL
95ED  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
95EF          	W_AGAIN
95EF  C5414741		DB	$C5,'AGAI','N'+$80
      49CE
95F5  E395    		DW	W_END
95F7          	C_AGAIN
95F7  7C85    		DW	E_COLON			;Interpret following word sequence
95F9  FB85    		DW	C_1			;Put 1 on stack
95FB  EA8A    		DW	C_QPAIRS
95FD  348B    		DW	C_COMPILE		;Compile next word into dictionary
95FF  B080    		DW	C_BRANCH		;Add following offset to BC
9601  4C95    		DW	C_BACK
9603  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9605          	W_REPEAT
9605  C6524550		DB	$C6,'REPEA','T'+$80
      4541D4
960C  EF95    		DW	W_AGAIN
960E          	C_REPEAT
960E  7C85    		DW	E_COLON			;Interpret following word sequence
9610  B583    		DW	C_MOVER			;Move value from data to return stack
9612  B583    		DW	C_MOVER			;Move value from data to return stack
9614  F795    		DW	C_AGAIN
9616  CB83    		DW	C_RMOVE			;Move word from return to data stack
9618  CB83    		DW	C_RMOVE			;Move word from return to data stack
961A  0386    		DW	C_2
961C  5489    		DW	C_MINUS
961E  7095    		DW	C_ENDIF
9620  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9622          	W_IF
9622  C249C6  		DB	$C2,'I','F'+$80
9625  0596    		DW	W_REPEAT
9627          	C_IF
9627  7C85    		DW	E_COLON			;Interpret following word sequence
9629  348B    		DW	C_COMPILE		;Compile next word into dictionary
962B  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
962D  1789    		DW	C_HERE			;Dictionary pointer onto stack
962F  F385    		DW	C_ZERO			;Put zero on stack
9631  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
9633  0386    		DW	C_2
9635  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9637          	W_ELSE
9637  C4454C53		DB	$C4,'ELS','E'+$80
      C5
963C  2296    		DW	W_IF
963E          	C_ELSE
963E  7C85    		DW	E_COLON			;Interpret following word sequence
9640  0386    		DW	C_2
9642  EA8A    		DW	C_QPAIRS
9644  348B    		DW	C_COMPILE		;Compile next word into dictionary
9646  B080    		DW	C_BRANCH		;Add following offset to BC
9648  1789    		DW	C_HERE			;Dictionary pointer onto stack
964A  F385    		DW	C_ZERO			;Put zero on stack
964C  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
964E  A284    		DW	C_SWAP			;Swap top 2 values on stack
9650  0386    		DW	C_2
9652  7095    		DW	C_ENDIF
9654  0386    		DW	C_2
9656  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9658          	W_WHILE
9658  C5574849		DB	$C5,'WHIL','E'+$80
      4CC5
965E  3796    		DW	W_ELSE
9660          	C_WHILE
9660  7C85    		DW	E_COLON			;Interpret following word sequence
9662  2796    		DW	C_IF
9664  EF88    		DW	C_2PLUS			;2 plus
9666  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9668          	W_SPACES
9668  86535041		DB	$86,'SPACE','S'+$80
      4345D3
966F  5896    		DW	W_WHILE
9671          	C_SPACES
9671  7C85    		DW	E_COLON			;Interpret following word sequence
9673  F385    		DW	C_ZERO			;Put zero on stack
9675  5792    		DW	C_MAX
9677  F989    		DW	C_QUERYDUP
9679  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
967B  0C00    		DW	B0034-$			;000Ch
967D  F385    		DW	C_ZERO			;Put zero on stack
967F  2281    		DW	C_LDO			;Put start & end loop values on RPP
9681          	B0035
9681  EA89    		DW	C_SPACE			;Output space
9683  DD80    		DW	C_LLOOP			;Increment loop & branch if not done
9685  FCFF    		DW	B0035-$			;FFFCh
9687          	B0034
9687  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9689          	W_LESSHARP
9689  823CA3  		DB	$82,'<','#'+$80
968C  6896    		DW	W_SPACES
968E          	C_LESSHARP
968E  7C85    		DW	E_COLON			;Interpret following word sequence
9690  F28D    		DW	C_PAD			;Save intermediate string address
9692  5587    		DW	C_HLD
9694  3985    		DW	C_STORE			;Store word at addr
9696  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9698          	W_SHARPGT
9698  8223BE  		DB	$82,'#','>'+$80
969B  8996    		DW	W_LESSHARP
969D          	C_SHARPGT
969D  7C85    		DW	E_COLON			;Interpret following word sequence
969F  8684    		DW	C_DROP			;Drop top value from stack
96A1  8684    		DW	C_DROP			;Drop top value from stack
96A3  5587    		DW	C_HLD
96A5  0285    		DW	C_FETCH			;Get word from addr on stack
96A7  F28D    		DW	C_PAD			;Save intermediate string address
96A9  7784    		DW	C_OVER			;Copy 2nd down to top of stack
96AB  5489    		DW	C_MINUS
96AD  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
96AF          	W_SIGN
96AF  84534947		DB	$84,'SIG','N'+$80
      CE
96B4  9896    		DW	W_SHARPGT
96B6          	C_SIGN
96B6  7C85    		DW	E_COLON			;Interpret following word sequence
96B8  C589    		DW	C_ROT			;3rd valu down to top of stack
96BA  0284    		DW	C_0LESS			;Less than 0
96BC  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
96BE  0800    		DW	B0036-$			;0008h
96C0  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
96C2  2D00    		DW	$002D
96C4  DA8D    		DW	C_HOLD
96C6          	B0036
96C6  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
96C8          	W_SHARP
96C8  81A3    		DB	$81,'#'+$80
96CA  AF96    		DW	W_SIGN
96CC          	C_SHARP
96CC  7C85    		DW	E_COLON			;Interpret following word sequence
96CE  2487    		DW	C_BASE			;Put BASE addr on stack
96D0  0285    		DW	C_FETCH			;Get word from addr on stack
96D2  0F93    		DW	C_MDIVMOD
96D4  C589    		DW	C_ROT			;3rd valu down to top of stack
96D6  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
96D8  0900    		DW	$0009
96DA  7784    		DW	C_OVER			;Copy 2nd down to top of stack
96DC  7589    		DW	C_LESSTHAN
96DE  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
96E0  0800    		DW	B0037-$			;0008h
96E2  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
96E4  0700    		DW	$0007
96E6  1384    		DW	C_PLUS			;n1 + n2
96E8          	B0037
96E8  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
96EA  3000    		DW	$0030
96EC  1384    		DW	C_PLUS			;n1 + n2
96EE  DA8D    		DW	C_HOLD
96F0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
96F2          	W_SHARPS
96F2  8223D3  		DB	$82,'#','S'+$80
96F5  C896    		DW	W_SHARP
96F7          	C_SHARPS
96F7  7C85    		DW	E_COLON			;Interpret following word sequence
96F9          	B0038
96F9  CC96    		DW	C_SHARP
96FB  7784    		DW	C_OVER			;Copy 2nd down to top of stack
96FD  7784    		DW	C_OVER			;Copy 2nd down to top of stack
96FF  1883    		DW	C_OR			;OR
9701  E783    		DW	C_0EQUALS		;=0
9703  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
9705  F4FF    		DW	B0038-$			;FFF4h
9707  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9709          	W_DDOTR
9709  83442ED2		DB	$83,'D.','R'+$80
970D  F296    		DW	W_SHARPS
970F          	C_DDOTR
970F  7C85    		DW	E_COLON			;Interpret following word sequence
9711  B583    		DW	C_MOVER			;Move value from data to return stack
9713  A284    		DW	C_SWAP			;Swap top 2 values on stack
9715  7784    		DW	C_OVER			;Copy 2nd down to top of stack
9717  3392    		DW	C_DABS
9719  8E96    		DW	C_LESSHARP
971B  F796    		DW	C_SHARPS
971D  B696    		DW	C_SIGN
971F  9D96    		DW	C_SHARPGT
9721  CB83    		DW	C_RMOVE			;Move word from return to data stack
9723  7784    		DW	C_OVER			;Copy 2nd down to top of stack
9725  5489    		DW	C_MINUS
9727  7196    		DW	C_SPACES
9729  228C    		DW	C_TYPE			;Output n bytes from addr
972B  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
972D          	W_DOTR
972D  822ED2  		DB	$82,'.','R'+$80
9730  0997    		DW	W_DDOTR
9732          	C_DOTR
9732  7C85    		DW	E_COLON			;Interpret following word sequence
9734  B583    		DW	C_MOVER			;Move value from data to return stack
9736  EC91    		DW	C_SINGTODUB		;Change single number to double
9738  CB83    		DW	C_RMOVE			;Move word from return to data stack
973A  0F97    		DW	C_DDOTR
973C  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
973E          	W_DDOT
973E  8244AE  		DB	$82,'D','.'+$80
9741  2D97    		DW	W_DOTR
9743          	C_DDOT
9743  7C85    		DW	E_COLON			;Interpret following word sequence
9745  F385    		DW	C_ZERO			;Put zero on stack
9747  0F97    		DW	C_DDOTR
9749  EA89    		DW	C_SPACE			;Output space
974B  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
974D          	W_DOT
974D  81AE    		DB	$81,'.'+$80
974F  3E97    		DW	W_DDOT
9751          	C_DOT
9751  7C85    		DW	E_COLON			;Interpret following word sequence
9753  EC91    		DW	C_SINGTODUB		;Change single number to double
9755  4397    		DW	C_DDOT
9757  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9759          	W_QUESTION
9759  81BF    		DB	$81,'?'+$80
975B  4D97    		DW	W_DOT
975D          	C_QUESTION
975D  7C85    		DW	E_COLON			;Interpret following word sequence
975F  0285    		DW	C_FETCH			;Get word from addr on stack
9761  5197    		DW	C_DOT
9763  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9765          	W_UDOT					;Output as unsigned value
9765  8255AE  		DB	$82,'U','.'+$80
9768  5997    		DW	W_QUESTION
976A          	C_UDOT
976A  7C85    		DW	E_COLON			;Interpret following word sequence
976C  F385    		DW	C_ZERO			;Put zero on stack
976E  4397    		DW	C_DDOT			;Output double value
9770  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9772          	W_VLIST
9772  85564C49		DB	$85,'VLIS','T'+$80
      53D4
9778  6597    		DW	W_UDOT
977A          	C_VLIST
977A  7C85    		DW	E_COLON			;Interpret following word sequence
977C  FF86    		DW	C_CONTEXT		;Leave vocab pointer on stack
977E  0285    		DW	C_FETCH			;Get word from addr on stack
9780  0285    		DW	C_FETCH			;Get word from addr on stack
9782  4C82    		DW	C_CR			;Output [CR][LF]
9784          	B0039
9784  AF84    		DW	C_DUP			;Duplicate top value on stack
9786  798A    		DW	C_PFA			;Convert NFA to PFA
9788  A284    		DW	C_SWAP			;Swap top 2 values on stack
978A  678F    		DW	C_ID			;Print definition name from name field addr
978C  458A    		DW	C_LFA			;Convert param addr to link addr
978E  0285    		DW	C_FETCH			;Get word from addr on stack
9790  AF84    		DW	C_DUP			;Duplicate top value on stack
9792  E783    		DW	C_0EQUALS		;=0
9794  3D82    		DW	C_TERMINAL		;Check for break key
9796  1883    		DW	C_OR			;OR
9798  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
979A  EAFF    		DW	B0039-$			;FFE2h
979C  8684    		DW	C_DROP			;Drop top value from stack
979E  4C82    		DW	C_CR			;Output [CR][LF]
97A0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
97A2          	W_LIST
97A2  844C4953		DB	$84,'LIS','T'+$80
      D4
97A7  7297    		DW	W_VLIST
97A9          	C_LIST
97A9  7C85    		DW	E_COLON			;Interpret following word sequence
97AB  2487    		DW	C_BASE			;Put BASE addr on stack
97AD  0285    		DW	C_FETCH			;Put current base on stack
97AF  A284    		DW	C_SWAP			;Get number of list screen to top
97B1  958B    		DW	C_DECIMAL		;Sets decimal mode
97B3  4C82    		DW	C_CR			;Output [CR][LF]
97B5  AF84    		DW	C_DUP			;Duplicate top value on stack
97B7  E486    		DW	C_SCR			;Set most recently listed
97B9  3985    		DW	C_STORE			;Store word at addr
97BB  838C    		DW	C_CQUOTE		;Output following string
97BD  06      		DB	S_END3-S_START3
97BE          	S_START3
97BE  53435220		DB	'SCR # '
      2320
97C4          	S_END3
97C4  5197    		DW	C_DOT			;Output the screen number
97C6  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
97C8  1000    		DW	$0010			;16 lines to do
97CA  F385    		DW	C_ZERO			;From 0 to 15
97CC  2281    		DW	C_LDO			;Put start & end loop values on RPP
97CE          	DO_LINE
97CE  4C82    		DW	C_CR			;Output [CR][LF]
97D0  3E81    		DW	C_I			;Line number onto data stack
97D2  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
97D4  0300    		DW	$0003			;Fromat right justified 3 characters
97D6  3297    		DW	C_DOTR			;Output formatted
97D8  EA89    		DW	C_SPACE			;Output space
97DA  3E81    		DW	C_I			;Line number onto data stack
97DC  E486    		DW	C_SCR			;Get screen number
97DE  0285    		DW	C_FETCH			;Get word from addr on stack
97E0  5093    		DW	C_DOTLINE		;Output line from screen
97E2  3D82    		DW	C_TERMINAL		;Check for break key
97E4  C880    		DW	C_0BRANCH		;Jump if no break key
97E6  0400    		DW	NO_BRK-$		;
97E8  A183    		DW	C_LEAVE			;Else set loop index to limit (quit loop)
97EA          	NO_BRK
97EA  DD80    		DW	C_LLOOP			;Increment loop & branch if not done
97EC  E2FF    		DW	DO_LINE-$		;
97EE  4C82    		DW	C_CR			;Output [CR][LF]
97F0  2487    		DW	C_BASE			;Put BASE addr on stack
97F2  3985    		DW	C_STORE			;Restore original base
97F4  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
97F6          	W_INDEX
97F6  85494E44		DB	$85,'INDE','X'+$80
      45D8
97FC  A297    		DW	W_LIST
97FE          	C_INDEX
97FE  7C85    		DW	E_COLON			;Interpret following word sequence
9800  E388    		DW	C_1PLUS			;1 plus
9802  A284    		DW	C_SWAP			;Swap top 2 values on stack
9804  2281    		DW	C_LDO			;Put start & end loop values on RPP
9806          	B003D
9806  4C82    		DW	C_CR			;Output [CR][LF]
9808  3E81    		DW	C_I			;Copy LOOP index to data stack
980A  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
980C  0300    		DW	$0003
980E  3297    		DW	C_DOTR
9810  EA89    		DW	C_SPACE			;Output space
9812  F385    		DW	C_ZERO			;Put zero on stack
9814  3E81    		DW	C_I			;Copy LOOP index to data stack
9816  5093    		DW	C_DOTLINE		;Output line from screen
9818  3D82    		DW	C_TERMINAL		;Check for break key
981A  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
981C  0400    		DW	B003C-$			;$0004
981E  A183    		DW	C_LEAVE			;Quit loop by making index = limit
9820          	B003C
9820  DD80    		DW	C_LLOOP			;Increment loop & branch if not done
9822  E4FF    		DW	B003D-$			;FFE4h
9824  4C82    		DW	C_CR			;Output [CR][LF]
9826  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9828          	W_INT
9828  C43B494E		DB	$C4,';IN','T'+$80
      D4
982D  F697    		DW	W_INDEX
982F          	C_INT
982F  7C85    		DW	E_COLON			;Interpret following word sequence
9831  FD8A    		DW	C_WHATSTACK		;Check stack pointer, error if not ok
9833  348B    		DW	C_COMPILE		;Compile next word into dictionary
9835  3D98    		DW	X_INT
9837  4A8B    		DW	C_LEFTBRKT		;Set STATE to execute
9839  6D8B    		DW	C_SMUDGE
983B  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
983D          	X_INT
983D  3F98    		DW	2+$			;Vector to code
983F  214CFE  		LD	HL,INTFLAG
9842  CBB6    		RES	6,(HL)
9844  FB      		EI
9845  C38C83  		JP	X_STOP
		
9848          	W_INTFLAG
9848  87494E54		DB	$87,'INTFLA','G'+$80
      464C41C7
9850  2898    		DW	W_INT
9852          	C_INTFLAG
9852  E385    		DW	X_USER			;Put next word on stack then do next
9854  4C00    		DW	INTFLAG-SYSTEM
		
9856          	W_INTVECT
9856  87494E54		DB	$87,'INTVEC','T'+$80
      564543D4
985E  4898    		DW	W_INTFLAG
9860          	C_INTVECT
9860  E385    		DW	X_USER			;Put next word on stack then do next
9862  4E00    		DW	INTVECT-SYSTEM
		
9864          	W_CPU
9864  842E4350		DB	$84,'.CP','U'+$80
      D5
9869  5698    		DW	W_INTVECT
986B          	C_CPU
986B  7C85    		DW	E_COLON			;Interpret following word sequence
986D  838C    		DW	C_CQUOTE		;Output following string
986F  04      		DB	S_END4-S_START4
9870          	S_START4
9870  5A383020		DB	'Z80 '
9874          	S_END4
9874  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9876          	W_2SWAP
9876  85325357		DB	$85,'2SWA','P'+$80
      41D0
987C  6498    		DW	W_CPU
987E          	C_2SWAP
987E  7C85    		DW	E_COLON			;Interpret following word sequence
9880  C589    		DW	C_ROT			;3rd valu down to top of stack
9882  B583    		DW	C_MOVER			;Move value from data to return stack
9884  C589    		DW	C_ROT			;3rd valu down to top of stack
9886  CB83    		DW	C_RMOVE			;Move word from return to data stack
9888  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
988A          	W_2OVER
988A  85324F56		DB	$85,'2OVE','R'+$80
      45D2
9890  7698    		DW	W_2SWAP
9892          	C_2OVER
9892  7C85    		DW	E_COLON			;Interpret following word sequence
9894  B583    		DW	C_MOVER			;Move value from data to return stack
9896  B583    		DW	C_MOVER			;Move value from data to return stack
9898  BD84    		DW	C_2DUP			;Dup top 2 values on stack
989A  CB83    		DW	C_RMOVE			;Move word from return to data stack
989C  CB83    		DW	C_RMOVE			;Move word from return to data stack
989E  7E98    		DW	C_2SWAP
98A0  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
98A2          	W_EXIT
98A2  84455849		DB	$84,'EXI','T'+$80
      D4
98A7  8A98    		DW	W_2OVER
98A9          	C_EXIT
98A9  8C83    		DW	X_STOP
		
98AB          	W_J		;Push outer loop value on stack
98AB  81CA    		DB	$81,'J'+$80
98AD  A298    		DW	W_EXIT
98AF          	C_J
98AF  B198    		DW	2+$			;Vector to code
98B1  2A46FE  		LD	HL,(RPP)		;Get return stack pointer
98B4  23      		INC	HL			;Skip inner loop values
98B5  23      		INC	HL			;
98B6  23      		INC	HL			;
98B7  23      		INC	HL			;
98B8  C34381  		JP	X_I2
		
98BB          	W_ROLL
98BB  84524F4C		DB	$84,'ROL','L'+$80
      CC
98C0  AB98    		DW	W_J
98C2          	C_ROLL
98C2  7C85    		DW	E_COLON			;Interpret following word sequence
98C4  AF84    		DW	C_DUP			;Duplicate top value on stack
98C6  F385    		DW	C_ZERO			;Put zero on stack
98C8  B789    		DW	C_GREATER
98CA  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
98CC  2C00    		DW	B003E-$			;002Ch
98CE  AF84    		DW	C_DUP			;Duplicate top value on stack
98D0  B583    		DW	C_MOVER			;Move value from data to return stack
98D2  D489    		DW	C_PICK
98D4  CB83    		DW	C_RMOVE			;Move word from return to data stack
98D6  F385    		DW	C_ZERO			;Put zero on stack
98D8  A284    		DW	C_SWAP			;Swap top 2 values on stack
98DA  2281    		DW	C_LDO			;Put start & end loop values on RPP
98DC          	B003F
98DC  3E83    		DW	C_SPFETCH		;Stack pointer onto stack
98DE  3E81    		DW	C_I			;Copy LOOP index to data stack
98E0  AF84    		DW	C_DUP			;Duplicate top value on stack
98E2  1384    		DW	C_PLUS			;n1 + n2
98E4  1384    		DW	C_PLUS			;n1 + n2
98E6  AF84    		DW	C_DUP			;Duplicate top value on stack
98E8  0889    		DW	C_2MINUS		;2 minus
98EA  0285    		DW	C_FETCH			;Get word from addr on stack
98EC  A284    		DW	C_SWAP			;Swap top 2 values on stack
98EE  3985    		DW	C_STORE			;Store word at addr
98F0  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
98F2  FFFF    		DW	$FFFF
98F4  1681    		DW	C_PLOOP			;Loop + stack & branch if not done
98F6  E6FF    		DW	B003F-$			;FFE6h
98F8          	B003E
98F8  8684    		DW	C_DROP			;Drop top value from stack
98FA  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
98FC          	W_DEPTH
98FC  85444550		DB	$85,'DEPT','H'+$80
      54C8
9902  BB98    		DW	W_ROLL
9904          	C_DEPTH
9904  7C85    		DW	E_COLON			;Interpret following word sequence
9906  6B86    		DW	C_S0			;Push S0 (initial data stack pointer)
9908  0285    		DW	C_FETCH			;Get word from addr on stack
990A  3E83    		DW	C_SPFETCH		;Stack pointer onto stack
990C  5489    		DW	C_MINUS
990E  0386    		DW	C_2
9910  CC92    		DW	C_DIV
9912  FC88    		DW	C_1MINUS		;1 minus
9914  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9916          	W_DLESSTHAN
9916  8244BC  		DB	$82,'D','<'+$80
9919  FC98    		DW	W_DEPTH
991B          	C_DLESSTHAN
991B  7C85    		DW	E_COLON			;Interpret following word sequence
991D  C589    		DW	C_ROT			;3rd valu down to top of stack
991F  BD84    		DW	C_2DUP			;Dup top 2 values on stack
9921  6989    		DW	C_EQUALS
9923  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
9925  0A00    		DW	B0040-$			;000Ah
9927  9484    		DW	C_2DROP			;Drop top two values from stack
9929  9789    		DW	C_ULESS			;IF stack-1 < stack_top leave true flag
992B  B080    		DW	C_BRANCH		;Add following offset to BC
992D  0800    		DW	B0041-$			;0008h
992F          	B0040
992F  7E98    		DW	C_2SWAP
9931  9484    		DW	C_2DROP			;Drop top two values from stack
9933  B789    		DW	C_GREATER
9935          	B0041
9935  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9937          	W_0GREATER
9937  8230BE  		DB	$82,'0','>'+$80
993A  1699    		DW	W_DLESSTHAN
993C          	C_0GREATER
993C  7C85    		DW	E_COLON			;Interpret following word sequence
993E  F385    		DW	C_ZERO			;Put zero on stack
9940  B789    		DW	C_GREATER
9942  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9944          	W_DOTS
9944  822ED3  		DB	$82,'.','S'+$80
9947  3799    		DW	W_0GREATER
9949          	C_DOTS
9949  7C85    		DW	E_COLON			;Interpret following word sequence
994B  4C82    		DW	C_CR			;Output [CR][LF]
994D  0499    		DW	C_DEPTH
994F  C880    		DW	C_0BRANCH		;Add offset to BC if stack top = 0
9951  2000    		DW	B0042-$			;0020h
9953  3E83    		DW	C_SPFETCH		;Stack pointer onto stack
9955  0889    		DW	C_2MINUS		;2 minus
9957  6B86    		DW	C_S0			;Push S0 (initial data stack pointer)
9959  0285    		DW	C_FETCH			;Get word from addr on stack
995B  0889    		DW	C_2MINUS		;2 minus
995D  2281    		DW	C_LDO			;Put start & end loop values on RPP
995F          	B0043
995F  3E81    		DW	C_I			;Copy LOOP index to data stack
9961  0285    		DW	C_FETCH			;Get word from addr on stack
9963  5197    		DW	C_DOT
9965  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
9967  FEFF    		DW	$FFFE
9969  1681    		DW	C_PLOOP			;Loop + stack & branch if not done
996B  F4FF    		DW	B0043-$			;FFF4h
996D  B080    		DW	C_BRANCH		;Add following offset to BC
996F  1100    		DW	S_END5-$		;0011h
9971          	B0042
9971  838C    		DW	C_CQUOTE		;Output following string
9973  0C      		DB	S_END5-S_START5
9974          	S_START5
9974  53544143		DB	'STACK EMPTY '
      4B20454D
      50545920
9980          	S_END5
9980  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9982          	W_CODE
9982  84434F44		DB	$84,'COD','E'+$80
      C5
9987  4499    		DW	W_DOTS
9989          	C_CODE
9989  7C85    		DW	E_COLON			;Interpret following word sequence
998B  D38A    		DW	C_QEXEC			;Error not if not in execute mode
998D  778F    		DW	C_XXX1
998F  4D83    		DW	C_SPSTORE		;Set initial stack pointer value
9991  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9993          	W_ENDCODE
9993  88454E44		DB	$88,'END-COD','E'+$80
      2D434F44
      C5
999C  8299    		DW	W_CODE
999E          	C_ENDCODE
999E  7C85    		DW	E_COLON			;Interpret following word sequence
99A0  0D87    		DW	C_CURRENT
99A2  0285    		DW	C_FETCH			;Get word from addr on stack
99A4  FF86    		DW	C_CONTEXT
99A6  3985    		DW	C_STORE			;Store word at addr
99A8  D38A    		DW	C_QEXEC			;Error not if not in execute mode
99AA  FD8A    		DW	C_WHATSTACK		;Check stack pointer, error if not ok
99AC  6D8B    		DW	C_SMUDGE
99AE  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
99B0          	W_NEXT
99B0  C44E4558		DB	$C4,'NEX','T'+$80
      D4
99B5  9399    		DW	W_ENDCODE
99B7          	C_NEXT
99B7  7C85    		DW	E_COLON			;Interpret following word sequence
99B9  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
99BB  C300    		DW	$00C3			;Jump instruction
99BD  4489    		DW	C_CCOMMA		;Save as 8 bit value
99BF  8C80    		DW	C_LIT			;Puts next 2 bytes on the stack
99C1  6680    		DW	NEXT			;The address of NEXT
99C3  3389    		DW	C_COMMA			;Reserve 2 bytes and save n
99C5  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
99C7          	W_IM2		;Set interrupt mode 2
99C7  83494DB2		DB	$83,'IM','2'+$80
99CB  B099    		DW	W_NEXT
99CD          	C_IM2
99CD  CF99    		DW	2+$			;Vector to code
99CF  ED5E    		IM	2			;Mode 2
99D1  C36680  		JP	NEXT
		
99D4          	W_IM1		;Set interrupt mode 1
99D4  83494DB1		DB	$83,'IM','1'+$80
99D8  C799    		DW	W_IM2
99DA          	C_IM1
99DA  DC99    		DW	2+$			;Vector to code
99DC  ED56    		IM	1			;Mode 1
99DE  C36680  		JP	NEXT
		
99E1          	W_IM0		;Set interrupt mode 0
99E1  83494DB0		DB	$83,'IM','0'+$80
99E5  D499    		DW	W_IM1
99E7          	C_IM0
99E7  E999    		DW	2+$			;Vector to code
99E9  ED46    		IM	0			;Mode 0
99EB  C36680  		JP	NEXT
		
99EE          	W_DI		;Disable interrupt
99EE  8244C9  		DB	$82,'D','I'+$80
99F1  E199    		DW	W_IM0
99F3          	C_DI
99F3  F599    		DW	2+$			;Vector to code
99F5  F3      		DI				;Disable interrupt
99F6  C36680  		JP	NEXT
		
99F9          	W_EI		;Enable interrupt
99F9  8245C9  		DB	$82,'E','I'+$80
99FC  EE99    		DW	W_DI
99FE          	C_EI
99FE  009A    		DW	2+$			;Vector to code
9A00  FB      		EI				;Enable interrupt
9A01  C36680  		JP	NEXT
		
9A04          	W_MON		;Jump to m/c monitor
9A04  834D4FCE		DB	$83,'MO','N'+$80
9A08  F999    		DW	W_EI
9A0A          	C_MON
9A0A  0C9A    		DW 	2+$
9A0C  C30000  		JP	MONSTART
		
9A0F          	W_LLOAD
9A0F  854C4C4F		DB	$85,'LLOA','D'+$80
      41C4
9A15  049A    		DW	W_MON
9A17          	C_LLOAD
9A17  7C85    		DW	E_COLON			;Interpret following word sequence
9A19  1E94    		DW	C_BLOCK			;Get block address
9A1B  8C80    		DW	C_LIT			;Enter loop with null
9A1D  0000    		DW	$0000			;
9A1F          	LL_BEGIN
9A1F  AF84    		DW	C_DUP			;Dup key
9A21  C880    		DW	C_0BRANCH		;If null then don't store
9A23  2800    		DW	LL_NULL-$		;
9A25  AF84    		DW	C_DUP			;Dup key again
9A27  8C80    		DW	C_LIT			;Compare to [CR]
9A29  0D00    		DW	$000D			;
9A2B  6989    		DW	C_EQUALS		;
9A2D  C880    		DW	C_0BRANCH		;If not [CR] then jump
9A2F  1200    		DW	LL_STORE-$		;
9A31  8684    		DW	C_DROP			;Drop the [CR]
9A33  1E86    		DW	C_CL			;Get characters per line
9A35  1384    		DW	C_PLUS			;Add to current addr
9A37  1E86    		DW	C_CL			;Make CL MOD value
9A39  4384    		DW	C_NEGATE		;Form 2s complement of n
9A3B  0683    		DW	C_AND			;Mask out bits
9A3D  B080    		DW	C_BRANCH		;Done this bit so jump
9A3F  0600    		DW	NO_STORE-$
9A41          	LL_STORE
9A41  7784    		DW	C_OVER			;Get address to store at
9A43  3985    		DW	C_STORE			;Save chr
9A45          	NO_STORE
9A45  E388    		DW	C_1PLUS			;Next addres
9A47  B080    		DW	C_BRANCH		;Done so jump
9A49  0400    		DW	LL_CHAR-$		;
9A4B          	LL_NULL
9A4B  8684    		DW	C_DROP			;Was null so drop it
9A4D          	LL_CHAR
9A4D  2B82    		DW	C_KEY			;Get key
9A4F  AF84    		DW	C_DUP			;Duplicate it
9A51  8C80    		DW	C_LIT			;Compare with [CTRL] Z
9A53  1A00    		DW	$001A			;
9A55  6989    		DW	C_EQUALS		;
9A57  C880    		DW	C_0BRANCH		;If not EOF then jump
9A59  C6FF    		DW	LL_BEGIN-$		;
9A5B  8684    		DW	C_DROP			;Drop EOF character
9A5D  8684    		DW	C_DROP			;Drop next address
9A5F  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9A61          	W_TASK
9A61  84544153		DB	$84,'TAS','K'+$80
      CB
9A66  0F9A    		DW	W_LLOAD
9A68          	C_TASK
9A68  7C85    		DW	E_COLON			;Interpret following word sequence
9A6A  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
9A6C          	W_TASKEND
		
9A6C          	W_EDITI
		
9A6C          	W_CLEAR		;Clear block n
9A6C  85434C45		DB	$85,'CLEA','R'+$80
      41D2
9A72  619A    		DW	W_TASK
9A74          	C_CLEAR
9A74  7C85    		DW	E_COLON			;Interpret following word sequence
9A76  AF84    		DW	C_DUP			;Duplicate number
9A78  E486    		DW	C_SCR			;Get SCR addr
9A7A  3985    		DW	C_STORE			;Store screen number
9A7C  1E94    		DW	C_BLOCK			;Get the address of the block
9A7E  4E86    		DW	C_BBUF			;Put number of bytes/block on stack
9A80  BA8D    		DW	C_ERASE			;Clear the block
9A82  8A83    		DW	C_STOP			;Pop BC from return stack (=next)
		
9A84          	CF_UKEY					;Get key onto stack
9A84  869A    		DW	2+$			;Vector to code
9A86  CDBF9A  		CALL	CHR_RD			;User key in routine
9A89  6F      		LD	L,A			;Put key on stack
9A8A  2600    		LD	H,$00			;
9A8C  C36580  		JP	NEXTS1			;Save & NEXT
		
9A8F          	CF_UEMIT				;Chr from stack to output
9A8F  919A    		DW	2+$			;Vector to code
9A91  E1      		POP	HL			;Get CHR to output
9A92  7D      		LD	A,L			;Put in A
9A93  C5      		PUSH	BC			;Save regs
9A94  D5      		PUSH	DE			;
9A95  CDF39A  		CALL	CHR_WR			;User output routine
9A98  D1      		POP	DE			;Restore regs
9A99  C1      		POP	BC			;
9A9A  C36680  		JP	NEXT			;
		
9A9D          	CF_UCR					;CR output
9A9D  9F9A    		DW	2+$			;Vector to code
9A9F  C5      		PUSH	BC			;Save regs
9AA0  D5      		PUSH	DE			;Just in case
9AA1  3E0D    		LD	A,$0D			;Carrage return
9AA3  CDF39A  		CALL	CHR_WR			;User output routine
9AA6  3E0A    		LD	A,$0A			;Line feed
9AA8  CDF39A  		CALL	CHR_WR			;User output routine
9AAB  D1      		POP	DE			;Get regs back
9AAC  C1      		POP	BC			;
9AAD  C36680  		JP	NEXT			;Next
		
9AB0          	CF_UQTERMINAL				;Test for user break
9AB0  B29A    		DW	2+$			;Vector to code
9AB2  C5      		PUSH	BC			;Save regs
9AB3  D5      		PUSH	DE			;Just in case
9AB4  CDD99A  		CALL	BREAKKEY		;User break test routine
9AB7  D1      		POP	DE			;Get regs back
9AB8  C1      		POP	BC			;
9AB9  2600    		LD	H,$00			;Clear H
9ABB  6F      		LD	L,A			;Result in L
9ABC  C36580  		JP	NEXTS1			;Store it & Next
		
			;Serial I/O routines
		
		; Change these to suit your target system .....
		
9ABF          	CHR_RD					;8251 Character in
9ABF  3A66FE  		LD	A,(KEYBUF)		;Get key buffer
9AC2  B7      		OR	A			;Set flags
9AC3  280B    		JR	Z,NO_BUF_KEY		;If empty go wait for key
9AC5  3267FE  		LD	(KEYBUF+1),A		;Save key
9AC8  AF      		XOR	A			;Clear buffer
9AC9  3266FE  		LD	(KEYBUF),A		;
9ACC  3A67FE  		LD	A,(KEYBUF+1)		;Get key back
9ACF  C9      		RET
9AD0          	NO_BUF_KEY
9AD0  DB61    		IN	A,(URTCNT)		;Get status byte
9AD2  CB4F    		BIT	1,A			;Check buffer full bit
9AD4  28FA    		JR	Z,NO_BUF_KEY		;Not full so wait
9AD6  DB60    		IN	A,(URTDA)		;Get byte from buffer
9AD8  C9      		RET				;
		
9AD9          	BREAKKEY
9AD9  3A66FE  		LD	A,(KEYBUF)		;Get buffer contents
9ADC  B7      		OR	A			;Set the flags
9ADD  200F    		JR	NZ,NO_KEY		;If buffer is full then exit
9ADF  DB61    		IN	A,(URTCNT)		;Get status byte
9AE1  CB4F    		BIT	1,A			;Check buffer full bit
9AE3  2809    		JR	Z,NO_KEY		;Not full so go on
9AE5  DB60    		IN	A,(URTDA)		;Get byte from buffer
9AE7  FE03    		CP	$03			;Is it break
9AE9  2805    		JR	Z,WAS_BRK
9AEB  3266FE  		LD	(KEYBUF),A		;Not break so save key
9AEE          	NO_KEY
9AEE  AF      		XOR	A			;Wasn't break, or no key, so clear
9AEF  C9      		RET
9AF0          	WAS_BRK
9AF0  3E01    		LD	A,$01			;Was break so set flag
9AF2  C9      		RET
		
9AF3          	CHR_WR					;8251 Character out
9AF3  E67F    		AND	$7F			;Mask off top bit
9AF5  F5      		PUSH	AF			;Save byte for now
9AF6          	WAIT1
9AF6  DB61    		IN	A,(URTCNT)
9AF8  CB47    		BIT	0,A			;Check buffer full bit
9AFA  28FA    		JR	Z,WAIT1			;Out buffer full so wait
9AFC  F1      		POP	AF			;Get byte back
9AFD  D360    		OUT	(URTDA),A		;Send byte
9AFF  C9      		RET				;
		
9B00          		END



Statistics:

     4	passes
     0	jr promotions
   798	symbols
  7016	bytes



Symbol Table:

b0000           89ad     
b0001           89b1     
b0002           8a03     
b0003           8aaf     
b0004           8ab1     
b0005           8c40     
b0006           8c42     
b0007           8c72     
b0008           8c76     
b0009           8c58     
b000a           8cba     
b000b           8cc0     
b000c           8d0d     
b000d           8d05     
b000e           8d09     
b000f           8d33     
b0010           8d25     
b0011           8d27     
b0012           8cd5     
b0013           8d8f     
b0014           8d8b     
b0015           8d93     
b0016           8e19     
b0017           8e1d     
b0018           8e95     
b0019           8e8f     
b001a           8e59     
b001b           8ee6     
b001c           8ec0     
b001d           8ef0     
b001e           8f18     
b001f           8f40     
b0020           8f5f     
b0021           8f8d     
b0022           8ffb     
b0023           9018     
b0025           906d     
b0026           9071     
b0027           9091     
b0028           908b     
b0029           908f     
b002a           9055     
b002c           9139     
b002d           920a     
b002e           921c     
b002f           924d     
b0030           9263     
b0031           938a     
b0032           9386     
b0033           9395     
b0034           9687     
b0035           9681     
b0036           96c6     
b0037           96e8     
b0038           96f9     
b0039           9784     
b003c           9820     
b003d           9806     
b003e           98f8     
b003f           98dc     
b0040           992f     
b0041           9935     
b0042           9971     
b0043           995f     
b004f           8c32     
b0050           9483     
b0051           9469     
b0054           8a14     
backspace       801e     
base            fe26     
blk             fe16     
block_size     = 200     
breakkey        9ad9     
buffers        =   1     
c_0branch       80c8     
c_0equals       83e7     
c_0greater      993c     
c_0less         8402     
c_1             85fb     
c_1minus        88fc     
c_1plus         88e3     
c_2             8603     
c_2drop         8494     
c_2dup          84bd     
c_2fetch        851f     
c_2minus        8908     
c_2over         9892     
c_2plus         88ef     
c_2store        8555     
c_2swap         987e     
c_3             860b     
c_abort         915c     
c_abs           9224     
c_again         95f7     
c_allot         8927     
c_and           8306     
c_back          954c     
c_base          8724     
c_bbuf          864e     
c_begin         955e     
c_bl            8614     
c_blanks        8dcb     
c_blk           86c6     
c_block         941e     
c_bounds        84cf     
c_branch        80b0     
c_bscr          865e     
c_buffer        9410     
c_cabort        8f24     
c_call          8899     
c_ccode         8bab     
c_ccomma        8944     
c_ccompile      8fcf     
c_cfa           8a55     
c_cfetch        8511     
c_cl            861e     
c_clear         9a74     
c_cline         932e     
c_cls           825c     
c_cmove         826e     
c_code          9989     
c_cold          91cb     
c_colon         8568     
c_comma         8933     
c_compile       8b34     
c_constant      85ab     
c_context       86ff     
c_convert       8e57     
c_count         8c0f     
c_cpu           986b     
c_cquote        8c83     
c_cr            824c     
c_create        8bd8     
c_csp           8742     
c_cspstore      8a8e     
c_cstore        8548     
c_current       870d     
c_dabs          9233     
c_ddot          9743     
c_ddotr         970f     
c_decimal       8b95     
c_definitions   910c     
c_depth         9904     
c_di            99f3     
c_digit         8152     
c_div           92cc     
c_divmod        92bc     
c_dlessthan     991b     
c_dliteral      9008     
c_dnegate       845a     
c_do            9596     
c_does          8be8     
c_dot           9751     
c_dotline       9350     
c_dotr          9732     
c_dots          9949     
c_dp            86ad     
c_dpl           872e     
c_dplus         8420     
c_dplusminus    9212     
c_drop          8486     
c_dump          9463     
c_dup           84af     
c_ebuffers      93f9     
c_ei            99fe     
c_else          963e     
c_emit          8215     
c_enclose       81ca     
c_end           95e9     
c_endcode       999e     
c_endif         9570     
c_equals        8969     
c_erase         8dba     
c_error         8f32     
c_execute       80a1     
c_exit          98a9     
c_expect        8ccb     
c_fence         86a4     
c_fetch         8502     
c_fill          8d9c     
c_find          8180     
c_first         862e     
c_fld           8738     
c_flush         9458     
c_forget        950f     
c_forth         90f4     
c_greater       89b7     
c_here          8917     
c_hex           8b7f     
c_hld           8755     
c_hold          8dda     
c_i             813e     
c_id            8f67     
c_if            9627     
c_iloop         80e2     
c_im0           99e7     
c_im1           99da     
c_im2           99cd     
c_immediate     90a1     
c_index         97fe     
c_int           982f     
c_interpret     9053     
c_intflag       9852     
c_intvect       9860     
c_j             98af     
c_key           822b     
c_latest        8a35     
c_ldo           8122     
c_leave         83a1     
c_leftbrkt      8b4a     
c_lessharp      968e     
c_lessthan      8975     
c_lfa           8a45     
c_limit         863e     
c_link          90e2     
c_list          97a9     
c_lit           808c     
c_literal       8feb     
c_lload         9a17     
c_lloop         80dd     
c_load          94a4     
c_loop          95a9     
c_max           9257     
c_mdiv          9287     
c_mdivmod       930f     
c_message       9364     
c_mfind         8efa     
c_min           9241     
c_minus         8954     
c_mod           92dc     
c_mon           9a0a     
c_mover         83b5     
c_mtimes        926c     
c_negate        8443     
c_next          99b7     
c_nextscreen    94d6     
c_nfa           8a63     
c_not           83fb     
c_null          8d5d     
c_number        8ea2     
c_offset        86f1     
c_openbrkt      911c     
c_or            8318     
c_out           86da     
c_over          8477     
c_pad           8df2     
c_pfa           8a79     
c_pick          89d4     
c_ploop         8116     
c_plus          8413     
c_plusbuf       93dc     
c_plusloop      95bf     
c_plusminus     9200     
c_plusstore     84dd     
c_portin        939c     
c_portout       93b1     
c_prev          93d1     
c_qcomp         8abb     
c_qerror        8aa1     
c_qexec         8ad3     
c_qloading      8b1a     
c_qpairs        8aea     
c_qstack        9023     
c_query         8d45     
c_querydup      89f9     
c_question      975d     
c_quit          912f     
c_quote         8c9c     
c_r0            8674     
c_ra            884f     
c_raf           87e8     
c_raf2          8825     
c_rb            8861     
c_rbc           87f2     
c_rbc2          8830     
c_rc            886a     
c_rd            8873     
c_rde           87fc     
c_rde2          883b     
c_re            887c     
c_repeat        960e     
c_rf            8858     
c_rfetch        83e0     
c_rh            8885     
c_rhash         874b     
c_rhl           8806     
c_rhl2          8846     
c_rightbrkt     8b58     
c_rix           8810     
c_riy           881a     
c_rl            888e     
c_rmove         83cb     
c_roll          98c2     
c_rot           89c5     
c_rpfetch       8364     
c_rpstore       8372     
c_rw            943c     
c_s0            866b     
c_sccode        8bc1     
c_scr           86e4     
c_semicolon     8590     
c_sharp         96cc     
c_sharpgt       969d     
c_sharps        96f7     
c_sign          96b6     
c_singtodub     91ec     
c_smudge        8b6d     
c_space         89ea     
c_spaces        9671     
c_spfetch       833e     
c_spstore       834d     
c_state         8719     
c_stop          838a     
c_store         8539     
c_swap          84a2     
c_task          9a68     
c_terminal      823d     
c_then          958b     
c_tib           867e     
c_tick          94f6     
c_times         92ad     
c_timesdiv      92fd     
c_timesdivmod   92ec     
c_toggle        84f4     
c_toin          86d0     
c_trailing      8c50     
c_traverse      8a10     
c_type          8c22     
c_uabort        87de     
c_ubbuf         8787     
c_ubscr         8794     
c_ucl           8760     
c_ucr           87c6     
c_udot          976a     
c_uemit         87bc     
c_ufirst        876d     
c_ukey          87b0     
c_uless         8997     
c_ulimit        877a     
c_umod          82b9     
c_until         95d5     
c_update        93e7     
c_urw           87d1     
c_use           93c6     
c_user          85dd     
c_ustar         8284     
c_uterminal     87a5     
c_variable      85c9     
c_vlist         977a     
c_voc_link      86bc     
c_vocabulary    90ba     
c_warm          918e     
c_warning       8698     
c_whatstack     8afd     
c_while         9660     
c_width         868a     
c_word          8e05     
c_xor           832b     
c_xxx1          8f77     
c_zero          85f3     
cf_uabort       9166     
cf_ucr          9a9d     
cf_uemit        9a8f     
cf_ukey         9a84     
cf_uqterminal   9ab0     
cf_urw          9446     
chr_rd          9abf     
chr_wr          9af3     
compare         8183     
context         fe20     
crflag          fe3e     
csp             fe2c     
ctc2           =  66     
current         fe22     
data_stack     =fd80     
decr_loop       80fb     
def_sysaddr     8022     
disk_end       =f000     
disk_start     =a000     
do_line         97ce     
dp              fe12     
dpl             fe28     
e_colon         857c     
e_forth         90fc     
elast           fe38     
end_chr         81b0     
fence           fe10     
firstword       91c0     
flast           fe32     
fld             fe2a     
half_times      82a2     
hld             fe30     
intflag         fe4c     
intvect         fe4e     
is_pos          91f8     
j21e6           81d4     
j2202           81f0     
j2218           8206     
j22db           82d4     
j22dd           82d6     
j22e5           82de     
j22f2           82eb     
j22fc           82f5     
j2301           82fa     
j298c           8981     
j2997           898c     
jpcode          fe7d     
jpvect          fe7e     
keybuf          fe66     
less10          8168     
ll_begin        9a1f     
ll_char         9a4d     
ll_null         9a4b     
ll_store        9a41     
mass_store     =fea0     
match_no_end    818b     
minus16         895e     
monstart       =   0     
ndigit          8173     
next            8066     
next_bit        82a7     
next_byte       8da4     
nextaddr        8081     
nexts1          8065     
nexts2          8064     
no_brk          97ea     
no_buf_key      9ad0     
no_bytes        827b     
no_count        8dae     
no_key          9aee     
no_match        81a8     
no_mul          82ae     
no_name         9077     
no_store        9a45     
no_zero         83f2     
noint           807b     
not_end_chr     81aa     
not_lt0         840c     
not_word_byte   8199     
offset          fe1e     
out_            fe1a     
pat             fe40     
prev            fe4a     
pst             fe43     
r0              fe08     
raf             fe68     
raf2            fe74     
rbc             fe6a     
rbc2            fe76     
rde             fe6c     
rde2            fe78     
restab          8018     
rhash           fe2e     
rhl             fe6e     
rhl2            fe7a     
rix             fe70     
riy             fe72     
rpp             fe46     
s0              fe06     
s_end1          9181     
s_end2          9393     
s_end3          97c4     
s_end4          9874     
s_end5          9980     
s_end7          8f4b     
s_end8          9150     
s_start1        9173     
s_start2        938d     
s_start3        97be     
s_start4        9870     
s_start5        9974     
s_start7        8f49     
s_start8        914e     
scr             fe1c     
start_table     8030     
state           fe24     
system          fe00     
tabend          801e     
test_limit      8100     
tib             fe0a     
toin            fe18     
uabort          fe5a     
ubbuf           fe62     
ubscr           fe64     
ucl             fe5c     
ucr             fe58     
uemit           fe54     
ufirst          fe5e     
ukey            fe52     
ulimit          fe60     
urtcnt         =  61     
urtda          =  60     
urw             fe56     
use             fe48     
uterminal       fe50     
voc_link        fe14     
vocab_base     =f000     
w_0branch       80be     
w_0equals       83e2     
w_0greater      9937     
w_0less         83fd     
w_1             85f7     
w_1minus        88f7     
w_1plus         88de     
w_2             85ff     
w_2drop         848c     
w_2dup          84b6     
w_2fetch        851a     
w_2minus        8903     
w_2over         988a     
w_2plus         88ea     
w_2store        8550     
w_2swap         9876     
w_3             8607     
w_abort         9154     
w_abs           921e     
w_again         95ef     
w_allot         891f     
w_and           8300     
w_back          9545     
w_base          871d     
w_bbuf          8646     
w_begin         9556     
w_bl            860f     
w_blanks        8dc2     
w_blk           86c0     
w_block         9416     
w_bounds        84c6     
w_branch        80a7     
w_bscr          8656     
w_buffer        9407     
w_cabort        8f1a     
w_call          8892     
w_ccode         8ba1     
w_ccomma        893f     
w_ccompile      8fc3     
w_cfa           8a4f     
w_cfetch        850c     
w_cl            8618     
w_clear         9a6c     
w_cline         9325     
w_cls           8256     
w_cmove         8266     
w_code          9982     
w_cold          91c2     
w_colon         8564     
w_comma         892f     
w_compile       8b2a     
w_constant      85a0     
w_context       86f5     
w_convert       8e4d     
w_count         8c07     
w_cpu           9864     
w_cquote        8c7c     
w_cr            8247     
w_create        8bcf     
w_csp           873c     
w_cspstore      8a87     
w_cstore        8543     
w_current       8703     
w_dabs          922c     
w_ddot          973e     
w_ddotr         9709     
w_decimal       8b8b     
w_definitions   90fe     
w_depth         98fc     
w_di            99ee     
w_digit         814a     
w_div           92c8     
w_divmod        92b5     
w_dlessthan     9916     
w_dliteral      8ffd     
w_dnegate       8450     
w_do            9591     
w_does          8be0     
w_dot           974d     
w_dotline       9348     
w_dotr          972d     
w_dots          9944     
w_dp            86a8     
w_dpl           8728     
w_dplus         841b     
w_dplusminus    920c     
w_drop          847f     
w_dump          945c     
w_dup           84a9     
w_ebuffers      93e9     
w_editi         9a6c     
w_ei            99f9     
w_else          9637     
w_emit          820e     
w_enclose       81c0     
w_end           95e3     
w_endcode       9993     
w_endif         9568     
w_equals        8965     
w_erase         8db2     
w_error         8f2a     
w_execute       8097     
w_exit          98a2     
w_expect        8cc2     
w_fence         869c     
w_fetch         84fe     
w_fill          8d95     
w_find          8177     
w_first         8626     
w_fld           8732     
w_flush         9450     
w_forget        9506     
w_forth         90ec     
w_greater       89b3     
w_here          8910     
w_hex           8b79     
w_hld           874f     
w_hold          8dd3     
w_i             813a     
w_id            8f61     
w_if            9622     
w_im0           99e1     
w_im1           99d4     
w_im2           99c7     
w_immediate     9095     
w_index         97f6     
w_int           9828     
w_interpret     9047     
w_intflag       9848     
w_intvect       9856     
w_j             98ab     
w_key           8225     
w_latest        8a2c     
w_ldo           811b     
w_leave         8399     
w_leftbrkt      8b46     
w_lessharp      9689     
w_lessthan      8971     
w_lfa           8a3f     
w_limit         8636     
w_list          97a2     
w_lit           8086     
w_literal       8fe1     
w_lload         9a0f     
w_lloop         80d4     
w_load          949d     
w_loop          95a2     
w_max           9251     
w_mdiv          9282     
w_mdivmod       9307     
w_message       935a     
w_mfind         8ef2     
w_min           923b     
w_minus         8950     
w_mod           92d6     
w_mon           9a04     
w_mover         83b0     
w_mtimes        9267     
w_negate        843a     
w_next          99b0     
w_nextscreen    94d0     
w_nfa           8a5d     
w_not           83f5     
w_null          8d59     
w_number        8e99     
w_offset        86e8     
w_openbrkt      9118     
w_or            8313     
w_out           86d4     
w_over          8470     
w_pad           8dec     
w_pfa           8a73     
w_pick          89cd     
w_ploop         810c     
w_plus          840f     
w_plusbuf       93d5     
w_plusloop      95b7     
w_plusminus     91fb     
w_plusstore     84d8     
w_portin        9397     
w_portout       93ac     
w_prev          93ca     
w_qcomp         8ab3     
w_qerror        8a98     
w_qexec         8acb     
w_qloading      8b0f     
w_qpairs        8ae1     
w_qstack        901a     
w_query         8d3d     
w_querydup      89f2     
w_question      9759     
w_quit          9128     
w_quote         8c97     
w_r0            866f     
w_ra            884a     
w_raf           87e2     
w_raf2          881e     
w_rb            885c     
w_rbc           87ec     
w_rbc2          8829     
w_rc            8865     
w_rd            886e     
w_rde           87f6     
w_rde2          8834     
w_re            8877     
w_repeat        9605     
w_rf            8853     
w_rfetch        83db     
w_rh            8880     
w_rhash         8746     
w_rhl           8800     
w_rhl2          883f     
w_rightbrkt     8b54     
w_rix           880a     
w_riy           8814     
w_rl            8889     
w_rmove         83c6     
w_roll          98bb     
w_rot           89bf     
w_rpfetch       835e     
w_rpstore       836c     
w_rw            9436     
w_s0            8666     
w_sccode        8bb9     
w_scr           86de     
w_semicolon     858c     
w_sharp         96c8     
w_sharpgt       9698     
w_sharps        96f2     
w_sign          96af     
w_singtodub     91e5     
w_smudge        8b64     
w_space         89e2     
w_spaces        9668     
w_spfetch       8338     
w_spstore       8347     
w_state         8711     
w_stop          8385     
w_store         8535     
w_swap          849b     
w_task          9a61     
w_taskend       9a6c     
w_terminal      8231     
w_then          9584     
w_tib           8678     
w_tick          94f2     
w_times         92a9     
w_timesdiv      92f8     
w_timesdivmod   92e4     
w_toggle        84eb     
w_toin          86ca     
w_trailing      8c44     
w_traverse      8a05     
w_type          8c1b     
w_uabort        87d5     
w_ubbuf         877e     
w_ubscr         878b     
w_ucl           8759     
w_ucr           87c0     
w_udot          9765     
w_uemit         87b4     
w_ufirst        8764     
w_ukey          87a9     
w_uless         8992     
w_ulimit        8771     
w_umod          82b1     
w_until         95cd     
w_update        93de     
w_urw           87ca     
w_use           93c0     
w_user          85d6     
w_ustar         827f     
w_uterminal     8798     
w_variable      85be     
w_vlist         9772     
w_voc_link      86b1     
w_vocabulary    90ad     
w_warm          9187     
w_warning       868e     
w_whatstack     8af6     
w_while         9658     
w_width         8682     
w_word          8dfe     
w_xor           8325     
w_zero          85ef     
wait1           9af6     
warning         fe0e     
was_brk         9af0     
width           fe0c     
word1           8020     
x_0equals       83e9     
x_branch        80b2     
x_cold          91a0     
x_constant      85b5     
x_does          8bf4     
x_i             8140     
x_i2            8143     
x_int           983d     
x_stop          838c     
x_user          85e3     
x_variable      85d1     
