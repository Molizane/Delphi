AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page    1
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

4349 lines read, no errors in pass 1.
                        ; This is an implementation of FORTH for the Z80 that
                        ; should be easily portable to other Z80 systems.
                        ; It assumes RAM from $9000 to $FFFF and a UART for
                        ; communication with the host or VDU.
                        
fd80 =                  DATA_STACK	EQU	$FD80		;Data stack grows down
f000 =                  VOCAB_BASE	EQU	$F000		;Dictionary grows up from here
fea0 =                  MASS_STORE	EQU	$FEA0		;Mass storage buffer (default)
a000 =                  DISK_START	EQU	$A000		;Pseudo disk buffer start
f000 =                  DISK_END	EQU	$F000		;Pseudo disk buffer end
0200 =                  BLOCK_SIZE	EQU	$0200		;Pseudo disk block size
0001 =                  BUFFERS		EQU	$0001		;Pseudo disk buffers per block
                        
0000 =                  MONSTART	EQU	$0000		;Monitor entry address
                        
fe00 =                  	ORG	$FE00		;Set up system variable addresses
                        
fe00 :                  SYSTEM					;Start of scratch pad area
fe00 : 000000000000     			DS	6		;User bytes
fe06 : 0000             S0			DW	0		;Initial value of the data stack pointer
fe08 : 0000             R0			DW	0		;Initial value of the return stack pointer
fe0a : 0000             TIB			DW	0		;Address of the terminal input buffer
fe0c : 0000             WIDTH		DW	0		;Number of letters saved in names
fe0e : 0000             WARNING		DW	0		;Error message control number
fe10 : 0000             FENCE		DW	0		;Dictionary FORGET protection point
fe12 : 0000             DP			DW	0		;The dictionary pointer
fe14 : 0000             VOC_LINK	DW	0		;Most recently created vocabulary
fe16 : 0000             BLK			DW	0		;Current block number under interpretation
fe18 : 0000             TOIN		DW	0		;Offset in the current input text buffer
fe1a : 0000             OUT_		DW	0		;Offset in the current output text buffer
fe1c : 0000             SCR			DW	0		;Screen number last referenced by LIST
fe1e : 0000             OFFSET		DW	0		;Block offset for disk drives
fe20 : 0000             CONTEXT		DW	0		;Pointer to the vocabulary within which
                        						;dictionary search will first begin
fe22 : 0000             CURRENT		DW	0		;Pointer to the vocabulary within which
                        						;new definitions are to be created
fe24 : 0000             STATE		DW	0		;Contains state of compillation
fe26 : 0000             BASE		DW	0		;Current I/O base address
fe28 : 0000             DPL			DW	0		;Number of digits to the right of the
                        						;decimal point on double integer input
fe2a : 0000             FLD			DW	0		;Field width for formatted number output
fe2c : 0000             CSP			DW	0		;Check stack pointer
fe2e : 0000             RHASH		DW	0		;Location of editor cursor in a text bloxk
fe30 : 0000             HLD			DW	0		;Address of current output
fe32 : 000000000000     FLAST		DS	6		;FORTH vocabulary data initialised to FORTH
                        						;vocabulary
fe38 : 000000000000     ELAST		DS	6		;Editor vocabulary data initialised to
                        						;EDITOR vocabulary
fe3e : 00               CRFLAG		DB	0		;Carriage return flag
fe3f : 00               			DB	0		;User byte
fe40 : 000000           PAT			DS	3		;I/O port fetch routine (input)
fe43 : 000000           PST			DS	3		;I/O port store routine (output)
fe46 : 0000             RPP			DW	0		;Return stack pointer
fe48 : 0000             USE			DW	0		;Mass storage buffer address to use
fe4a : 0000             PREV		DW	0		;Mass storage buffer address just used
fe4c : 00               INTFLAG		DB	0		;Interrupt flag
fe4d : 00               			DB	0		;User byte
fe4e : 0000             INTVECT		DW	0		;Interrupt vector
fe50 : 0000             UTERMINAL	DW	0		;Code field address of word ?TERMINAL
fe52 : 0000             UKEY		DW	0		;Code field address of word KEY
fe54 : 0000             UEMIT		DW	0		;Code field address of word EMIT
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page    2
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

fe56 : 0000             URW			DW	0		;Code field address of word R/W
fe58 : 0000             UCR			DW	0		;Code field address of word CR
fe5a : 0000             UABORT		DW	0		;Code field address of word ABORT
fe5c : 0000             UCL			DW	0		;Number of characters per input line
fe5e : 0000             UFIRST		DW	0		;Start of pseudo disk buffer
fe60 : 0000             ULIMIT		DW	0		;End of pseudo disk buffer
fe62 : 0000             UBBUF		DW	0		;Number of bytes per block
fe64 : 0000             UBSCR		DW	0		;Number of buffers per block
fe66 : 0000             KEYBUF		DW	0		;Double key buffer
fe68 : 0000             RAF			DW	0		;Register AF
fe6a : 0000             RBC			DW	0		;Register BC
fe6c : 0000             RDE			DW	0		;Register DE
fe6e : 0000             RHL			DW	0		;Register HL
fe70 : 0000             RIX			DW	0		;Register IX
fe72 : 0000             RIY			DW	0		;Register IY
fe74 : 0000             RAF2		DW	0		;Register AF'
fe76 : 0000             RBC2		DW	0		;Register BC'
fe78 : 0000             RDE2		DW	0		;Register DE'
fe7a : 0000             RHL2		DW	0		;Register HL'
fe7c : 00               			DB	0		;User byte
fe7d : 00               JPCODE		DB	0		;JMP code (C3) for word CALL
fe7e : 0000             JPVECT		DW	0		;JMP vector for word CALL
fe80 : 00000000000000.. 			DS	32		;User bytes
                        
                        ;	IO/M Addresses
                        
                        ; This assumes that the uPF IO/M card is fitted.
                        
0060 =                  URTDA		EQU	$60		;8251 UART Data Port
0061 =                  URTCNT		EQU	$61		;8251 UART Control Port
                        
0066 =                  CTC2		EQU	$66		;CTC Channel 2, Baud rate gen for UART
                        
8000 =                  	ORG	$8000			;Start of RAM
                        
                        ;	Setup 8251 9600 baud 8N1	*
                        
                        ; Change this bit to suit your systems port initialisation.
                        
8000 : 3e47             	LD	A,$47				;Counter mode, TC follows, Reset channel
8002 : d366             	OUT	(CTC2),A			;CTC2 is baud rate gen for 8251
8004 : 3e03             	LD	A,$03				;Time const for 9600 baud
8006 : d366             	OUT	(CTC2),A			;
8008 : 211880           	LD	HL,RESTAB			;Reset sequence for 8251
800b : 0606             	LD	B,TABEND-RESTAB		;Table length
800d : 0e61             	LD	C,URTCNT			;Point to control port
800f : edb3             	OTIR					;OUT and loop until done
                        
8011 : af               	XOR	A					;Clear A
8012 : 3266fe           	LD	(KEYBUF),A			;Clear buffered key
8015 : c3a091           	JP	X_COLD
                        
8018 :                  RESTAB
8018 : 000000404e37     	DB	$00,$00,$00,$40,$4E,$37
801e :                  TABEND
                        
801e :                  BACKSPACE
801e : 0800             	DW	$0008			;Backspace chr
                        
8020 :                  WORD1
8020 : 80fd             	DW	DATA_STACK
8022 :                  DEF_SYSADDR
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page    3
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8022 : 00fe             	DW	SYSTEM
8024 : 80fd             	DW	DATA_STACK
8026 : 1f00             	DW	$001F			;Word name length (default 31)
8028 : 0000             	DW	$0000			;Error message control number
802a : 00f0             	DW	VOCAB_BASE		;FORGET protection
802c : 0bf0             	DW	VOCAB_BASE+$0B		;Dictionary pointer
802e : fc90             	DW	E_FORTH			;Most recently created vocab.
                        
8030 :                  START_TABLE
8030 : 81a0             	DB	$81,$A0
8032 : 00f0             	DW	VOCAB_BASE
8034 : 0000             	DB	$00,$00			;FLAST
8036 : 81a0             	DB	$81,$A0
8038 : 6c9a             	DW	W_EDITI
803a : fc90             	DW	E_FORTH			;ELAST
803c : 00               	DB	$00			;CRFLAG
803d : 00               	DB	$00			;Free
803e : db00             	IN	A,($00)			;I/O Port input
8040 : c9               	RET				;routine
8041 : d300             	OUT	($00),A			;I/O Port output
8043 : c9               	RET				;routine
8044 : 00fe             	DW	SYSTEM 			;Return stack pointer
8046 : a0fe             	DW	MASS_STORE		;Mass storage buffer to use
8048 : a0fe             	DW	MASS_STORE		;Storage buffer just used
804a : 00               	DB	$00			;Interrupt flag
804b : 00               	DB	$00			;Free
804c : 5c91             	DW	C_ABORT			;Interrupt vector
804e : b09a             	DW	CF_UQTERMINAL		;C field address ?TERMINAL
8050 : 849a             	DW	CF_UKEY			;C field address KEY
8052 : 8f9a             	DW	CF_UEMIT		;C field address EMIT
8054 : 9d9a             	DW	CF_UCR			;C field address CR
8056 : 4694             	DW	CF_URW			;C field address R/W
8058 : 6691             	DW	CF_UABORT		;C field address ABORT
805a : 2000             	DW	$0020			;CHRs per input line
805c : 00a0             	DW	DISK_START		;Pseudo disk buf start
805e : 00f0             	DW	DISK_END		;Pseudo disk buf end
8060 : 0002             	DW	BLOCK_SIZE		;Bytes per block
8062 : 0100             	DW	BUFFERS			;Buffers per block
                        
8064 :                  NEXTS2
8064 : d5               	PUSH	DE
8065 :                  NEXTS1
8065 : e5               	PUSH	HL
8066 :                  NEXT
8066 : 3a4cfe           	LD	A,(INTFLAG)		;Interrupt flag
8069 : cb7f             	BIT	7,A				;Check for interrupt
806b : 280e             	JR	Z,NOINT			;No interrupt
806d : cb77             	BIT	6,A				;Interrupt enabled ?
806f : 200a             	JR	NZ,NOINT		;No interrupt
8071 : 2a4efe           	LD	HL,(INTVECT)	;Get interrupt vector
8074 : 3e40             	LD	A,$40			;Clear flag byte
8076 : 324cfe           	LD	(INTFLAG),A		;Interrupt flag into HL
8079 : 1806             	JR	NEXTADDR		;JP (HL)
807b :                  NOINT
807b : 0a               	LD	A,(BC)			;effectively LD HL,(BC)
807c : 03               	INC	BC				;
807d : 6f               	LD	L,A				;
807e : 0a               	LD	A,(BC)			;
807f : 03               	INC	BC				;BC now points to next vector
8080 : 67               	LD	H,A				;HL has addr vector
8081 :                  NEXTADDR
8081 : 5e               	LD	E,(HL)			;effectively LD HL,(HL)
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page    4
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8082 : 23               	INC	HL				;
8083 : 56               	LD	D,(HL) 			;
8084 : eb               	EX	DE,HL 			;
8085 : e9               	JP	(HL) 			;Jump to it
                        
8086 :                  W_LIT					;Puts next 2 bytes on the stack
8086 : 834c49d4         	DB	$83,'LI','T'+$80
808a : 0000             	DW	$0000			;First word in vocabulary
808c :                  C_LIT
808c : 8e80             	DW	2+$				;Vector to code
808e : 0a               	LD	A,(BC)			;Gets next word from (BC)
808f : 03               	INC	BC				;then increments BC to point
8090 : 6f               	LD	L,A				;to the next addr. Pushes the
8091 : 0a               	LD	A,(BC)			;result onto the stack.
8092 : 03               	INC	BC				;
8093 : 67               	LD	H,A				;
8094 : c36580           	JP	NEXTS1			;Save & NEXT
                        
                        
8097 :                  W_EXECUTE	;Jump to address on stack
8097 : 87455845435554c5 	DB	$87,'EXECUT','E'+$80
809f : 8680             	DW	W_LIT
80a1 :                  C_EXECUTE
80a1 : a380             	DW	2+$			;Vector to code
80a3 : e1               	POP	HL			;Get addr off data stack
80a4 : c38180           	JP	NEXTADDR		;Basically JP (HL)
                        
                        
80a7 :                  W_BRANCH	;Add following offset to BC
80a7 : 864252414e43c8   	DB	$86,'BRANC','H'+$80
80ae : 9780             	DW	W_EXECUTE
80b0 :                  C_BRANCH
80b0 : b280             	DW	2+$			;Vector to code
80b2 :                  X_BRANCH
80b2 : 60               	LD	H,B			;Next pointer into HL
80b3 : 69               	LD	L,C			;
80b4 : 5e               	LD	E,(HL)			;Get word offset LD DE,(HL)
80b5 : 23               	INC	HL			;Incr to point at next byte
80b6 : 56               	LD	D,(HL)			;
80b7 : 2b               	DEC	HL 			;Restore HL
80b8 : 19               	ADD	HL,DE			;Calculate new address
80b9 : 4d               	LD	C,L			;Put it in BC
80ba : 44               	LD	B,H			;
80bb : c36680           	JP	NEXT			;Go do it
                        
                        
80be :                  W_0BRANCH	;Add offset to BC if stack top = 0
80be : 87304252414e43c8 	DB	$87,'0BRANC','H'+$80	;Conditional branch
80c6 : a780             	DW	W_BRANCH
80c8 :                  C_0BRANCH
80c8 : ca80             	DW	2+$			;Vector to code
80ca : e1               	POP	HL			;Get value off stack
80cb : 7d               	LD	A,L			;Set flags
80cc : b4               	OR	H			;
80cd : 28e3             	JR	Z,X_BRANCH		;If zero then do the branch
80cf : 03               	INC	BC			;Else dump branch address
80d0 : 03               	INC	BC			;
80d1 : c36680           	JP	NEXT			;Continue execution
                        
80d4 :                  W_LLOOP		;Increment loop & branch if not done
80d4 : 863c4c4f4f50be   	DB	$86,'<LOOP','>'+$80
80db : be80             	DW	W_0BRANCH
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page    5
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

80dd :                  C_LLOOP
80dd : df80             	DW	2+$			;Vector to code
80df : 110100           	LD	DE,0001
80e2 :                  C_ILOOP
80e2 : 2a46fe           	LD	HL,(RPP)		;Get return stack pointer
80e5 : 7e               	LD	A,(HL)			;Add DE to value on return stack
80e6 : 83               	ADD	A,E			;
80e7 : 77               	LD	(HL),A			;
80e8 : 5f               	LD	E,A			;
80e9 : 23               	INC	HL			;
80ea : 7e               	LD	A,(HL)			;
80eb : 8a               	ADC	A,D			;
80ec : 77               	LD	(HL),A			;
80ed : 23               	INC	HL			;HL now points to limit value
80ee : 14               	INC	D			;Get Ds sign bit
80ef : 15               	DEC	D			;
80f0 : 57               	LD	D,A			;Result now in DE
80f1 : fafb80           	JP	M,DECR_LOOP		;Decrement loop so check > limit
                        					;otherwies check < limit
80f4 : 7b               	LD	A,E			;Low byte back
80f5 : 96               	SUB	(HL)			;Subtract limit low
80f6 : 7a               	LD	A,D			;High byte back
80f7 : 23               	INC	HL			;Point to limit high
80f8 : 9e               	SBC	A,(HL)			;Subtract it
80f9 : 1805             	JR	TEST_LIMIT		;
80fb :                  DECR_LOOP
80fb : 7e               	LD	A,(HL)			;Get limit low
80fc : 93               	SUB	E			;Subtract index low
80fd : 23               	INC	HL			;Point to limit high
80fe : 7e               	LD	A,(HL)			;Get it
80ff : 9a               	SBC	A,D			;Subtract index high
8100 :                  TEST_LIMIT
8100 : fab280           	JP	M,X_BRANCH		;Not reached limit so jump
8103 : 23               	INC	HL			;Drop index & limit from return stack
8104 : 2246fe           	LD	(RPP),HL		;Save stack pointer
8107 : 03               	INC	BC			;Skip branch offset
8108 : 03               	INC	BC			;
8109 : c36680           	JP	NEXT
                        
810c :                  W_PLOOP		;Loop + stack & branch if not done
810c : 873c2b4c4f4f50be 	DB	$87,'<+LOOP','>'+$80
8114 : d480             	DW	W_LLOOP
8116 :                  C_PLOOP
8116 : 1881             	DW	2+$			;Vector to code
8118 : d1               	POP	DE			;Get value from stack
8119 : 18c7             	JR	C_ILOOP			;Go do loop increment
                        
811b :                  W_LDO		;Put start & end loop values on RPP
811b : 843c444fbe       	DB	$84,'<DO','>'+$80
8120 : 0c81             	DW	 W_PLOOP
8122 :                  C_LDO
8122 : 2481             	DW	 2+$
8124 : 2a46fe           	LD	HL,(RPP)		;Get return stack pointer
8127 : 2b               	DEC	HL			;Add space for two values
8128 : 2b               	DEC	HL			;
8129 : 2b               	DEC	HL			;
812a : 2b               	DEC	HL			;
812b : 2246fe           	LD	(RPP),HL		;Save new stack pointer
812e : d1               	POP	DE			;Get start value &
812f : 73               	LD	(HL),E			;put on return stack top
8130 : 23               	INC	HL			;
8131 : 72               	LD	(HL),D			;
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page    6
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8132 : 23               	INC	HL			;
8133 : d1               	POP	DE			;Get end value &
8134 : 73               	LD	(HL),E			;put on return stack - 1
8135 : 23               	INC	HL			;
8136 : 72               	LD	(HL),D			;
8137 : c36680           	JP	NEXT
                        
813a :                  W_I		;Copy LOOP index to data stack
813a : 81c9             	DB	$81,'I'+$80
813c : 1b81             	DW	 W_LDO
813e :                  C_I
813e : 4081             	DW	 2+$
8140 :                  X_I
8140 : 2a46fe           	LD	HL,(RPP)		;Get return stack pointer
8143 :                  X_I2
8143 : 5e               	LD	E,(HL)			;Get LOOP index off return stack
8144 : 23               	INC	HL			;
8145 : 56               	LD	D,(HL)			;
8146 : d5               	PUSH	DE			;Push onto data stack
8147 : c36680           	JP	NEXT
                        
814a :                  W_DIGIT		;Convert digit n2 using base n1
814a : 8544494749d4     	DB	$85,'DIGI','T'+$80
8150 : 3a81             	DW	 W_I
8152 :                  C_DIGIT
8152 : 5481             	DW	2+$
8154 : e1               	POP	HL			;Get base to use
8155 : d1               	POP	DE			;Get char
8156 : 7b               	LD	A,E			;A = char
8157 : d630             	SUB	$30			;Subtract 30h
8159 : fa7381           	JP	M,NDIGIT		;
815c : fe0a             	CP	$0A			;Greater than 9 ?
815e : fa6881           	JP	M,LESS10		;If not then skip
8161 : d607             	SUB	$07			;Convert 'A' to 10
8163 : fe0a             	CP	$0A			;Is it 10?
8165 : fa7381           	JP	M,NDIGIT		;If not an error occured
8168 :                  LESS10
8168 : bd               	CP	L			;L is 1 digit limit
8169 : f27381           	JP	P,NDIGIT		;Out of range for digit
816c : 5f               	LD	E,A			;Result into DE
816d : 210100           	LD	HL,0001			;Leave TRUE flag
8170 : c36480           	JP	NEXTS2			;Save both & NEXT
8173 :                  NDIGIT
8173 : 6c               	LD	L,H			;Leave FALSE flag
8174 : c36580           	JP	NEXTS1			;Save & NEXT
                        
8177 :                  W_FIND		;Find word & return vector,byte & flag
8177 : 863c46494e44be   	DB	$86,'<FIND','>'+$80
817e : 4a81             	DW	W_DIGIT
8180 :                  C_FIND
8180 : 8281             	DW	2+$			;Vector to code
8182 : d1               	POP	DE			;Get pointer to next vocabulary word
8183 :                  COMPARE
8183 : e1               	POP	HL			;Copy pointer to word we're looking 4
8184 : e5               	PUSH	HL			;
8185 : 1a               	LD	A,(DE)			;Get 1st vocabulary word letter
8186 : ae               	XOR	(HL)			;Compare with what we've got
8187 : e63f             	AND	$3F			;Ignore start flag
8189 : 201f             	JR	NZ,NOT_END_CHR		;No match so skip to next word
818b :                  MATCH_NO_END
818b : 23               	INC	HL			;Compare next chr
818c : 13               	INC	DE			;
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page    7
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

818d : 1a               	LD	A,(DE)			;
818e : ae               	XOR	(HL)			;
818f : 87               	ADD	A,A			;Move bit 7 to C flag
8190 : 2016             	JR	NZ,NO_MATCH		;No match jump
8192 : 30f7             	JR	NC,MATCH_NO_END		;Match & not last, so next chr
8194 : 210500           	LD	HL,0005			;Offset to start of code
8197 : 19               	ADD	HL,DE			;HL now points to code start for word
8198 : e3               	EX	(SP),HL			;Swap with value on stack
8199 :                  NOT_WORD_BYTE
8199 : 1b               	DEC	DE			;Search back for word type byte
819a : 1a               	LD	A,(DE)			;
819b : b7               	OR	A			;
819c : f29981           	JP	P,NOT_WORD_BYTE		;Not yet so loop
819f : 5f               	LD	E,A			;Byte into DE
81a0 : 1600             	LD	D,$00			;
81a2 : 210100           	LD	HL,0001			;Leave TRUE flag
81a5 : c36480           	JP	NEXTS2			;Save both & NEXT
81a8 :                  NO_MATCH
81a8 : 3806             	JR	C,END_CHR		;If last chr then jump
81aa :                  NOT_END_CHR
81aa : 13               	INC	DE			;Next chr of this vocab word
81ab : 1a               	LD	A,(DE)			;Get it
81ac : b7               	OR	A			;Set flags
81ad : f2aa81           	JP	P,NOT_END_CHR		;Loop if not end chr
81b0 :                  END_CHR
81b0 : 13               	INC	DE			;Now points to next word vector
81b1 : eb               	EX	DE,HL			;Swap
81b2 : 5e               	LD	E,(HL)			;Vector into DE
81b3 : 23               	INC	HL			;
81b4 : 56               	LD	D,(HL)			;
81b5 : 7a               	LD	A,D			;Check it's not last (first) word
81b6 : b3               	OR	E			;
81b7 : 20ca             	JR	NZ,COMPARE		;No error so loop
81b9 : e1               	POP	HL			;Dump pointer
81ba : 210000           	LD	HL,0000			;Flag error
81bd : c36580           	JP	NEXTS1			;Save & NEXT
                        
81c0 :                  W_ENCLOSE
81c0 : 87454e434c4f53c5 	DB	$87,'ENCLOS','E'+$80
81c8 : 7781             	DW	W_FIND
81ca :                  C_ENCLOSE
81ca : cc81             	DW	2+$			;Vector to code
81cc : d1               	POP	DE			; get delimiter character
81cd : e1               	POP	HL			; get address 1
81ce : e5               	PUSH	HL			; duplicate it
81cf : 7b               	LD	A,E			; delimiter char into A
81d0 : 57               	LD	D,A			; copy to D
81d1 : 1eff             	LD	E,$FF			; -1 for offset
81d3 : 2b               	DEC	HL			; to allow for first INCR
81d4 :                  J21E6
81d4 : 23               	INC	HL			; point to next chr
81d5 : 1c               	INC	E			; next offset
81d6 : be               	CP	(HL)			; compare chr with (address)
81d7 : 28fb             	JR	Z,J21E6			; loop if = delimiter chr
81d9 : 3e0d             	LD	A,$0D			; else set CR
81db : be               	CP	(HL)			; compare with (address)
81dc : 7a               	LD	A,D			; restore delimiter chr
81dd : 28f5             	JR	Z,J21E6			; loop if it was = CR
81df : 1600             	LD	D,$00			; zero high byte
81e1 : d5               	PUSH	DE			; save offset
81e2 : 57               	LD	D,A			; restore delimiter chr
81e3 : 7e               	LD	A,(HL)			; get byte from address
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page    8
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

81e4 : a7               	AND	A			; set the flags
81e5 : 2009             	JR	NZ,J2202		; branch if not null
81e7 : 1600             	LD	D,$00			; clear high byte
81e9 : 1c               	INC	E			; point to next addr
81ea : d5               	PUSH	DE			; save address
81eb : 1d               	DEC	E			; point to end
81ec : d5               	PUSH	DE			; push address
81ed : c36680           	JP	NEXT			; done
81f0 :                  J2202
81f0 : 7a               	LD	A,D			; restore delimiter chr
81f1 : 23               	INC	HL			; increment address
81f2 : 1c               	INC	E			; increment offset
81f3 : be               	CP	(HL)			; compare delimiter with (address)
81f4 : 2810             	JR	Z,J2218			; jump if =
81f6 : 3e0d             	LD	A,$0D			; else get CR
81f8 : be               	CP	(HL)			; compare with (address)
81f9 : 280b             	JR	Z,J2218			; jump if =
81fb : 7e               	LD	A,(HL)			; else get byte
81fc : a7               	AND	A			; set the flags
81fd : 20f1             	JR	NZ,J2202		; loop if not null
81ff : 1600             	LD	D,$00			; clear gigh byte
8201 : d5               	PUSH	DE			; save address
8202 : d5               	PUSH	DE			; save address
8203 : c36680           	JP	NEXT			; done
8206 :                  J2218
8206 : 1600             	LD	D,$00			; clear high byte
8208 : d5               	PUSH	DE			; save address
8209 : 1c               	INC	E			; increment offset
820a : d5               	PUSH	DE			; save address
820b : c36680           	JP	NEXT			; done
                        
820e :                  W_EMIT		;Output CHR from stack
820e : 84454d49d4       	DB	$84,'EMI','T'+$80
8213 : c081             	DW	W_ENCLOSE
8215 :                  C_EMIT
8215 : 7c85             	DW	E_COLON			;Interpret following word sequence
8217 : bc87             	DW	C_UEMIT			;Put UEMIT addr on stack
8219 : 0285             	DW	C_FETCH			;Get UEMIT code field address
821b : a180             	DW	C_EXECUTE		;Jump to address on stack
821d : fb85             	DW	C_1
821f : da86             	DW	C_OUT
8221 : dd84             	DW	C_PLUSSTORE
8223 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8225 :                  W_KEY		;Wait for key, value on stack
8225 : 834b45d9         	DB	$83,'KE','Y'+$80
8229 : 0e82             	DW	W_EMIT
822b :                  C_KEY
822b : 2d82             	DW	2+$			;Vector to code
822d : 2a52fe           	LD	HL,(UKEY)		;Get the vector
8230 : e9               	JP	(HL)			;Jump to it
                        
                        ;	DW	E_COLON			;Interpret following word sequence
                        ;	DW	C_UKEY			;Put UKEY addr on stack
                        ;	DW	C_FETCH			;Get CF_KEY
                        ;	DW	C_EXECUTE		;Jump to CF_KEY
                        ;	DW	C_STOP			;Pop BC from return stack (=next)
                        
                        
8231 :                  W_TERMINAL
8231 : 893f5445524d49.. 	DB	$89,'?TERMINA','L'+$80
823b : 2582             	DW	W_KEY
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page    9
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

823d :                  C_TERMINAL
823d : 7c85             	DW	E_COLON			;Interpret following word sequence
823f : a587             	DW	C_UTERMINAL
8241 : 0285             	DW	C_FETCH			;Get word from addr on stack
8243 : a180             	DW	C_EXECUTE		;Jump to address on stack
8245 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8247 :                  W_CR		;Output [CR][LF]
8247 : 8243d2           	DB	$82,'C','R'+$80
824a : 3182             	DW	W_TERMINAL
824c :                  C_CR
824c : 7c85             	DW	E_COLON			;Interpret following word sequence
824e : c687             	DW	C_UCR			;Push UCR addr
8250 : 0285             	DW	C_FETCH			;Get UCR code field addr
8252 : a180             	DW	C_EXECUTE		;Jump to address on stack
8254 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8256 :                  W_CLS		;Clear screen
8256 : 83434cd3         	DB	$83,'CL','S'+$80
825a : 4782             	DW	W_CR
825c :                  C_CLS
825c : 7c85             	DW	E_COLON			;Interpret following word sequence
825e : 8c80             	DW	C_LIT			;Put clear screen code on stack
8260 : 0c00             	DW	$000C			;
8262 : 1582             	DW	C_EMIT			;Output it
8264 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8266 :                  W_CMOVE		;Move block
8266 : 85434d4f56c5     	DB	$85,'CMOV','E'+$80
826c : 5682             	DW	W_CLS
826e :                  C_CMOVE
826e : 7082             	DW	2+$			;Vector to code
8270 : 69               	LD	L,C			;Save BC for now
8271 : 60               	LD	H,B			;
8272 : c1               	POP	BC			;Get no. of bytes to move
8273 : d1               	POP	DE			;Get destination address
8274 : e3               	EX	(SP),HL			;Get source address
8275 : 78               	LD	A,B			;Check it's not a 0 length block
8276 : b1               	OR	C			;
8277 : 2802             	JR	Z,NO_BYTES		;If 0 length then do nothing
8279 : edb0             	LDIR				;Move block
827b :                  NO_BYTES
827b : c1               	POP	BC			;Get BC back
827c : c36680           	JP	NEXT
                        
827f :                  W_USTAR		;Unsigned multiply
827f : 8255aa           	DB	$82,'U','*'+$80
8282 : 6682             	DW	W_CMOVE
8284 :                  C_USTAR
8284 : 8682             	DW	2+$			;Vector to code
8286 : d1               	POP	DE			; get n2
8287 : e1               	POP	HL			; get n1
8288 : c5               	PUSH	BC			; save BC for now
8289 : 4c               	LD	C,H			; save H
828a : 7d               	LD	A,L			; low byte to multiply by
828b : cda282           	CALL	HALF_TIMES		; HL = A * DE
828e : e5               	PUSH	HL			; save partial result
828f : 67               	LD	H,A			; clear H
8290 : 79               	LD	A,C			; high byte to multiply by
8291 : 4c               	LD	C,H			; clear B
8292 : cda282           	CALL	HALF_TIMES		; HL = A * DE
8295 : d1               	POP	DE			; get last partial result
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   10
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8296 : 41               	LD	B,C			; add partial results
8297 : 4a               	LD	C,D			; add partial results
8298 : 09               	ADD	HL,BC			;
8299 : ce00             	ADC	A,$00			;
829b : 55               	LD	D,L			;
829c : 6c               	LD	L,H			;
829d : 67               	LD	H,A			;
829e : c1               	POP	BC			; get BC back
829f : c36480           	JP	NEXTS2			; save 32 bit result & NEXT
                        
82a2 :                  HALF_TIMES				;
82a2 : 210000           	LD	HL,$0000		; clear partial result
82a5 : 0608             	LD	B,$08			; eight bits to do
82a7 :                  NEXT_BIT
82a7 : 29               	ADD	HL,HL			; result * 2
82a8 : 17               	RLA				; multiply bit into C
82a9 : 3003             	JR	NC,NO_MUL		; branch if no multiply
82ab : 19               	ADD	HL,DE			; add multiplicand
82ac : ce00             	ADC	A,$00			; add in any carry
82ae :                  NO_MUL
82ae : 10f7             	DJNZ	NEXT_BIT		; decr and loop if not done
82b0 : c9               	RET				;
                        
82b1 :                  W_UMOD		;Unsigned divide & MOD
82b1 : 85552f4d4fc4     	DB	$85,'U/MO','D'+$80
82b7 : 7f82             	DW	W_USTAR
82b9 :                  C_UMOD
82b9 : bb82             	DW	2+$			;Vector to code
82bb : 210400           	LD	HL,0004
82be : 39               	ADD	HL,SP
82bf : 5e               	LD	E,(HL)
82c0 : 71               	LD	(HL),C
82c1 : 23               	INC	HL
82c2 : 56               	LD	D,(HL)
82c3 : 70               	LD	(HL),B
82c4 : c1               	POP	BC
82c5 : e1               	POP	HL
82c6 : 7d               	LD	A,L
82c7 : 91               	SUB	C
82c8 : 7c               	LD	A,H
82c9 : 98               	SBC	A,B
82ca : 3808             	JR	C,J22DB
82cc : 21ffff           	LD	HL,$FFFF
82cf : 11ffff           	LD	DE,$FFFF
82d2 : 1826             	JR	J2301
82d4 :                  J22DB
82d4 : 3e10             	LD	A,$10
82d6 :                  J22DD
82d6 : 29               	ADD	HL,HL
82d7 : 17               	RLA
82d8 : eb               	EX	DE,HL
82d9 : 29               	ADD	HL,HL
82da : 3002             	JR	NC,J22E5
82dc : 13               	INC	DE
82dd : a7               	AND	A
82de :                  J22E5
82de : eb               	EX	DE,HL
82df : 1f               	RRA
82e0 : f5               	PUSH	AF
82e1 : 3008             	JR	NC,J22F2
82e3 : 7d               	LD	A,L
82e4 : 91               	SUB	C
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   11
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

82e5 : 6f               	LD	L,A
82e6 : 7c               	LD	A,H
82e7 : 98               	SBC	A,B
82e8 : 67               	LD	H,A
82e9 : 180a             	JR	J22FC
82eb :                  J22F2
82eb : 7d               	LD	A,L
82ec : 91               	SUB	C
82ed : 6f               	LD	L,A
82ee : 7c               	LD	A,H
82ef : 98               	SBC	A,B
82f0 : 67               	LD	H,A
82f1 : 3002             	JR	NC,J22FC
82f3 : 09               	ADD	HL,BC
82f4 : 1b               	DEC	DE
82f5 :                  J22FC
82f5 : 13               	INC	DE
82f6 : f1               	POP	AF
82f7 : 3d               	DEC	A
82f8 : 20dc             	JR	NZ,J22DD
82fa :                  J2301
82fa : c1               	POP	BC
82fb : e5               	PUSH	HL
82fc : d5               	PUSH	DE
82fd : c36680           	JP	NEXT
                        
8300 :                  W_AND		;AND
8300 : 83414ec4         	DB	$83,'AN','D'+$80
8304 : b182             	DW	W_UMOD
8306 :                  C_AND
8306 : 0883             	DW	2+$			;Vector to code
8308 : d1               	POP	DE			;Get n1 off stack
8309 : e1               	POP	HL			;Get n2 off stack
830a : 7b               	LD	A,E			;AND lo bytes
830b : a5               	AND	L			;
830c : 6f               	LD	L,A			;Result in L
830d : 7a               	LD	A,D			;AND hi bytes
830e : a4               	AND	H			;
830f : 67               	LD	H,A			;Result in H
8310 : c36580           	JP	NEXTS1			;Save & next
                        
8313 :                  W_OR		;OR
8313 : 824fd2           	DB	$82,'O','R'+$80
8316 : 0083             	DW	W_AND
8318 :                  C_OR
8318 : 1a83             	DW	2+$			;Vector to code
831a : d1               	POP	DE			;Get n1 off stack
831b : e1               	POP	HL			;Get n2 off stack
831c : 7b               	LD	A,E			;OR lo bytes
831d : b5               	OR	L			;
831e : 6f               	LD	L,A			;Result in L
831f : 7a               	LD	A,D			;OR hi bytes
8320 : b4               	OR	H			;
8321 : 67               	LD	H,A			;Result in H
8322 : c36580           	JP	NEXTS1			;Save & next
                        
8325 :                  W_XOR		;XOR
8325 : 83584fd2         	DB	$83,'XO','R'+$80
8329 : 1383             	DW	W_OR
832b :                  C_XOR
832b : 2d83             	DW	2+$			;Vector to code
832d : d1               	POP	DE			;Get n1 off stack
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   12
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

832e : e1               	POP	HL			;Get n2 off stack
832f : 7b               	LD	A,E			;XOR lo bytes
8330 : ad               	XOR	L			;
8331 : 6f               	LD	L,A			;Result in L
8332 : 7a               	LD	A,D			;XOR hi bytes
8333 : ac               	XOR	H			;
8334 : 67               	LD	H,A			;Result in H
8335 : c36580           	JP	NEXTS1			;Save & NEXT
                        
8338 :                  W_SPFETCH	;Stack pointer onto stack
8338 : 835350c0         	DB	$83,'SP','@'+$80
833c : 2583             	DW	W_XOR
833e :                  C_SPFETCH
833e : 4083             	DW	2+$			;Vector to code
8340 : 210000           	LD	HL,0000			;No offset
8343 : 39               	ADD	HL,SP			;Add SP to HL
8344 : c36580           	JP	NEXTS1			;Save & NEXT
                        
8347 :                  W_SPSTORE	;Set initial stack pointer value
8347 : 835350a1         	DB	$83,'SP','!'+$80
834b : 3883             	DW	W_SPFETCH
834d :                  C_SPSTORE
834d : 4f83             	DW	2+$			;Vector to code
834f : 2a2280           	LD	HL,(DEF_SYSADDR)	;Get system base addr
8352 : 110600           	LD	DE,S0-SYSTEM		;Offset to stack pointer value (0006)
8355 : 19               	ADD	HL,DE			;Add to base addr
8356 : 5e               	LD	E,(HL)			;Get SP from ram
8357 : 23               	INC	HL			;
8358 : 56               	LD	D,(HL)			;
8359 : eb               	EX	DE,HL			;Put into HL
835a : f9               	LD	SP,HL			;Set SP
835b : c36680           	JP	NEXT
                        
835e :                  W_RPFETCH	;Get return stack pointer
835e : 835250c0         	DB	$83,'RP','@'+$80
8362 : 4783             	DW	W_SPSTORE
8364 :                  C_RPFETCH
8364 : 6683             	DW	2+$			;Vector to code
8366 : 2a46fe           	LD	HL,(RPP)		;Return stack pointer into HL
8369 : c36580           	JP	NEXTS1			;Save & NEXT
                        
836c :                  W_RPSTORE	;Set initial return stack pointer
836c : 835250a1         	DB	$83,'RP','!'+$80
8370 : 5e83             	DW	W_RPFETCH
8372 :                  C_RPSTORE
8372 : 7483             	DW	2+$			;Vector to code
8374 : 2a2280           	LD	HL,(DEF_SYSADDR)	;Get system base addr
8377 : 110800           	LD	DE,0008			;Offset to return stack pointer value
837a : 19               	ADD	HL,DE			;Add to base addr
837b : 5e               	LD	E,(HL)			;Get SP from ram
837c : 23               	INC	HL			;
837d : 56               	LD	D,(HL)			;
837e : eb               	EX	DE,HL			;Put into HL
837f : 2246fe           	LD	(RPP),HL		;Set return SP
8382 : c36680           	JP	NEXT
                        
8385 :                  W_STOP		;Pop BC from return stack (=next)
8385 : 823bd3           	DB	$82,';','S'+$80
8388 : 6c83             	DW	W_RPSTORE
838a :                  C_STOP
838a : 8c83             	DW	2+$			;Vector to code
838c :                  X_STOP
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   13
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

838c : 2a46fe           	LD	HL,(RPP)		;Return stack pointer to HL
838f : 4e               	LD	C,(HL)			;Get low byte
8390 : 23               	INC	HL			;
8391 : 46               	LD	B,(HL)			;Get high byte
8392 : 23               	INC	HL			;
8393 : 2246fe           	LD	(RPP),HL		;Save stack pointer
8396 : c36680           	JP	NEXT
                        
8399 :                  W_LEAVE		;Quit loop by making index = limit
8399 : 854c454156c5     	DB	$85,'LEAV','E'+$80
839f : 8583             	DW	W_STOP
83a1 :                  C_LEAVE
83a1 : a383             	DW	2+$			;Vector to code
83a3 : 2a46fe           	LD	HL,(RPP)		;Get return stack pointer
83a6 : 5e               	LD	E,(HL)			;Get loop limit low
83a7 : 23               	INC	HL			;
83a8 : 56               	LD	D,(HL)			;Get loop limit high
83a9 : 23               	INC	HL			;
83aa : 73               	LD	(HL),E			;Set index low to loop limit
83ab : 23               	INC	HL			;
83ac : 72               	LD	(HL),D			;Set index high to loop limit
83ad : c36680           	JP	NEXT
                        
83b0 :                  W_MOVER		;Move from data to return stack
83b0 : 823ed2           	DB	$82,'>','R'+$80
83b3 : 9983             	DW	W_LEAVE
83b5 :                  C_MOVER
83b5 : b783             	DW	2+$			;Vector to code
83b7 : d1               	POP	DE			;Get value
83b8 : 2a46fe           	LD	HL,(RPP)		;Get return stack pointer
83bb : 2b               	DEC	HL			;Set new value
83bc : 2b               	DEC	HL			;
83bd : 2246fe           	LD	(RPP),HL		;Save it
83c0 : 73               	LD	(HL),E			;Push low byte onto return stack
83c1 : 23               	INC	HL			;
83c2 : 72               	LD	(HL),D			;Push high byte onto return stack
83c3 : c36680           	JP	NEXT
                        
83c6 :                  W_RMOVE		;Move word from return to data stack
83c6 : 8252be           	DB	$82,'R','>'+$80
83c9 : b083             	DW	W_MOVER
83cb :                  C_RMOVE
83cb : cd83             	DW	2+$			;Vector to code
83cd : 2a46fe           	LD	HL,(RPP)		;Get return stack pointer
83d0 : 5e               	LD	E,(HL)			;Pop word off return stack
83d1 : 23               	INC	HL			;
83d2 : 56               	LD	D,(HL)			;
83d3 : 23               	INC	HL			;
83d4 : 2246fe           	LD	(RPP),HL		;Save new return stack pointer
83d7 : d5               	PUSH	DE			;Push on data stack
83d8 : c36680           	JP	NEXT
                        
83db :                  W_RFETCH	;Return stack top to data stack
83db : 8252c0           	DB	$82,'R','@'+$80
83de : c683             	DW	W_RMOVE
83e0 :                  C_RFETCH
83e0 : 4081             	DW	X_I			;Return stack top to data stack
                        
                        
83e2 :                  W_0EQUALS	;=0
83e2 : 8230bd           	DB	$82,'0','='+$80
83e5 : db83             	DW	W_RFETCH
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   14
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

83e7 :                  C_0EQUALS
83e7 : e983             	DW	2+$			;Vector to code
83e9 :                  X_0EQUALS
83e9 : e1               	POP	HL			;Get value from stack
83ea : 7d               	LD	A,L			;set flags
83eb : b4               	OR	H			;
83ec : 210000           	LD	HL,0000			;Not = 0 flag
83ef : 2001             	JR	NZ,NO_ZERO		;
83f1 : 23               	INC	HL			;= 0 flag
83f2 :                  NO_ZERO
83f2 : c36580           	JP	NEXTS1			;Save & NEXT
                        
83f5 :                  W_NOT		;Convert flag, same as 0=
83f5 : 834e4fd4         	DB	$83,'NO','T'+$80
83f9 : e283             	DW	W_0EQUALS
83fb :                  C_NOT
83fb : e983             	DW	X_0EQUALS
                        
83fd :                  W_0LESS		;Less than 0
83fd : 8230bc           	DB	$82,'0','<'+$80
8400 : f583             	DW	W_NOT
8402 :                  C_0LESS
8402 : 0484             	DW	2+$			;Vector to code
8404 : e1               	POP	HL			;Get value
8405 : 29               	ADD	HL,HL			;S bit into C
8406 : 210000           	LD	HL,0000			;Wasn't < 0 flag
8409 : 3001             	JR	NC,NOT_LT0		;
840b : 23               	INC	HL			;Was < 0 flag
840c :                  NOT_LT0				;
840c : c36580           	JP	NEXTS1			;Save & NEXT
                        
840f :                  W_PLUS			;n1 + n2
840f : 81ab             	DB	$81,'+'+$80
8411 : fd83             	DW	W_0LESS
8413 :                  C_PLUS
8413 : 1584             	DW	2+$			;Vector to code
8415 : d1               	POP	DE			;Get n2
8416 : e1               	POP	HL			;Get n1
8417 : 19               	ADD	HL,DE			;Add them
8418 : c36580           	JP	NEXTS1			;Save & NEXT
                        
841b :                  W_DPLUS		;32 bit add
841b : 8244ab           	DB	$82,'D','+'+$80
841e : 0f84             	DW	W_PLUS
8420 :                  C_DPLUS
8420 : 2284             	DW	2+$			;Vector to code
8422 : 210600           	LD	HL,0006			; offset to low word
8425 : 39               	ADD	HL,SP			; add stack pointer
8426 : 5e               	LD	E,(HL)			; get d1 low word low byte
8427 : 71               	LD	(HL),C			; save BC low byte
8428 : 23               	INC	HL			; point to high byte
8429 : 56               	LD	D,(HL)			; get d1 low word high byte
842a : 70               	LD	(HL),B			; save BC high byte
842b : c1               	POP	BC			; get high word d2
842c : e1               	POP	HL			; get low word d2
842d : 19               	ADD	HL,DE			; add low words
842e : eb               	EX	DE,HL			; save result low word in DE
842f : e1               	POP	HL			; get d1 high word
8430 : 7d               	LD	A,L			; copy d1 high word low byte
8431 : 89               	ADC	A,C			; add d2 high word low byte
                        					; + carry from low word add
8432 : 6f               	LD	L,A			; result from high word low byte into L
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   15
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8433 : 7c               	LD	A,H			; copy d1 high word low byte
8434 : 88               	ADC	A,B			; add d2 high word low byte
                        					; + carry from high word low byte add
8435 : 67               	LD	H,A			; result from high word high byte into H
8436 : c1               	POP	BC			; restore BC
8437 : c36480           	JP	NEXTS2			;Save 32 bit result & NEXT
                        
843a :                  W_NEGATE	;Form 2s complement of n
843a : 864e45474154c5   	DB	$86,'NEGAT','E'+$80
8441 : 1b84             	DW	W_DPLUS
8443 :                  C_NEGATE
8443 : 4584             	DW	2+$			;Vector to code
8445 : e1               	POP	HL			;Get number
8446 : 7d               	LD	A,L			;Low byte into A
8447 : 2f               	CPL				;Complement it
8448 : 6f               	LD	L,A			;Back into L
8449 : 7c               	LD	A,H			;High byte into A
844a : 2f               	CPL				;Complement it
844b : 67               	LD	H,A			;Back into H
844c : 23               	INC	HL			;+1
844d : c36580           	JP	NEXTS1			;Save & NEXT
                        
8450 :                  W_DNEGATE	;Form 2s complement of 32 bit n
8450 : 87444e45474154c5 	DB	$87,'DNEGAT','E'+$80
8458 : 3a84             	DW	W_NEGATE
845a :                  C_DNEGATE
845a : 5c84             	DW	2+$			;Vector to code
845c : e1               	POP	HL			; get high word
845d : d1               	POP	DE			; get low word
845e : 97               	SUB	A			; clear A
845f : 93               	SUB	E			; negate low word low byte
8460 : 5f               	LD	E,A			; copy back to E
8461 : 3e00             	LD	A,$00			; clear A
8463 : 9a               	SBC	A,D			; negate low word high byte
8464 : 57               	LD	D,A			; copy back to D
8465 : 3e00             	LD	A,$00			; clear A
8467 : 9d               	SBC	A,L			; negate high word low byte
8468 : 6f               	LD	L,A			; copy back to L
8469 : 3e00             	LD	A,$00			; clear A
846b : 9c               	SBC	A,H			; negate high word high byte
846c : 67               	LD	H,A			; copy back to H
846d : c36480           	JP	NEXTS2			;Save 32 bit result & NEXT
                        
8470 :                  W_OVER		;Copy 2nd down to top of stack
8470 : 844f5645d2       	DB	$84,'OVE','R'+$80
8475 : 5084             	DW	W_DNEGATE
8477 :                  C_OVER
8477 : 7984             	DW	2+$			;Vector to code
8479 : d1               	POP	DE			;Get top
847a : e1               	POP	HL			;Get next
847b : e5               	PUSH	HL			;Save it back
847c : c36480           	JP	NEXTS2			;Save both & NEXT
                        
847f :                  W_DROP		;Drop top value from stack
847f : 8444524fd0       	DB	$84,'DRO','P'+$80
8484 : 7084             	DW	W_OVER
8486 :                  C_DROP
8486 : 8884             	DW	2+$			;Vector to code
8488 : e1               	POP	HL			;Get top value
8489 : c36680           	JP	NEXT
                        
848c :                  W_2DROP		;Drop top two values from stack
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   16
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

848c : 853244524fd0     	DB	$85,'2DRO','P'+$80
8492 : 7f84             	DW	W_DROP
8494 :                  C_2DROP
8494 : 9684             	DW	2+$			;Vector to code
8496 : e1               	POP	HL			;Get top value
8497 : e1               	POP	HL			;Get top value
8498 : c36680           	JP	NEXT
                        
849b :                  W_SWAP		;Swap top 2 values on stack
849b : 84535741d0       	DB	$84,'SWA','P'+$80
84a0 : 8c84             	DW	W_2DROP
84a2 :                  C_SWAP
84a2 : a484             	DW	2+$			;Vector to code
84a4 : e1               	POP	HL			;Get top value
84a5 : e3               	EX	(SP),HL			;Exchanhe with next down
84a6 : c36580           	JP	NEXTS1			;Save & NEXT
                        
84a9 :                  W_DUP		;Duplicate top value on stack
84a9 : 834455d0         	DB	$83,'DU','P'+$80
84ad : 9b84             	DW	W_SWAP
84af :                  C_DUP
84af : b184             	DW	2+$			;Vector to code
84b1 : e1               	POP	HL			;Get value off stack
84b2 : e5               	PUSH	HL			;Copy it back
84b3 : c36580           	JP	NEXTS1			;Save & NEXT
                        
84b6 :                  W_2DUP		;Dup top 2 values on stack
84b6 : 84324455d0       	DB	$84,'2DU','P'+$80
84bb : a984             	DW	W_DUP
84bd :                  C_2DUP
84bd : bf84             	DW	2+$			;Vector to code
84bf : e1               	POP	HL			;Get top two values from stack
84c0 : d1               	POP	DE			;
84c1 : d5               	PUSH	DE			;Copy them back
84c2 : e5               	PUSH	HL			;
84c3 : c36480           	JP	NEXTS2			;Save both & NEXT
                        
84c6 :                  W_BOUNDS	;Convert address & n to start & end
84c6 : 86424f554e44d3   	DB	$86,'BOUND','S'+$80
84cd : b684             	DW	W_2DUP
84cf :                  C_BOUNDS
84cf : d184             	DW	2+$			;Vector to code
84d1 : e1               	POP	HL			; get n
84d2 : d1               	POP	DE			; get addr
84d3 : 19               	ADD	HL,DE			; add addr to n
84d4 : eb               	EX	DE,HL			; swap them
84d5 : c36480           	JP	NEXTS2			; save both & NEXT
                        
84d8 :                  W_PLUSSTORE	;Add n1 to addr
84d8 : 822ba1           	DB	$82,'+','!'+$80
84db : c684             	DW	W_BOUNDS
84dd :                  C_PLUSSTORE
84dd : df84             	DW	2+$			;Vector to code
84df : e1               	POP	HL			;Get addr
84e0 : d1               	POP	DE			;Get DE
84e1 : 7e               	LD	A,(HL)			;Add low bytes
84e2 : 83               	ADD	A,E			;
84e3 : 77               	LD	(HL),A			;Store result
84e4 : 23               	INC	HL			;Point to high byte
84e5 : 7e               	LD	A,(HL)			;Add high bytes
84e6 : 8a               	ADC	A,D			;
84e7 : 77               	LD	(HL),A			;Store result
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   17
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

84e8 : c36680           	JP	NEXT
                        
84eb :                  W_TOGGLE	;XOR (addr) with byte
84eb : 86544f47474cc5   	DB	$86,'TOGGL','E'+$80
84f2 : d884             	DW	W_PLUSSTORE
84f4 :                  C_TOGGLE
84f4 : f684             	DW	2+$			;Vector to code
84f6 : d1               	POP	DE			;Get byte
84f7 : e1               	POP	HL			;Get addr
84f8 : 7e               	LD	A,(HL)			;Get byte from addr
84f9 : ab               	XOR	E			;Toggle it
84fa : 77               	LD	(HL),A			;Save result
84fb : c36680           	JP	NEXT
                        
84fe :                  W_FETCH		;Get word from addr on stack
84fe : 81c0             	DB	$81,'@'+$80
8500 : eb84             	DW	W_TOGGLE
8502 :                  C_FETCH
8502 : 0485             	DW	2+$			;Vector to code
8504 : e1               	POP	HL			;Get addr
8505 : 5e               	LD	E,(HL)			;Get low byte
8506 : 23               	INC	HL			;
8507 : 56               	LD	D,(HL)			;Get high byte
8508 : d5               	PUSH	DE			;Save it
8509 : c36680           	JP	NEXT
                        
850c :                  W_CFETCH	;Get byte from addr on stack
850c : 8243c0           	DB	$82,'C','@'+$80
850f : fe84             	DW	W_FETCH
8511 :                  C_CFETCH
8511 : 1385             	DW	2+$			;Vector to code
8513 : e1               	POP	HL			;Get addr
8514 : 6e               	LD	L,(HL)			;Get byte
8515 : 2600             	LD	H,$00			;Top byte = 0
8517 : c36580           	JP	NEXTS1			;Save & NEXT
                        
851a :                  W_2FETCH	;Get word from addr+2 and addr
851a : 8232c0           	DB	$82,'2','@'+$80
851d : 0c85             	DW	W_CFETCH
851f :                  C_2FETCH
851f : 2185             	DW	2+$			;Vector to code
8521 : e1               	POP	HL			;Get addr
8522 : 110200           	LD	DE,0002			;Plus 2 bytes
8525 : 19               	ADD	HL,DE			;Get 2nd word first
8526 : 5e               	LD	E,(HL)			;Low byte
8527 : 23               	INC	HL			;
8528 : 56               	LD	D,(HL)			;High byte
8529 : d5               	PUSH	DE			;Save it
852a : 11fdff           	LD	DE,$FFFD		;Minus 2 bytes
852d : 19               	ADD	HL,DE			;Get 1st word
852e : 5e               	LD	E,(HL)			;Low byte
852f : 23               	INC	HL			;
8530 : 56               	LD	D,(HL)			;High byte
8531 : d5               	PUSH	DE			;Save it
8532 : c36680           	JP	NEXT
                        
8535 :                  W_STORE		;Store word at addr
8535 : 81a1             	DB	$81,'!'+$80
8537 : 1a85             	DW	W_2FETCH
8539 :                  C_STORE
8539 : 3b85             	DW	2+$			;Vector to code
853b : e1               	POP	HL			;Get addr
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   18
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

853c : d1               	POP	DE			;Get word
853d : 73               	LD	(HL),E			;Store low byte
853e : 23               	INC	HL			;
853f : 72               	LD	(HL),D			;Store high byte
8540 : c36680           	JP	NEXT
                        
8543 :                  W_CSTORE	;Store byte at addr
8543 : 8243a1           	DB	$82,'C','!'+$80
8546 : 3585             	DW	W_STORE
8548 :                  C_CSTORE
8548 : 4a85             	DW	2+$			;Vector to code
854a : e1               	POP	HL			;Get addr
854b : d1               	POP	DE			;Get byte
854c : 73               	LD	(HL),E			;Save it
854d : c36680           	JP	NEXT
                        
8550 :                  W_2STORE	;Store 2 words at addr (+2)
8550 : 8232a1           	DB	$82,'2','!'+$80
8553 : 4385             	DW	W_CSTORE
8555 :                  C_2STORE
8555 : 5785             	DW	2+$			;Vector to code
8557 : e1               	POP	HL			;Get addr
8558 : d1               	POP	DE			;Get word
8559 : 73               	LD	(HL),E			;Save low byte
855a : 23               	INC	HL			;
855b : 72               	LD	(HL),D			;Save high byte
855c : 23               	INC	HL			;
855d : d1               	POP	DE			;Get next word
855e : 73               	LD	(HL),E			;Save low byte
855f : 23               	INC	HL			;
8560 : 72               	LD	(HL),D			;Save high byte
8561 : c36680           	JP	NEXT
                        
8564 :                  W_COLON
8564 : 8180             	DB	$81,''+$80
8566 : 5085             	DW	W_2STORE
8568 :                  C_COLON
8568 : 7c85             	DW	E_COLON			;Interpret following word sequence
856a : d38a             	DW	C_QEXEC			;Error not if not in execute mode
856c : 8e8a             	DW	C_CSPSTORE		;Set current stack pointer value
856e : 0d87             	DW	C_CURRENT		;Get CURRENT addr
8570 : 0285             	DW	C_FETCH			;Get word from addr on stack
8572 : ff86             	DW	C_CONTEXT		;Make CONTEXT current vocab
8574 : 3985             	DW	C_STORE			;Store word at addr
8576 : 778f             	DW	C_XXX1			;Puts name into dictionary
8578 : 588b             	DW	C_RIGHTBRKT		;Set STATE to compile
857a : ab8b             	DW	C_CCODE			;Execute following machine code
                        
857c :                  E_COLON
857c : 2a46fe           	LD	HL,(RPP)		;Get return stack pointer
857f : 2b               	DEC	HL			;Put BC on return stack
8580 : 70               	LD	(HL),B			;
8581 : 2b               	DEC	HL			;
8582 : 71               	LD	(HL),C			;
8583 : 2246fe           	LD	(RPP),HL		;Save new pointer
8586 : 13               	INC	DE
8587 : 4b               	LD	C,E
8588 : 42               	LD	B,D
8589 : c36680           	JP	NEXT
                        
858c :                  W_SEMICOLON	;Terminate compilation
858c : c1bb             	DB	$C1,';'+$80
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   19
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

858e : 6485             	DW	W_COLON
8590 :                  C_SEMICOLON
8590 : 7c85             	DW	E_COLON			;Interpret following word sequence
8592 : bb8a             	DW	C_QCOMP			;Check we're allready compiling
8594 : fd8a             	DW	C_WHATSTACK		;Check stack pointer, error if not ok
8596 : 348b             	DW	C_COMPILE		;Compile next word into dictionary
8598 : 8a83             	DW	C_STOP			;
859a : 6d8b             	DW	C_SMUDGE		;Smudge bit to O.K.
859c : 4a8b             	DW	C_LEFTBRKT		;Set STATE to execute
859e : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
85a0 :                  W_CONSTANT
85a0 : 88434f4e535441.. 	DB	$88,'CONSTAN','T'+$80
85a9 : 8c85             	DW	W_SEMICOLON
85ab :                  C_CONSTANT
85ab : 7c85             	DW	E_COLON			;Interpret following word sequence
85ad : 778f             	DW	C_XXX1
85af : 6d8b             	DW	C_SMUDGE
85b1 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
85b3 : ab8b             	DW	C_CCODE			;Execute following machine code
                        
85b5 :                  X_CONSTANT				;Put next word on stack
85b5 : 13               	INC	DE			;Adjust pointer
85b6 : eb               	EX	DE,HL			;Get next word
85b7 : 5e               	LD	E,(HL)			;
85b8 : 23               	INC	HL			;
85b9 : 56               	LD	D,(HL)			;
85ba : d5               	PUSH	DE			;Put on stack
85bb : c36680           	JP	NEXT
                        
85be :                  W_VARIABLE
85be : 88564152494142.. 	DB	$88,'VARIABL','E'+$80
85c7 : a085             	DW	W_CONSTANT
85c9 :                  C_VARIABLE
85c9 : 7c85             	DW	E_COLON			;Interpret following word sequence
85cb : f385             	DW	C_ZERO			;Put zero on stack
85cd : ab85             	DW	C_CONSTANT
85cf : ab8b             	DW	C_CCODE			;Execute following machine code
                        
85d1 :                  X_VARIABLE
85d1 : 13               	INC	DE
85d2 : d5               	PUSH	DE
85d3 : c36680           	JP	NEXT
                        
85d6 :                  W_USER
85d6 : 84555345d2       	DB	$84,'USE','R'+$80
85db : be85             	DW	W_VARIABLE
85dd :                  C_USER
85dd : 7c85             	DW	E_COLON			;Interpret following word sequence
85df : ab85             	DW	C_CONSTANT
85e1 : ab8b             	DW	C_CCODE			;Execute following machine code
                        
85e3 :                  X_USER
85e3 : 13               	INC	DE			;Adjust to next word
85e4 : eb               	EX	DE,HL
85e5 : 5e               	LD	E,(HL)
85e6 : 23               	INC	HL
85e7 : 56               	LD	D,(HL)
85e8 : 2a2280           	LD	HL,(DEF_SYSADDR)
85eb : 19               	ADD	HL,DE
85ec : c36580           	JP	NEXTS1			;Save & NEXT
                        
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   20
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

85ef :                  W_ZERO		;Put zero on stack
85ef : 81b0             	DB	$81,'0'+$80
85f1 : d685             	DW	W_USER
85f3 :                  C_ZERO
85f3 : b585             	DW	X_CONSTANT		;Put next word on stack
85f5 : 0000             	DW	$0000
                        
85f7 :                  W_1		;Put 1 on stack
85f7 : 81b1             	DB	$81,'1'+$80
85f9 : ef85             	DW	W_ZERO
85fb :                  C_1
85fb : b585             	DW	X_CONSTANT		;Put next word on stack
85fd : 0100             	DW	$0001
                        
85ff :                  W_2
85ff : 81b2             	DB	$81,'2'+$80
8601 : f785             	DW	W_1
8603 :                  C_2
8603 : b585             	DW	X_CONSTANT		;Put next word on stack
8605 : 0200             	DW	$0002
                        
8607 :                  W_3
8607 : 81b3             	DB	$81,'3'+$80
8609 : ff85             	DW	W_2
860b :                  C_3
860b : b585             	DW	X_CONSTANT		;Put next word on stack
860d : 0300             	DW	$0003
                        
860f :                  W_BL		;Leaves ASCII for blank on stack
860f : 8242cc           	DB	$82,'B','L'+$80
8612 : 0786             	DW	W_3
8614 :                  C_BL
8614 : b585             	DW	X_CONSTANT		;Put next word on stack
8616 : 2000             	DW	$0020
                        
8618 :                  W_CL
8618 : 83432fcc         	DB	$83,'C/','L'+$80
861c : 0f86             	DW	W_BL
861e :                  C_CL
861e : 7c85             	DW	E_COLON			;Interpret following word sequence
8620 : 6087             	DW	C_UCL
8622 : 0285             	DW	C_FETCH			;Get word from addr on stack
8624 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8626 :                  W_FIRST
8626 : 8546495253d4     	DB	$85,'FIRS','T'+$80
862c : 1886             	DW	W_CL
862e :                  C_FIRST
862e : 7c85             	DW	E_COLON			;Interpret following word sequence
8630 : 6d87             	DW	C_UFIRST		;Put UFIRST addr on stack
8632 : 0285             	DW	C_FETCH			;Get word from addr on stack
8634 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8636 :                  W_LIMIT
8636 : 854c494d49d4     	DB	$85,'LIMI','T'+$80
863c : 2686             	DW	W_FIRST
863e :                  C_LIMIT
863e : 7c85             	DW	E_COLON			;Interpret following word sequence
8640 : 7a87             	DW	C_ULIMIT		;Put ULIMIT on stack
8642 : 0285             	DW	C_FETCH			;Get word from addr on stack
8644 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   21
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8646 :                  W_BBUF
8646 : 85422f4255c6     	DB	$85,'B/BU','F'+$80
864c : 3686             	DW	W_LIMIT
864e :                  C_BBUF
864e : 7c85             	DW	E_COLON			;Interpret following word sequence
8650 : 8787             	DW	C_UBBUF
8652 : 0285             	DW	C_FETCH			;Get word from addr on stack
8654 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8656 :                  W_BSCR
8656 : 85422f5343d2     	DB	$85,'B/SC','R'+$80
865c : 4686             	DW	W_BBUF
865e :                  C_BSCR
865e : 7c85             	DW	E_COLON			;Interpret following word sequence
8660 : 9487             	DW	C_UBSCR			;Number of buffers per block
8662 : 0285             	DW	C_FETCH			;Get word from addr on stack
8664 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8666 :                  W_S0		;Push S0 (initial data stack pointer)
8666 : 8253b0           	DB	$82,'S','0'+$80
8669 : 5686             	DW	W_BSCR
866b :                  C_S0
866b : e385             	DW	X_USER			;Put next word on stack then do next
866d : 0600             	DW	S0-SYSTEM
                        
866f :                  W_R0
866f : 8252b0           	DB	$82,'R','0'+$80
8672 : 6686             	DW	W_S0
8674 :                  C_R0
8674 : e385             	DW	X_USER			;Put next word on stack then do next
8676 : 0800             	DW	R0-SYSTEM
                        
8678 :                  W_TIB
8678 : 835449c2         	DB	$83,'TI','B'+$80
867c : 6f86             	DW	W_R0
867e :                  C_TIB
867e : e385             	DW	X_USER			;Put next word on stack then do next
8680 : 0a00             	DW	TIB-SYSTEM
                        
8682 :                  W_WIDTH
8682 : 8557494454c8     	DB	$85,'WIDT','H'+$80
8688 : 7886             	DW	W_TIB
868a :                  C_WIDTH
868a : e385             	DW	X_USER			;Put next word on stack then do next
868c : 0c00             	DW	WIDTH-SYSTEM
                        
868e :                  W_WARNING	;Put WARNING addr on stack
868e : 875741524e494ec7 	DB	$87,'WARNIN','G'+$80
8696 : 8286             	DW	W_WIDTH
8698 :                  C_WARNING
8698 : e385             	DW	X_USER			;Put next word on stack then do next
869a : 0e00             	DW	WARNING-SYSTEM
                        
869c :                  W_FENCE
869c : 8546454e43c5     	DB	$85,'FENC','E'+$80
86a2 : 8e86             	  	DW	W_WARNING
86a4 :                  C_FENCE
86a4 : e385             	DW	X_USER			;Put next word on stack then do next
86a6 : 1000             	DW	FENCE-SYSTEM
                        
86a8 :                  W_DP		;Dictionary pointer addr on stack
86a8 : 8244d0           	DB	$82,'D','P'+$80
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   22
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

86ab : 9c86             	DW	W_FENCE
86ad :                  C_DP
86ad : e385             	DW	X_USER			;Put next word on stack then do next
86af : 1200             	DW	DP-SYSTEM
                        
86b1 :                  W_VOC_LINK
86b1 : 88564f432d4c49.. 	DB	$88,'VOC-LIN','K'+$80
86ba : a886             	DW	W_DP
86bc :                  C_VOC_LINK
86bc : e385             	DW	X_USER			;Put next word on stack then do next
86be : 1400             	DW	VOC_LINK-SYSTEM
                        
86c0 :                  W_BLK
86c0 : 83424ccb         	DB	$83,'BL','K'+$80
86c4 : b186             	DW	W_VOC_LINK
86c6 :                  C_BLK
86c6 : e385             	DW	X_USER			;Put next word on stack then do next
86c8 : 1600             	DW	BLK-SYSTEM
                        
86ca :                  W_TOIN
86ca : 833e49ce         	DB	$83,'>I','N'+$80
86ce : c086             	DW	W_BLK
86d0 :                  C_TOIN
86d0 : e385             	DW	X_USER			;Put next word on stack then do next
86d2 : 1800             	DW	TOIN-SYSTEM
                        
86d4 :                  W_OUT		;Put OUT buffer count addr on stack
86d4 : 834f55d4         	DB	$83,'OU','T'+$80
86d8 : ca86             	DW	W_TOIN
86da :                  C_OUT
86da : e385             	DW	X_USER			;Put next word on stack then do next
86dc : 1a00             	DW	OUT_-SYSTEM
                        
86de :                  W_SCR
86de : 835343d2         	DB	$83,'SC','R'+$80
86e2 : d486             	DW	W_OUT
86e4 :                  C_SCR
86e4 : e385             	DW	X_USER			;Put next word on stack then do next
86e6 : 1c00             	DW	SCR-SYSTEM
                        
86e8 :                  W_OFFSET	;Put disk block offset on stack
86e8 : 864f46465345d4   	DB	$86,'OFFSE','T'+$80
86ef : de86             	DW	W_SCR
86f1 :                  C_OFFSET
86f1 : e385             	DW	X_USER			;Put next word on stack then do next
86f3 : 1e00             	DW	OFFSET-SYSTEM
                        
86f5 :                  W_CONTEXT
86f5 : 87434f4e544558d4 	DB	$87,'CONTEX','T'+$80
86fd : e886             	DW	W_OFFSET
86ff :                  C_CONTEXT
86ff : e385             	DW	X_USER			;Put next word on stack then do next
8701 : 2000             	DW	CONTEXT-SYSTEM
                        
8703 :                  W_CURRENT
8703 : 8743555252454ed4 	DB	$87,'CURREN','T'+$80
870b : f586             	DW	W_CONTEXT
870d :                  C_CURRENT
870d : e385             	DW	X_USER			;Put next word on stack then do next
870f : 2200             	DW	CURRENT-SYSTEM
                        
8711 :                  W_STATE		;Push STATE addr
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   23
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8711 : 8553544154c5     	DB	$85,'STAT','E'+$80
8717 : 0387             	DW	W_CURRENT
8719 :                  C_STATE
8719 : e385             	DW	X_USER			;Put next word on stack then do next
871b : 2400             	DW	STATE-SYSTEM
                        
871d :                  W_BASE		;Put BASE addr on stack
871d : 84424153c5       	DB	$84,'BAS','E'+$80
8722 : 1187             	DW	W_STATE
8724 :                  C_BASE
8724 : e385             	DW	X_USER			;Put next word on stack then do next
8726 : 2600             	DW	BASE-SYSTEM
                        
8728 :                  W_DPL
8728 : 834450cc         	DB	$83,'DP','L'+$80
872c : 1d87             	DW	W_BASE
872e :                  C_DPL
872e : e385             	DW	X_USER			;Put next word on stack then do next
8730 : 2800             	DW	DPL-SYSTEM
                        
8732 :                  W_FLD
8732 : 83464cc4         	DB	$83,'FL','D'+$80
8736 : 2887             	DW	W_DPL
8738 :                  C_FLD
8738 : e385             	DW	X_USER			;Put next word on stack then do next
873a : 2a00             	DW	FLD-SYSTEM
                        
873c :                  W_CSP		;Push check stack pointer addr
873c : 834353d0         	DB	$83,'CS','P'+$80
8740 : 3287             	DW	W_FLD
8742 :                  C_CSP
8742 : e385             	DW	X_USER			;Put next word on stack then do next
8744 : 2c00             	DW	CSP-SYSTEM
                        
8746 :                  W_RHASH
8746 : 8252a3           	DB	$82,'R','#'+$80
8749 : 3c87             	DW	W_CSP
874b :                  C_RHASH
874b : e385             	DW	X_USER			;Put next word on stack then do next
874d : 2e00             	DW	RHASH-SYSTEM
                        
874f :                  W_HLD
874f : 83484cc4         	DB	$83,'HL','D'+$80
8753 : 4687             	DW	W_RHASH
8755 :                  C_HLD
8755 : e385             	DW	X_USER			;Put next word on stack then do next
8757 : 3000             	DW	HLD-SYSTEM
                        
8759 :                  W_UCL
8759 : 8455432fcc       	DB	$84,'UC/','L'+$80
875e : 4f87             	DW	W_HLD
8760 :                  C_UCL
8760 : e385             	DW	X_USER			;Put next word on stack then do next
8762 : 5c00             	DW	UCL-SYSTEM
                        
8764 :                  W_UFIRST
8764 : 865546495253d4   	DB	$86,'UFIRS','T'+$80
876b : 5987             	DW	W_UCL
876d :                  C_UFIRST
876d : e385             	DW	X_USER			;Put next word on stack then do next
876f : 5e00             	DW	UFIRST-SYSTEM
                        
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   24
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8771 :                  W_ULIMIT
8771 : 86554c494d49d4   	DB	$86,'ULIMI','T'+$80
8778 : 6487             	DW	W_UFIRST
877a :                  C_ULIMIT
877a : e385             	DW	X_USER			;Put next word on stack then do next
877c : 6000             	DW	ULIMIT-SYSTEM
                        
877e :                  W_UBBUF
877e : 8655422f4255c6   	DB	$86,'UB/BU','F'+$80
8785 : 7187             	DW	W_ULIMIT
8787 :                  C_UBBUF
8787 : e385             	DW	X_USER			;Put next word on stack then do next
8789 : 6200             	DW	UBBUF-SYSTEM
                        
878b :                  W_UBSCR
878b : 8655422f5343d2   	DB	$86,'UB/SC','R'+$80
8792 : 7e87             	DW	W_UBBUF
8794 :                  C_UBSCR
8794 : e385             	DW	X_USER			;Put next word on stack then do next
8796 : 6400             	DW	UBSCR-SYSTEM
                        
8798 :                  W_UTERMINAL
8798 : 8a553f5445524d.. 	DB	$8A,'U?TERMINA','L'+$80
87a3 : 8b87             	DW	W_UBSCR
87a5 :                  C_UTERMINAL
87a5 : e385             	DW	X_USER			;Put next word on stack then do next
87a7 : 5000             	DW	UTERMINAL-SYSTEM
                        
87a9 :                  W_UKEY		;Put UKEY addr on stack
87a9 : 84554b45d9       	DB	$84,'UKE','Y'+$80
87ae : 9887             	DW	W_UTERMINAL
87b0 :                  C_UKEY
87b0 : e385             	DW	X_USER			;Put next word on stack then do next
87b2 : 5200             	DW	UKEY-SYSTEM
                        
87b4 :                  W_UEMIT		;Put UEMIT addr on stack
87b4 : 8555454d49d4     	DB	$85,'UEMI','T'+$80
87ba : a987             	DW	W_UKEY
87bc :                  C_UEMIT
87bc : e385             	DW	X_USER			;Put next word on stack then do next
87be : 5400             	DW	UEMIT-SYSTEM
                        
87c0 :                  W_UCR		;Push UCR addr
87c0 : 835543d2         	DB	$83,'UC','R'+$80
87c4 : b487             	DW	W_UEMIT
87c6 :                  C_UCR
87c6 : e385             	DW	X_USER			;Put next word on stack then do next
87c8 : 5800             	DW	UCR-SYSTEM
                        
87ca :                  W_URW
87ca : 8455522fd7       	DB	$84,'UR/','W'+$80
87cf : c087             	DW	W_UCR
87d1 :                  C_URW
87d1 : e385             	DW	X_USER			;Put next word on stack then do next
87d3 : 5600             	DW	URW-SYSTEM
                        
87d5 :                  W_UABORT	;Put UABORT on stack
87d5 : 865541424f52d4   	DB	$86,'UABOR','T'+$80
87dc : ca87             	DW	W_URW
87de :                  C_UABORT
87de : e385             	DW	X_USER			;Put next word on stack then do next
87e0 : 5a00             	DW	UABORT-SYSTEM
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   25
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

                        
87e2 :                  W_RAF
87e2 : 835241c6         	DB	$83,'RA','F'+$80
87e6 : d587             	DW	W_UABORT
87e8 :                  C_RAF
87e8 : e385             	DW	X_USER			;Put next word on stack then do next
87ea : 6800             	DW	RAF-SYSTEM
                        
87ec :                  W_RBC
87ec : 835242c3         	DB	$83,'RB','C'+$80
87f0 : e287             	DW	W_RAF
87f2 :                  C_RBC
87f2 : e385             	DW	X_USER			;Put next word on stack then do next
87f4 : 6a00             	DW	RBC-SYSTEM
                        
87f6 :                  W_RDE
87f6 : 835244c5         	DB	$83,'RD','E'+$80
87fa : ec87             	DW	W_RBC
87fc :                  C_RDE
87fc : e385             	DW	X_USER			;Put next word on stack then do next
87fe : 6c00             	DW	RDE-SYSTEM
                        
8800 :                  W_RHL
8800 : 835248cc         	DB	$83,'RH','L'+$80
8804 : f687             	DW	W_RDE
8806 :                  C_RHL
8806 : e385             	DW	X_USER			;Put next word on stack then do next
8808 : 6e00             	DW	RHL-SYSTEM
                        
880a :                  W_RIX
880a : 835249d8         	DB	$83,'RI','X'+$80
880e : 0088             	DW	W_RHL
8810 :                  C_RIX
8810 : e385             	DW	X_USER			;Put next word on stack then do next
8812 : 7000             	DW	RIX-SYSTEM
                        
8814 :                  W_RIY
8814 : 835249d9         	DB	$83,'RI','Y'+$80
8818 : 0a88             	DW	W_RIX
881a :                  C_RIY
881a : e385             	DW	X_USER			;Put next word on stack then do next
881c : 7200             	DW	RIY-SYSTEM
                        
881e :                  W_RAF2
881e : 84524146ac       	DB	$84,'RAF',$2C+$80
8823 : 1488             	DW	W_RIY
8825 :                  C_RAF2
8825 : e385             	DW	X_USER			;Put next word on stack then do next
8827 : 7400             	DW	RAF2-SYSTEM
                        
8829 :                  W_RBC2
8829 : 84524243ac       	DB	$84,'RBC',$2C+$80
882e : 1e88             	DW	W_RAF2
8830 :                  C_RBC2
8830 : e385             	DW	X_USER			;Put next word on stack then do next
8832 : 7600             	DW	RBC2-SYSTEM
                        
8834 :                  W_RDE2
8834 : 84524445ac       	DB	$84,'RDE',$2C+$80
8839 : 2988             	DW	W_RBC2
883b :                  C_RDE2
883b : e385             	DW	X_USER			;Put next word on stack then do next
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   26
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

883d : 7800             	DW	RDE2-SYSTEM
                        
883f :                  W_RHL2
883f : 8452484cac       	DB	$84,'RHL',$2C+$80
8844 : 3488             	DW	W_RDE2
8846 :                  C_RHL2
8846 : e385             	DW	X_USER			;Put next word on stack then do next
8848 : 7a00             	DW	RHL2-SYSTEM
                        
884a :                  W_RA
884a : 8252c1           	DB	$82,'R','A'+$80
884d : 3f88             	DW	W_RHL2
884f :                  C_RA
884f : e385             	DW	X_USER			;Put next word on stack then do next
8851 : 6900             	DW	RAF+1-SYSTEM
                        
8853 :                  W_RF
8853 : 8252c6           	DB	$82,'R','F'+$80
8856 : 4a88             	DW	W_RA
8858 :                  C_RF
8858 : e385             	DW	X_USER			;Put next word on stack then do next
885a : 6800             	DW	RAF-SYSTEM
                        
885c :                  W_RB
885c : 8252c2           	DB	$82,'R','B'+$80
885f : 5388             	DW	W_RF
8861 :                  C_RB
8861 : e385             	DW	X_USER			;Put next word on stack then do next
8863 : 6b00             	DW	RBC+1-SYSTEM
                        
8865 :                  W_RC
8865 : 8252c3           	DB	$82,'R','C'+$80
8868 : 5c88             	DW	W_RB
886a :                  C_RC
886a : e385             	DW	X_USER			;Put next word on stack then do next
886c : 6a00             	DW	RBC-SYSTEM
                        
886e :                  W_RD
886e : 8252c4           	DB	$82,'R','D'+$80
8871 : 6588             	DW	W_RC
8873 :                  C_RD
8873 : e385             	DW	X_USER			;Put next word on stack then do next
8875 : 6d00             	DW	RDE+1-SYSTEM
                        
8877 :                  W_RE
8877 : 8252c5           	DB	$82,'R','E'+$80
887a : 6e88             	DW	W_RD
887c :                  C_RE
887c : e385             	DW	X_USER			;Put next word on stack then do next
887e : 6c00             	DW	RDE-SYSTEM
                        
8880 :                  W_RH
8880 : 8252c8           	DB	$82,'R','H'+$80
8883 : 7788             	DW	W_RE
8885 :                  C_RH
8885 : e385             	DW	X_USER			;Put next word on stack then do next
8887 : 6f00             	DW	RHL+1-SYSTEM
                        
8889 :                  W_RL
8889 : 8252cc           	DB	$82,'R','L'+$80
888c : 8088             	DW	W_RH
888e :                  C_RL
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   27
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

888e : e385             	DW	X_USER			;Put next word on stack then do next
8890 : 6e00             	DW	RHL-SYSTEM
                        
8892 :                  W_CALL
8892 : 8443414ccc       	DB	$84,'CAL','L'+$80
8897 : 8988             	DW	W_RL
8899 :                  C_CALL
8899 : 9b88             	DW	2+$			;Vector to code
889b : e1               	POP	HL			;Address of routine CALLed
889c : d5               	PUSH	DE			;Save register
889d : c5               	PUSH	BC			;Save register
889e : 3ec3             	LD	A,$C3			;Hex code for JMP
88a0 : 327dfe           	LD	(JPCODE),A		;Save it
88a3 : 227efe           	LD	(JPVECT),HL		;Save jump vector
88a6 : 2a68fe           	LD	HL,(RAF)		;Get register AF
88a9 : e5               	PUSH	HL			;Onto stack
88aa : f1               	POP	AF			;POP into AF
88ab : ed4b6afe         	LD	BC,(RBC)		;Get register BC
88af : ed5b6cfe         	LD	DE,(RDE)		;Get register DE
88b3 : 2a6efe           	LD	HL,(RHL)		;Get register HL
88b6 : dd2a70fe         	LD	IX,(RIX)		;Get register IX
88ba : fd2a72fe         	LD	IY,(RIY)		;Get register IY
88be : cd7dfe           	CALL	JPCODE			;Call jump to code
88c1 : fd2272fe         	LD	(RIY),IY		;Save register IY
88c5 : dd2270fe         	LD	(RIX),IX		;Save register IX
88c9 : ed436afe         	LD	(RBC),BC		;Save register BC
88cd : ed536cfe         	LD	(RDE),DE		;Save register DE
88d1 : 226efe           	LD	(RHL),HL		;Save register HL
88d4 : f5               	PUSH	AF			;Save register AF
88d5 : e1               	POP	HL			;Into HL
88d6 : 2268fe           	LD	(RAF),HL		;Into memory
88d9 : c1               	POP	BC			;Restore BC
88da : d1               	POP	DE			;Restore DE
88db : c36680           	JP	NEXT			;
                        
88de :                  W_1PLUS		;1 plus
88de : 8231ab           	DB	$82,'1','+'+$80
88e1 : 9288             	DW	W_CALL
88e3 :                  C_1PLUS
88e3 : e588             	DW	2+$			;Vector to code
88e5 : e1               	POP	HL			; get n
88e6 : 23               	INC	HL			; add 1
88e7 : c36580           	JP	NEXTS1			; save result & NEXT
                        
88ea :                  W_2PLUS		;2 plus
88ea : 8232ab           	DB	$82,'2','+'+$80
88ed : de88             	DW	W_1PLUS
88ef :                  C_2PLUS
88ef : f188             	DW	2+$			;Vector to code
88f1 : e1               	POP	HL			; get n
88f2 : 23               	INC	HL			; add 1
88f3 : 23               	INC	HL			; add 2
88f4 : c36580           	JP	NEXTS1			; save result & NEXT
                        
88f7 :                  W_1MINUS	;1 minus
88f7 : 8231ad           	DB	$82,'1','-'+$80
88fa : ea88             	DW	W_2PLUS
88fc :                  C_1MINUS
88fc : fe88             	DW	2+$			;Vector to code
88fe : e1               	POP	HL			; get n
88ff : 2b               	DEC	HL			; add 1
8900 : c36580           	JP	NEXTS1			; save result & NEXT
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   28
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

                        
8903 :                  W_2MINUS	;2 minus
8903 : 8232ad           	DB	$82,'2','-'+$80
8906 : f788             	DW	W_1MINUS
8908 :                  C_2MINUS
8908 : 0a89             	DW	2+$			;Vector to code
890a : e1               	POP	HL			; get n
890b : 2b               	DEC	HL			; subtract 1
890c : 2b               	DEC	HL			; subtract 2
890d : c36580           	JP	NEXTS1			; save result & NEXT
                        
8910 :                  W_HERE		;Dictionary pointer onto stack
8910 : 84484552c5       	DB	$84,'HER','E'+$80
8915 : 0389             	DW	W_2MINUS
8917 :                  C_HERE
8917 : 7c85             	DW	E_COLON			;Interpret following word sequence
8919 : ad86             	DW	C_DP			;Dictionary pointer addr on stack
891b : 0285             	DW	C_FETCH			;Get word from addr on stack
891d : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
891f :                  W_ALLOT
891f : 85414c4c4fd4     	DB	$85,'ALLO','T'+$80
8925 : 1089             	DW	W_HERE
8927 :                  C_ALLOT
8927 : 7c85             	DW	E_COLON			;Interpret following word sequence
8929 : ad86             	DW	C_DP			;Dictionary pointer addr on stack
892b : dd84             	DW	C_PLUSSTORE		;Add n1 to addr
892d : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
892f :                  W_COMMA		;Reserve 2 bytes and save n
892f : 81ac             	DB	$81,','+$80
8931 : 1f89             	DW	W_ALLOT
8933 :                  C_COMMA
8933 : 7c85             	DW	E_COLON			;Interpret following word sequence
8935 : 1789             	DW	C_HERE			;Next free dictionary pointer onto stack
8937 : 3985             	DW	C_STORE			;Store word at addr
8939 : 0386             	DW	C_2			;
893b : 2789             	DW	C_ALLOT			;Move pointer
893d : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
893f :                  W_CCOMMA
893f : 8243ac           	DB	$82,'C',','+$80
8942 : 2f89             	DW	W_COMMA
8944 :                  C_CCOMMA
8944 : 7c85             	DW	E_COLON			;Interpret following word sequence
8946 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8948 : 4885             	DW	C_CSTORE		;Store byte at addr
894a : fb85             	DW	C_1			;Put 1 on stack
894c : 2789             	DW	C_ALLOT
894e : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8950 :                  W_MINUS
8950 : 81ad             	DB	$81,'-'+$80
8952 : 3f89             	DW	W_CCOMMA
8954 :                  C_MINUS
8954 : 5689             	DW	2+$			;Vector to code
8956 : d1               	POP	DE			; get n1
8957 : e1               	POP	HL			; get n2
8958 : cd5e89           	CALL	MINUS16			; call subtract routine
895b : c36580           	JP	NEXTS1			; save & NEXT
                        
895e :                  MINUS16
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   29
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

895e : 7d               	LD	A,L			; gel low byte
895f : 93               	SUB	E			; subtract low bytes
8960 : 6f               	LD	L,A			; save low byte result
8961 : 7c               	LD	A,H			; get high byte
8962 : 9a               	SBC	A,D			; subtract high bytes
8963 : 67               	LD	H,A			; save high byte result
8964 : c9               	RET				;
                        
8965 :                  W_EQUALS
8965 : 81bd             	DB	$81,'='+$80
8967 : 5089             	DW	W_MINUS
8969 :                  C_EQUALS
8969 : 7c85             	DW	E_COLON			;Interpret following word sequence
896b : 5489             	DW	C_MINUS
896d : e783             	DW	C_0EQUALS		;=0
896f : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8971 :                  W_LESSTHAN
8971 : 81bc             	DB	$81,'<'+$80
8973 : 6589             	DW	W_EQUALS
8975 :                  C_LESSTHAN
8975 : 7789             	DW	2+$			;Vector to code
8977 : d1               	POP	DE
8978 : e1               	POP	HL
8979 : 7a               	LD	A,D
897a : ac               	XOR	H
897b : fa8189           	JP	M,J298C
897e : cd5e89           	CALL	MINUS16
8981 :                  J298C
8981 : 24               	INC	H
8982 : 25               	DEC	H
8983 : fa8c89           	JP	M,J2997
8986 : 210000           	LD	HL,0000
8989 : c36580           	JP	NEXTS1			;Save & NEXT
898c :                  J2997
898c : 210100           	LD	HL,0001
898f : c36580           	JP	NEXTS1			;Save & NEXT
                        
8992 :                  W_ULESS		;IF stack-1 < stack_top leave true flag
8992 : 8255bc           	DB	$82,'U','<'+$80
8995 : 7189             	DW	W_LESSTHAN
8997 :                  C_ULESS
8997 : 7c85             	DW	E_COLON			;Interpret following word sequence
8999 : bd84             	DW	C_2DUP			;Dup top 2 values on stack
899b : 2b83             	DW	C_XOR			;Exclusive OR them
899d : 0284             	DW	C_0LESS			;Less than 0
899f : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
89a1 : 0c00             	DW	B0000-$			;000Ch
89a3 : 8684             	DW	C_DROP			;Drop top value from stack
89a5 : 0284             	DW	C_0LESS			;Less than 0
89a7 : e783             	DW	C_0EQUALS		;=0
89a9 : b080             	DW	C_BRANCH		;Add following offset to BC
89ab : 0600             	DW	B0001-$			;0006h
89ad :                  B0000
89ad : 5489             	DW	C_MINUS
89af : 0284             	DW	C_0LESS			;Less than 0
89b1 :                  B0001
89b1 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
89b3 :                  W_GREATER
89b3 : 81be             	DB	$81,'>'+$80
89b5 : 9289             	DW	W_ULESS
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   30
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

89b7 :                  C_GREATER
89b7 : 7c85             	DW	E_COLON			;Interpret following word sequence
89b9 : a284             	DW	C_SWAP			;Swap top 2 values on stack
89bb : 7589             	DW	C_LESSTHAN
89bd : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
89bf :                  W_ROT		;3rd valu down to top of stack
89bf : 83524fd4         	DB	$83,'RO','T'+$80
89c3 : b389             	DW	W_GREATER
89c5 :                  C_ROT
89c5 : c789             	DW	2+$			;Vector to code
89c7 : d1               	POP	DE			;Top value
89c8 : e1               	POP	HL			;Next one down
89c9 : e3               	EX	(SP),HL			;Exchange with third
89ca : c36480           	JP	NEXTS2			;Save both & NEXT
                        
89cd :                  W_PICK
89cd : 84504943cb       	DB	$84,'PIC','K'+$80
89d2 : bf89             	DW	W_ROT
89d4 :                  C_PICK
89d4 : 7c85             	DW	E_COLON			;Interpret following word sequence
89d6 : af84             	DW	C_DUP			;Duplicate top value on stack
89d8 : 1384             	DW	C_PLUS			;n1 + n2
89da : 3e83             	DW	C_SPFETCH		;Stack pointer onto stack
89dc : 1384             	DW	C_PLUS			;n1 + n2
89de : 0285             	DW	C_FETCH			;Get word from addr on stack
89e0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
89e2 :                  W_SPACE
89e2 : 8553504143c5     	DB	$85,'SPAC','E'+$80
89e8 : cd89             	DW	W_PICK
89ea :                  C_SPACE
89ea : 7c85             	DW	E_COLON			;Interpret following word sequence
89ec : 1486             	DW	C_BL			;Leaves ASCII for space on stack
89ee : 1582             	DW	C_EMIT			;Output CHR from stack
89f0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
89f2 :                  W_QUERYDUP
89f2 : 843f4455d0       	DB	$84,'?DU','P'+$80
89f7 : e289             	DW	W_SPACE
89f9 :                  C_QUERYDUP
89f9 : 7c85             	DW	E_COLON			;Interpret following word sequence
89fb : af84             	DW	C_DUP			;Duplicate top value on stack
89fd : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
89ff : 0400             	DW	B0002-$			;$0004
8a01 : af84             	DW	C_DUP			;Duplicate top value on stack
8a03 :                  B0002
8a03 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8a05 :                  W_TRAVERSE
8a05 : 88545241564552.. 	DB	$88,'TRAVERS','E'+$80
8a0e : f289             	DW	W_QUERYDUP
8a10 :                  C_TRAVERSE
8a10 : 7c85             	DW	E_COLON			;Interpret following word sequence
8a12 : a284             	DW	C_SWAP			;Swap top 2 values on stack
8a14 :                  B0054
8a14 : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
8a16 : 1384             	DW	C_PLUS			;n1 + n2
8a18 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8a1a : 7f00             	DW	$007F
8a1c : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
8a1e : 1185             	DW	C_CFETCH		;Get byte from addr on stack
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   31
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8a20 : 7589             	DW	C_LESSTHAN
8a22 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8a24 : f0ff             	DW	B0054-$			;FFF0h
8a26 : a284             	DW	C_SWAP			;Swap top 2 values on stack
8a28 : 8684             	DW	C_DROP			;Drop top value from stack
8a2a : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8a2c :                  W_LATEST
8a2c : 864c41544553d4   	DB	$86,'LATES','T'+$80
8a33 : 058a             	DW	W_TRAVERSE
8a35 :                  C_LATEST
8a35 : 7c85             	DW	E_COLON			;Interpret following word sequence
8a37 : 0d87             	DW	C_CURRENT
8a39 : 0285             	DW	C_FETCH			;Get word from addr on stack
8a3b : 0285             	DW	C_FETCH			;Get word from addr on stack
8a3d : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8a3f :                  W_LFA
8a3f : 834c46c1         	DB	$83,'LF','A'+$80
8a43 : 2c8a             	DW	W_LATEST
8a45 :                  C_LFA
8a45 : 7c85             	DW	E_COLON			;Interpret following word sequence
8a47 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8a49 : 0400             	DW	$0004
8a4b : 5489             	DW	C_MINUS
8a4d : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8a4f :                  W_CFA
8a4f : 834346c1         	DB	$83,'CF','A'+$80
8a53 : 3f8a             	DW	W_LFA
8a55 :                  C_CFA
8a55 : 578a             	DW	2+$			;Vector to code
8a57 : e1               	POP	HL			; get n
8a58 : 2b               	DEC	HL			; subtract 1
8a59 : 2b               	DEC	HL			; subtract 2
8a5a : c36580           	JP	NEXTS1			; save result & NEXT
8a5d :                  W_NFA
8a5d : 834e46c1         	DB	$83,'NF','A'+$80
8a61 : 4f8a             	DW	W_CFA
8a63 :                  C_NFA
8a63 : 7c85             	DW	E_COLON			;Interpret following word sequence
8a65 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8a67 : 0500             	DW	$0005
8a69 : 5489             	DW	C_MINUS
8a6b : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8a6d : ffff             	DW	$FFFF
8a6f : 108a             	DW	C_TRAVERSE
8a71 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8a73 :                  W_PFA					;Convert NFA to PFA
8a73 : 835046c1         	DB	$83,'PF','A'+$80
8a77 : 5d8a             	DW	W_NFA
8a79 :                  C_PFA
8a79 : 7c85             	DW	E_COLON			;Interpret following word sequence
8a7b : fb85             	DW	C_1			;Traverse up memory
8a7d : 108a             	DW	C_TRAVERSE		;End of name on stack
8a7f : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8a81 : 0500             	DW	$0005			;Offset to start of word code
8a83 : 1384             	DW	C_PLUS			;n1 + n2
8a85 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8a87 :                  W_CSPSTORE
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   32
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8a87 : 84214353d0       	DB	$84,'!CS','P'+$80
8a8c : 738a             	DW	W_PFA
8a8e :                  C_CSPSTORE
8a8e : 7c85             	DW	E_COLON			;Interpret following word sequence
8a90 : 3e83             	DW	C_SPFETCH		;Stack pointer onto stack
8a92 : 4287             	DW	C_CSP			;Push check stack pointer addr
8a94 : 3985             	DW	C_STORE			;Store word at addr
8a96 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8a98 :                  W_QERROR
8a98 : 863f4552524fd2   	DB	$86,'?ERRO','R'+$80
8a9f : 878a             	DW	W_CSPSTORE
8aa1 :                  C_QERROR
8aa1 : 7c85             	DW	E_COLON			;Interpret following word sequence
8aa3 : a284             	DW	C_SWAP			;Swap top 2 values on stack
8aa5 : c880             	DW	C_0BRANCH		;Branch if no error
8aa7 : 0800             	DW	B0003-$			;0008h
8aa9 : 328f             	DW	C_ERROR
8aab : b080             	DW	C_BRANCH		;Add following offset to BC
8aad : 0400             	DW	B0004-$			;$0004
8aaf :                  B0003
8aaf : 8684             	DW	C_DROP			;Drop error no.
8ab1 :                  B0004
8ab1 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8ab3 :                  W_QCOMP		;Error if not in compile mode
8ab3 : 853f434f4dd0     	DB	$85,'?COM','P'+$80
8ab9 : 988a             	DW	W_QERROR
8abb :                  C_QCOMP
8abb : 7c85             	DW	E_COLON			;Interpret following word sequence
8abd : 1987             	DW	C_STATE			;Push STATE addr
8abf : 0285             	DW	C_FETCH			;Get word from addr on stack
8ac1 : e783             	DW	C_0EQUALS		;=0
8ac3 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8ac5 : 1100             	DW	$0011			;Error message number
8ac7 : a18a             	DW	C_QERROR		;Error if state <> 0
8ac9 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8acb :                  W_QEXEC		;Error not if not in execute mode
8acb : 853f455845c3     	DB	$85,'?EXE','C'+$80
8ad1 : b38a             	DW	W_QCOMP
8ad3 :                  C_QEXEC
8ad3 : 7c85             	DW	E_COLON			;Interpret following word sequence
8ad5 : 1987             	DW	C_STATE			;Push STATE addr
8ad7 : 0285             	DW	C_FETCH			;Get word from addr on stack
8ad9 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8adb : 1200             	DW	$0012			;Error not if not in execute mode
8add : a18a             	DW	C_QERROR		;
8adf : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8ae1 :                  W_QPAIRS
8ae1 : 863f50414952d3   	DB	$86,'?PAIR','S'+$80
8ae8 : cb8a             	DW	W_QEXEC
8aea :                  C_QPAIRS
8aea : 7c85             	DW	E_COLON			;Interpret following word sequence
8aec : 5489             	DW	C_MINUS
8aee : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8af0 : 1300             	DW	$0013
8af2 : a18a             	DW	C_QERROR
8af4 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8af6 :                  W_WHATSTACK	;Check stack pointer, error if not ok
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   33
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8af6 : 843f4353d0       	DB	$84,'?CS','P'+$80
8afb : e18a             	DW	W_QPAIRS
8afd :                  C_WHATSTACK
8afd : 7c85             	DW	E_COLON			;Interpret following word sequence
8aff : 3e83             	DW	C_SPFETCH		;Stack pointer onto stack
8b01 : 4287             	DW	C_CSP			;Push check stack pointer addr
8b03 : 0285             	DW	C_FETCH			;Get check stack pointer
8b05 : 5489             	DW	C_MINUS			;If ok then result is 0
8b07 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8b09 : 1400             	DW	$0014			;Error no if not ok
8b0b : a18a             	DW	C_QERROR		;Error if stack top -1 <> 0
8b0d : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8b0f :                  W_QLOADING
8b0f : 883f4c4f414449.. 	DB	$88,'?LOADIN','G'+$80
8b18 : f68a             	DW	W_WHATSTACK
8b1a :                  C_QLOADING
8b1a : 7c85             	DW	E_COLON			;Interpret following word sequence
8b1c : c686             	DW	C_BLK
8b1e : 0285             	DW	C_FETCH			;Get word from addr on stack
8b20 : e783             	DW	C_0EQUALS		;=0
8b22 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8b24 : 1600             	DW	$0016
8b26 : a18a             	DW	C_QERROR
8b28 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8b2a :                  W_COMPILE
8b2a : 87434f4d50494cc5 	DB	$87,'COMPIL','E'+$80
8b32 : 0f8b             	DW	W_QLOADING
8b34 :                  C_COMPILE
8b34 : 7c85             	DW	E_COLON			;Interpret following word sequence
8b36 : bb8a             	DW	C_QCOMP			;Error if not in compile mode
8b38 : cb83             	DW	C_RMOVE			;Move word from return to data stack
8b3a : af84             	DW	C_DUP			;Bump return address and put back
8b3c : ef88             	DW	C_2PLUS			;
8b3e : b583             	DW	C_MOVER			;
8b40 : 0285             	DW	C_FETCH			;Get word from addr on stack
8b42 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
8b44 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8b46 :                  W_LEFTBRKT	;Set STATE to execute
8b46 : 81db             	DB	$81,'['+$80
8b48 : 2a8b             	DW	W_COMPILE
8b4a :                  C_LEFTBRKT
8b4a : 7c85             	DW	E_COLON			;Interpret following word sequence
8b4c : f385             	DW	C_ZERO			;Put zero on stack
8b4e : 1987             	DW	C_STATE			;Push STATE addr
8b50 : 3985             	DW	C_STORE			;Store word at addr
8b52 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8b54 :                  W_RIGHTBRKT	;Set STATE to compile
8b54 : 81dd             	DB	$81,']'+$80
8b56 : 468b             	DW	W_LEFTBRKT
8b58 :                  C_RIGHTBRKT
8b58 : 7c85             	DW	E_COLON			;Interpret following word sequence
8b5a : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8b5c : c000             	DW	$00C0
8b5e : 1987             	DW	C_STATE			;Push STATE addr
8b60 : 3985             	DW	C_STORE			;Set STATE to execute
8b62 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8b64 :                  W_SMUDGE
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   34
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8b64 : 86534d554447c5   	DB	$86,'SMUDG','E'+$80
8b6b : 548b             	DW	W_RIGHTBRKT
8b6d :                  C_SMUDGE
8b6d : 7c85             	DW	E_COLON			;Interpret following word sequence
8b6f : 358a             	DW	C_LATEST		;Push top words NFA
8b71 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8b73 : 2000             	DW	$0020
8b75 : f484             	DW	C_TOGGLE		;XOR (addr) with byte
8b77 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8b79 :                  W_HEX
8b79 : 834845d8         	DB	$83,'HE','X'+$80
8b7d : 648b             	DW	W_SMUDGE
8b7f :                  C_HEX
8b7f : 7c85             	DW	E_COLON			;Interpret following word sequence
8b81 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8b83 : 1000             	DW	$0010
8b85 : 2487             	DW	C_BASE			;Put BASE addr on stack
8b87 : 3985             	DW	C_STORE			;Store word at addr
8b89 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8b8b :                  W_DECIMAL	;Sets decimal mode
8b8b : 87444543494d41cc 	DB	$87,'DECIMA','L'+$80
8b93 : 798b             	DW	W_HEX
8b95 :                  C_DECIMAL
8b95 : 7c85             	DW	E_COLON			;Interpret following word sequence
8b97 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8b99 : 0a00             	DW	$000A			;Sets decimal value
8b9b : 2487             	DW	C_BASE			;Put BASE addr on stack
8b9d : 3985             	DW	C_STORE			;Store word at addr
8b9f : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8ba1 :                  W_CCODE		;Stop compillation & terminate word
8ba1 : 873c3b434f4445be 	DB	$87,'<;CODE','>'+$80
8ba9 : 8b8b             	DW	W_DECIMAL
8bab :                  C_CCODE
8bab : 7c85             	DW	E_COLON			;Interpret following word sequence
8bad : cb83             	DW	C_RMOVE			;Move word from return to data stack
8baf : 358a             	DW	C_LATEST		;Push top words NFA
8bb1 : 798a             	DW	C_PFA			;Convert NFA to PFA
8bb3 : 558a             	DW	C_CFA			;Convert PFA to CFA
8bb5 : 3985             	DW	C_STORE			;Store word at addr
8bb7 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8bb9 :                  W_SCCODE
8bb9 : c53b434f44c5     	DB	$C5,';COD','E'+$80
8bbf : a18b             	DW	W_CCODE
8bc1 :                  C_SCCODE
8bc1 : 7c85             	DW	E_COLON			;Interpret following word sequence
8bc3 : fd8a             	DW	C_WHATSTACK		;Check stack pointer, error if not ok
8bc5 : 348b             	DW	C_COMPILE		;Compile next word into dictionary
8bc7 : ab8b             	DW	C_CCODE
8bc9 : 4a8b             	DW	C_LEFTBRKT		;Set STATE to execute
8bcb : 689a             	DW	C_TASK
8bcd : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8bcf :                  W_CREATE
8bcf : 864352454154c5   	DB	$86,'CREAT','E'+$80
8bd6 : b98b             	DW	W_SCCODE
8bd8 :                  C_CREATE
8bd8 : 7c85             	DW	E_COLON			;Interpret following word sequence
8bda : f385             	DW	C_ZERO			;Put zero on stack
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   35
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8bdc : ab85             	DW	C_CONSTANT
8bde : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8be0 :                  W_DOES
8be0 : 85444f4553be     	DB	$85,'DOES','>'+$80
8be6 : cf8b             	DW	W_CREATE
8be8 :                  C_DOES
8be8 : 7c85             	DW	E_COLON			;Interpret following word sequence
8bea : cb83             	DW	C_RMOVE			;Move word from return to data stack
8bec : 358a             	DW	C_LATEST		;Push top words NFA
8bee : 798a             	DW	C_PFA			;Convert NFA to PFA
8bf0 : 3985             	DW	C_STORE			;Store word at addr
8bf2 : ab8b             	DW	C_CCODE			;Execute following machine code
                        
8bf4 :                  X_DOES
8bf4 : 2a46fe           	LD	HL,(RPP)		;Get return stack pointer
8bf7 : 2b               	DEC	HL			;Push next pointer
8bf8 : 70               	LD	(HL),B			;
8bf9 : 2b               	DEC	HL			;
8bfa : 71               	LD	(HL),C			;
8bfb : 2246fe           	LD	(RPP),HL
8bfe : 13               	INC	DE
8bff : eb               	EX	DE,HL
8c00 : 4e               	LD	C,(HL)
8c01 : 23               	INC	HL
8c02 : 46               	LD	B,(HL)
8c03 : 23               	INC	HL
8c04 : c36580           	JP	NEXTS1			;Save & NEXT
                        
8c07 :                  W_COUNT		;Convert string at addr to addr + length
8c07 : 85434f554ed4     	DB	$85,'COUN','T'+$80
8c0d : e08b             	DW	W_DOES
8c0f :                  C_COUNT
8c0f : 7c85             	DW	E_COLON			;Interpret following word sequence
8c11 : af84             	DW	C_DUP			;Duplicate address
8c13 : e388             	DW	C_1PLUS			;Add 1 (points to string start)
8c15 : a284             	DW	C_SWAP			;Get address back
8c17 : 1185             	DW	C_CFETCH		;Get byte from addr on stack
8c19 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8c1b :                  W_TYPE		;Output n bytes from addr
8c1b : 84545950c5       	DB	$84,'TYP','E'+$80
8c20 : 078c             	DW	W_COUNT
8c22 :                  C_TYPE
8c22 : 7c85             	DW	E_COLON			;Interpret following word sequence
8c24 : f989             	DW	C_QUERYDUP		;Copy length if length <> 0
8c26 : c880             	DW	C_0BRANCH		;Branch if length = 0
8c28 : 1800             	DW	B0005-$			;0018h
8c2a : 7784             	DW	C_OVER			;Copy address to stack top
8c2c : 1384             	DW	C_PLUS			;Add to length
8c2e : a284             	DW	C_SWAP			;Swap top 2 values on stack
8c30 : 2281             	DW	C_LDO			;Put start & end loop values on RPP
8c32 :                  B004F
8c32 : 3e81             	DW	C_I			;Copy LOOP index to data stack
8c34 : 1185             	DW	C_CFETCH		;Get byte from string
8c36 : 1582             	DW	C_EMIT			;Output CHR from stack
8c38 : dd80             	DW	C_LLOOP			;Increment loop & branch if not done
8c3a : f8ff             	DW	B004F-$			;FFF8h
8c3c : b080             	DW	C_BRANCH		;Done so branch to next
8c3e : 0400             	DW	B0006-$			;$0004
8c40 :                  B0005
8c40 : 8684             	DW	C_DROP			;Drop string address
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   36
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8c42 :                  B0006
8c42 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8c44 :                  W_TRAILING
8c44 : 892d545241494c.. 	DB	$89,'-TRAILIN','G'+$80
8c4e : 1b8c             	DW	W_TYPE
8c50 :                  C_TRAILING
8c50 : 7c85             	DW	E_COLON			;Interpret following word sequence
8c52 : af84             	DW	C_DUP			;Duplicate top value on stack
8c54 : f385             	DW	C_ZERO			;Put zero on stack
8c56 : 2281             	DW	C_LDO			;Put start & end loop values on RPP
8c58 :                  B0009
8c58 : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
8c5a : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
8c5c : 1384             	DW	C_PLUS			;n1 + n2
8c5e : fb85             	DW	C_1			;Put 1 on stack
8c60 : 5489             	DW	C_MINUS
8c62 : 1185             	DW	C_CFETCH		;Get byte from addr on stack
8c64 : 1486             	DW	C_BL			;Leaves ASCII for space on stack
8c66 : 5489             	DW	C_MINUS
8c68 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8c6a : 0800             	DW	B0007-$			;0008h
8c6c : a183             	DW	C_LEAVE			;Quit loop by making index = limit
8c6e : b080             	DW	C_BRANCH		;Add following offset to BC
8c70 : 0600             	DW	B0008-$			;0006h
8c72 :                  B0007
8c72 : fb85             	DW	C_1			;Put 1 on stack
8c74 : 5489             	DW	C_MINUS
8c76 :                  B0008
8c76 : dd80             	DW	C_LLOOP			;Increment loop & branch if not done
8c78 : e0ff             	DW	B0009-$			;FFE0h
8c7a : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8c7c :                  W_CQUOTE	;Output following string
8c7c : 843c2e22be       	DB	$84,'<.',$22,'>'+$80
8c81 : 448c             	DW	W_TRAILING
8c83 :                  C_CQUOTE
8c83 : 7c85             	DW	E_COLON			;Interpret following word sequence
8c85 : e083             	DW	C_RFETCH		;Copy return stack top to data stack
8c87 : 0f8c             	DW	C_COUNT			;Convert string at addr to addr + length
8c89 : af84             	DW	C_DUP			;Duplicate top value on stack
8c8b : e388             	DW	C_1PLUS			;1 plus
8c8d : cb83             	DW	C_RMOVE			;Move word from return to data stack
8c8f : 1384             	DW	C_PLUS			;Add length of string +1
8c91 : b583             	DW	C_MOVER			;Move value from data to return stack
8c93 : 228c             	DW	C_TYPE			;Output n bytes from addr
8c95 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8c97 :                  W_QUOTE		;Accept following text
8c97 : c22ea2           	DB	$C2,'.',$22+$80
8c9a : 7c8c             	DW	W_CQUOTE
8c9c :                  C_QUOTE
8c9c : 7c85             	DW	E_COLON			;Interpret following word sequence
8c9e : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8ca0 : 2200             	DW	$0022
8ca2 : 1987             	DW	C_STATE			;Push STATE addr
8ca4 : 0285             	DW	C_FETCH			;Get word from addr on stack
8ca6 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8ca8 : 1200             	DW	B000A-$			;0012h
8caa : 348b             	DW	C_COMPILE		;Compile next word into dictionary
8cac : 838c             	DW	C_CQUOTE		;
8cae : 058e             	DW	C_WORD
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   37
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8cb0 : 1185             	DW	C_CFETCH		;Get byte from addr on stack
8cb2 : e388             	DW	C_1PLUS			;1 plus
8cb4 : 2789             	DW	C_ALLOT
8cb6 : b080             	DW	C_BRANCH		;Add following offset to BC
8cb8 : 0800             	DW	B000B-$			;0008h
8cba :                  B000A
8cba : 058e             	DW	C_WORD
8cbc : 0f8c             	DW	C_COUNT			;Convert string at addr to addr + length
8cbe : 228c             	DW	C_TYPE			;Output n bytes from addr
8cc0 :                  B000B
8cc0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8cc2 :                  W_EXPECT
8cc2 : 864558504543d4   	DB	$86,'EXPEC','T'+$80
8cc9 : 978c             	DW	W_QUOTE
8ccb :                  C_EXPECT
8ccb : 7c85             	DW	E_COLON			;Interpret following word sequence
8ccd : 7784             	DW	C_OVER			;Copy buffer start addr
8ccf : 1384             	DW	C_PLUS			;Add to length to give start,end
8cd1 : 7784             	DW	C_OVER			;Copy start
8cd3 : 2281             	DW	C_LDO			;Put start & end loop values on RPP
8cd5 :                  B0012
8cd5 : 2b82             	DW	C_KEY			;Wait for key, value on stack
8cd7 : af84             	DW	C_DUP			;Duplicate key value
8cd9 : 8c80             	DW	C_LIT			;Push backspace addr
8cdb : 1e80             	DW	BACKSPACE		;
8cdd : 0285             	DW	C_FETCH			;Get backspace value
8cdf : 6989             	DW	C_EQUALS		;Was it backspace ?
8ce1 : c880             	DW	C_0BRANCH		;If not then jump
8ce3 : 2a00             	DW	B000C-$			;002Ah
8ce5 : 8684             	DW	C_DROP			;Drop top value from stack
8ce7 : af84             	DW	C_DUP			;Duplicate top value on stack
8ce9 : 3e81             	DW	C_I			;Copy LOOP index to data stack
8ceb : 6989             	DW	C_EQUALS
8ced : af84             	DW	C_DUP			;Duplicate top value on stack
8cef : cb83             	DW	C_RMOVE			;Move word from return to data stack
8cf1 : 0386             	DW	C_2
8cf3 : 5489             	DW	C_MINUS
8cf5 : 1384             	DW	C_PLUS			;n1 + n2
8cf7 : b583             	DW	C_MOVER			;Move value from data to return stack
8cf9 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8cfb : 0a00             	DW	B000D-$			;000Ah
8cfd : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8cff : 0700             	DW	$0007
8d01 : b080             	DW	C_BRANCH		;Add following offset to BC
8d03 : 0600             	DW	B000E-$			;0006h
8d05 :                  B000D
8d05 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8d07 : 0800             	DW	$0008
8d09 :                  B000E
8d09 : b080             	DW	C_BRANCH		;Add following offset to BC
8d0b : 2800             	DW	B000F-$			;0028h
8d0d :                  B000C
8d0d : af84             	DW	C_DUP			;Duplicate key value
8d0f : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8d11 : 0d00             	DW	$000D			;CR
8d13 : 6989             	DW	C_EQUALS		;Was it cariage return
8d15 : c880             	DW	C_0BRANCH		;If not then jump
8d17 : 0e00             	DW	B0010-$			;000Eh
8d19 : a183             	DW	C_LEAVE			;Quit loop by making index = limit
8d1b : 8684             	DW	C_DROP			;Drop top value from stack
8d1d : 1486             	DW	C_BL			;Leaves ASCII for space on stack
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   38
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8d1f : f385             	DW	C_ZERO			;Put zero on stack
8d21 : b080             	DW	C_BRANCH		;Add following offset to BC
8d23 : 0400             	DW	B0011-$			;$0004
8d25 :                  B0010
8d25 : af84             	DW	C_DUP			;Duplicate key value
8d27 :                  B0011
8d27 : 3e81             	DW	C_I			;Copy LOOP index to data stack
8d29 : 4885             	DW	C_CSTORE		;Store byte at addr
8d2b : f385             	DW	C_ZERO			;Put zero on stack
8d2d : 3e81             	DW	C_I			;Copy LOOP index to data stack
8d2f : e388             	DW	C_1PLUS			;1 plus
8d31 : 3985             	DW	C_STORE			;Store word at addr
8d33 :                  B000F
8d33 : 1582             	DW	C_EMIT			;Output CHR from stack
8d35 : dd80             	DW	C_LLOOP			;Increment loop & branch if not done
8d37 : 9eff             	DW	B0012-$			;FF9Eh
8d39 : 8684             	DW	C_DROP			;Drop top value from stack
8d3b : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8d3d :                  W_QUERY
8d3d : 8551554552d9     	DB	$85,'QUER','Y'+$80
8d43 : c28c             	DW	W_EXPECT
8d45 :                  C_QUERY
8d45 : 7c85             	DW	E_COLON			;Interpret following word sequence
8d47 : 7e86             	DW	C_TIB			;Put TIB addr on stack
8d49 : 0285             	DW	C_FETCH			;Get word from addr on stack
8d4b : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8d4d : 5000             	DW	$0050			;Max line length 50h
8d4f : cb8c             	DW	C_EXPECT		;Get line
8d51 : f385             	DW	C_ZERO			;Put zero on stack
8d53 : d086             	DW	C_TOIN			;Current input buffer offset
8d55 : 3985             	DW	C_STORE			;Store word at addr
8d57 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8d59 :                  W_NULL
8d59 : c180             	DB	$C1,$80
8d5b : 3d8d             	DW	W_QUERY
8d5d :                  C_NULL
8d5d : 7c85             	DW	E_COLON			;Interpret following word sequence
8d5f : c686             	DW	C_BLK
8d61 : 0285             	DW	C_FETCH			;Get word from addr on stack
8d63 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8d65 : 2a00             	DW	B0013-$			;002Ah
8d67 : fb85             	DW	C_1			;Put 1 on stack
8d69 : c686             	DW	C_BLK
8d6b : dd84             	DW	C_PLUSSTORE		;Add n1 to addr
8d6d : f385             	DW	C_ZERO			;Put zero on stack
8d6f : d086             	DW	C_TOIN			;Current input buffer offset
8d71 : 3985             	DW	C_STORE			;Store word at addr
8d73 : c686             	DW	C_BLK
8d75 : 0285             	DW	C_FETCH			;Get word from addr on stack
8d77 : 5e86             	DW	C_BSCR			;Number of buffers per block on stack
8d79 : fb85             	DW	C_1			;Put 1 on stack
8d7b : 5489             	DW	C_MINUS
8d7d : 0683             	DW	C_AND			;AND
8d7f : e783             	DW	C_0EQUALS		;=0
8d81 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8d83 : 0800             	DW	B0014-$			;0008h
8d85 : d38a             	DW	C_QEXEC			;Error not if not in execute mode
8d87 : cb83             	DW	C_RMOVE			;Move word from return to data stack
8d89 : 8684             	DW	C_DROP			;Drop top value from stack
8d8b :                  B0014
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   39
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8d8b : b080             	DW	C_BRANCH		;Add following offset to BC
8d8d : 0600             	DW	B0015-$			;0006h
8d8f :                  B0013
8d8f : cb83             	DW	C_RMOVE			;Move word from return to data stack
8d91 : 8684             	DW	C_DROP			;Drop top value from stack
8d93 :                  B0015
8d93 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8d95 :                  W_FILL		;Fill with byte n bytes from addr
8d95 : 8446494ccc       	DB	$84,'FIL','L'+$80
8d9a : 598d             	DW	W_NULL
8d9c :                  C_FILL
8d9c : 9e8d             	DW	2+$			;Vector to code
8d9e : 69               	LD	L,C			;Save BC for now
8d9f : 60               	LD	H,B			;
8da0 : d1               	POP	DE			; get byte
8da1 : c1               	POP	BC			; get n
8da2 : e3               	EX	(SP),HL			; get addr and save BC
8da3 : eb               	EX	DE,HL			;
8da4 :                  NEXT_BYTE
8da4 : 78               	LD	A,B			;Test count
8da5 : b1               	OR	C			;
8da6 : 2806             	JR	Z,NO_COUNT		;If 0 we're done
8da8 : 7d               	LD	A,L			;Byte into A
8da9 : 12               	LD	(DE),A			;Save byte
8daa : 13               	INC	DE			;Next addr
8dab : 0b               	DEC	BC			;Decr count
8dac : 18f6             	JR	NEXT_BYTE		;Loop
8dae :                  NO_COUNT
8dae : c1               	POP	BC			;Get BC back
8daf : c36680           	JP	NEXT
                        
8db2 :                  W_ERASE		;Fill addr & length from stack with 0
8db2 : 8545524153c5     	DB	$85,'ERAS','E'+$80
8db8 : 958d             	DW	W_FILL
8dba :                  C_ERASE
8dba : 7c85             	DW	E_COLON			;Interpret following word sequence
8dbc : f385             	DW	C_ZERO			;Put zero on stack
8dbe : 9c8d             	DW	C_FILL			;Fill with byte n bytes from addr
8dc0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8dc2 :                  W_BLANKS	;Fill addr & length from stack with [SP]
8dc2 : 86424c414e4bd3   	DB	$86,'BLANK','S'+$80
8dc9 : b28d             	DW	W_ERASE
8dcb :                  C_BLANKS
8dcb : 7c85             	DW	E_COLON			;Interpret following word sequence
8dcd : 1486             	DW	C_BL			;Leaves ASCII for space on stack
8dcf : 9c8d             	DW	C_FILL			;Fill with byte n bytes from addr
8dd1 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8dd3 :                  W_HOLD
8dd3 : 84484f4cc4       	DB	$84,'HOL','D'+$80
8dd8 : c28d             	DW	W_BLANKS
8dda :                  C_HOLD
8dda : 7c85             	DW	E_COLON			;Interpret following word sequence
8ddc : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8dde : ffff             	DW	$FFFF
8de0 : 5587             	DW	C_HLD
8de2 : dd84             	DW	C_PLUSSTORE		;Add n1 to addr
8de4 : 5587             	DW	C_HLD
8de6 : 0285             	DW	C_FETCH			;Get word from addr on stack
8de8 : 4885             	DW	C_CSTORE		;Store byte at addr
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   40
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8dea : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8dec :                  W_PAD
8dec : 835041c4         	DB	$83,'PA','D'+$80
8df0 : d38d             	DW	W_HOLD
8df2 :                  C_PAD
8df2 : 7c85             	DW	E_COLON			;Interpret following word sequence
8df4 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8df6 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8df8 : 4400             	DW	$0044
8dfa : 1384             	DW	C_PLUS			;n1 + n2
8dfc : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8dfe :                  W_WORD
8dfe : 84574f52c4       	DB	$84,'WOR','D'+$80
8e03 : ec8d             	DW	W_PAD
8e05 :                  C_WORD
8e05 : 7c85             	DW	E_COLON			;Interpret following word sequence
8e07 : c686             	DW	C_BLK
8e09 : 0285             	DW	C_FETCH			;Get word from addr on stack
8e0b : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8e0d : 0c00             	DW	B0016-$			;000Ch
8e0f : c686             	DW	C_BLK
8e11 : 0285             	DW	C_FETCH			;Get word from addr on stack
8e13 : 1e94             	DW	C_BLOCK
8e15 : b080             	DW	C_BRANCH		;Add following offset to BC
8e17 : 0600             	DW	B0017-$			;0006h
8e19 :                  B0016
8e19 : 7e86             	DW	C_TIB
8e1b : 0285             	DW	C_FETCH			;Get word from addr on stack
8e1d :                  B0017
8e1d : d086             	DW	C_TOIN			;Current input buffer offset
8e1f : 0285             	DW	C_FETCH			;Get word from addr on stack
8e21 : 1384             	DW	C_PLUS			;n1 + n2
8e23 : a284             	DW	C_SWAP			;Swap top 2 values on stack
8e25 : ca81             	DW	C_ENCLOSE
8e27 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8e29 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8e2b : 2200             	DW	$0022
8e2d : cb8d             	DW	C_BLANKS
8e2f : d086             	DW	C_TOIN			;Current input buffer offset
8e31 : dd84             	DW	C_PLUSSTORE		;Add n1 to addr
8e33 : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
8e35 : 5489             	DW	C_MINUS
8e37 : b583             	DW	C_MOVER			;Move value from data to return stack
8e39 : e083             	DW	C_RFETCH		;Return stack top to data stack
8e3b : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8e3d : 4885             	DW	C_CSTORE		;Store byte at addr
8e3f : 1384             	DW	C_PLUS			;n1 + n2
8e41 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8e43 : e388             	DW	C_1PLUS			;1 plus
8e45 : cb83             	DW	C_RMOVE			;Move word from return to data stack
8e47 : 6e82             	DW	C_CMOVE			;Move block
8e49 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8e4b : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8e4d :                  W_CONVERT
8e4d : 87434f4e564552d4 	DB	$87,'CONVER','T'+$80
8e55 : fe8d             	DW	W_WORD
8e57 :                  C_CONVERT
8e57 : 7c85             	DW	E_COLON			;Interpret following word sequence
8e59 :                  B001A
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   41
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8e59 : e388             	DW	C_1PLUS			;1 plus
8e5b : af84             	DW	C_DUP			;Duplicate top value on stack
8e5d : b583             	DW	C_MOVER			;Move value from data to return stack
8e5f : 1185             	DW	C_CFETCH		;Get byte from addr on stack
8e61 : 2487             	DW	C_BASE			;Put BASE addr on stack
8e63 : 0285             	DW	C_FETCH			;Get word from addr on stack
8e65 : 5281             	DW	C_DIGIT			;Convert digit n2 using base n1
8e67 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8e69 : 2c00             	DW	B0018-$			;002Ch
8e6b : a284             	DW	C_SWAP			;Swap top 2 values on stack
8e6d : 2487             	DW	C_BASE			;Put BASE addr on stack
8e6f : 0285             	DW	C_FETCH			;Get word from addr on stack
8e71 : 8482             	DW	C_USTAR
8e73 : 8684             	DW	C_DROP			;Drop top value from stack
8e75 : c589             	DW	C_ROT			;3rd value down to top of stack
8e77 : 2487             	DW	C_BASE			;Put BASE addr on stack
8e79 : 0285             	DW	C_FETCH			;Get word from addr on stack
8e7b : 8482             	DW	C_USTAR
8e7d : 2084             	DW	C_DPLUS
8e7f : 2e87             	DW	C_DPL
8e81 : 0285             	DW	C_FETCH			;Get word from addr on stack
8e83 : e388             	DW	C_1PLUS			;1 plus
8e85 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8e87 : 0800             	DW	B0019-$			;0008h
8e89 : fb85             	DW	C_1			;Put 1 on stack
8e8b : 2e87             	DW	C_DPL
8e8d : dd84             	DW	C_PLUSSTORE		;Add n1 to addr
8e8f :                  B0019
8e8f : cb83             	DW	C_RMOVE			;Move word from return to data stack
8e91 : b080             	DW	C_BRANCH		;Add following offset to BC
8e93 : c6ff             	DW	B001A-$			;FFC6h
8e95 :                  B0018
8e95 : cb83             	DW	C_RMOVE			;Move word from return to data stack
8e97 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8e99 :                  W_NUMBER
8e99 : 864e554d4245d2   	DB	$86,'NUMBE','R'+$80
8ea0 : 4d8e             	DW	W_CONVERT
8ea2 :                  C_NUMBER
8ea2 : 7c85             	DW	E_COLON			;Interpret following word sequence
8ea4 : f385             	DW	C_ZERO			;Put zero on stack
8ea6 : f385             	DW	C_ZERO			;Put zero on stack
8ea8 : c589             	DW	C_ROT			;3rd value down to top of stack
8eaa : af84             	DW	C_DUP			;Duplicate top value on stack
8eac : e388             	DW	C_1PLUS			;1 plus
8eae : 1185             	DW	C_CFETCH		;Get byte from addr on stack
8eb0 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8eb2 : 2d00             	DW	$002D			;'-'
8eb4 : 6989             	DW	C_EQUALS		;Is first chr = '-'
8eb6 : af84             	DW	C_DUP			;Duplicate negative flag
8eb8 : b583             	DW	C_MOVER			;Move value from data to return stack
8eba : 1384             	DW	C_PLUS			;n1 + n2
8ebc : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8ebe : ffff             	DW	$FFFF			; -1
8ec0 :                  B001C
8ec0 : 2e87             	DW	C_DPL
8ec2 : 3985             	DW	C_STORE			;Store word at addr
8ec4 : 578e             	DW	C_CONVERT
8ec6 : af84             	DW	C_DUP			;Duplicate top value on stack
8ec8 : 1185             	DW	C_CFETCH		;Get byte from addr on stack
8eca : 1486             	DW	C_BL			;Leaves ASCII for space on stack
8ecc : 5489             	DW	C_MINUS
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   42
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8ece : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8ed0 : 1600             	DW	B001B-$			;0016h
8ed2 : af84             	DW	C_DUP			;Duplicate top value on stack
8ed4 : 1185             	DW	C_CFETCH		;Get byte from addr on stack
8ed6 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8ed8 : 2e00             	DW	$002E			;'.'
8eda : 5489             	DW	C_MINUS
8edc : f385             	DW	C_ZERO			;Put zero on stack
8ede : a18a             	DW	C_QERROR
8ee0 : f385             	DW	C_ZERO			;Put zero on stack
8ee2 : b080             	DW	C_BRANCH		;Add following offset to BC
8ee4 : dcff             	DW	B001C-$			;FFDCh
8ee6 :                  B001B
8ee6 : 8684             	DW	C_DROP			;Drop top value from stack
8ee8 : cb83             	DW	C_RMOVE			;Move word from return to data stack
8eea : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8eec : 0400             	DW	B001D-$			;$0004
8eee : 5a84             	DW	C_DNEGATE
8ef0 :                  B001D
8ef0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8ef2 :                  W_MFIND
8ef2 : 852d46494ec4     	DB	$85,'-FIN','D'+$80
8ef8 : 998e             	DW	W_NUMBER
8efa :                  C_MFIND
8efa : 7c85             	DW	E_COLON			;Interpret following word sequence
8efc : 1486             	DW	C_BL			;Leaves ASCII for space on stack
8efe : 058e             	DW	C_WORD
8f00 : ff86             	DW	C_CONTEXT
8f02 : 0285             	DW	C_FETCH			;Get word from addr on stack
8f04 : 0285             	DW	C_FETCH			;Get word from addr on stack
8f06 : 8081             	DW	C_FIND			;Find word & return vector,byte & flag
8f08 : af84             	DW	C_DUP			;Duplicate top value on stack
8f0a : e783             	DW	C_0EQUALS		;=0
8f0c : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8f0e : 0a00             	DW	B001E-$			;000Ah
8f10 : 8684             	DW	C_DROP			;Drop top value from stack
8f12 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8f14 : 358a             	DW	C_LATEST		;Push top words NFA
8f16 : 8081             	DW	C_FIND			;Find word & return vector,byte & flag
8f18 :                  B001E
8f18 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8f1a :                  W_CABORT
8f1a : 873c41424f5254be 	DB	$87,'<ABORT','>'+$80
8f22 : f28e             	DW	W_MFIND
8f24 :                  C_CABORT
8f24 : 7c85             	DW	E_COLON			;Interpret following word sequence
8f26 : 5c91             	DW	C_ABORT
8f28 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8f2a :                  W_ERROR
8f2a : 854552524fd2     	DB	$85,'ERRO','R'+$80
8f30 : 1a8f             	DW	W_CABORT
8f32 :                  C_ERROR
8f32 : 7c85             	DW	E_COLON			;Interpret following word sequence
8f34 : 9886             	DW	C_WARNING		;Put WARNING addr on stack
8f36 : 0285             	DW	C_FETCH			;Get word from addr on stack
8f38 : 0284             	DW	C_0LESS			;Less than 0 leaves true
8f3a : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8f3c : 0400             	DW	B001F-$			;$0004
8f3e : 248f             	DW	C_CABORT
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   43
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8f40 :                  B001F
8f40 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8f42 : 0f8c             	DW	C_COUNT			;Convert string at addr to addr + length
8f44 : 228c             	DW	C_TYPE			;Output n bytes from addr
8f46 : 838c             	DW	C_CQUOTE		;Output following string
8f48 : 02               	DB	S_END7-S_START7
8f49 :                  S_START7
8f49 : 3f20             	DB	'? '		;
8f4b :                  S_END7
8f4b : 6493             	DW	C_MESSAGE		;Output message
8f4d : 4d83             	DW	C_SPSTORE		;Set initial stack pointer value
8f4f : c686             	DW	C_BLK
8f51 : 0285             	DW	C_FETCH			;Get word from addr on stack
8f53 : f989             	DW	C_QUERYDUP
8f55 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8f57 : 0800             	DW	B0020-$			;0008h
8f59 : d086             	DW	C_TOIN			;Current input buffer offset
8f5b : 0285             	DW	C_FETCH			;Get word from addr on stack
8f5d : a284             	DW	C_SWAP			;Swap top 2 values on stack
8f5f :                  B0020
8f5f : 2f91             	DW	C_QUIT
                        
8f61 :                  W_ID		;Print definition name from name field addr
8f61 : 834944ae         	DB	$83,'ID','.'+$80
8f65 : 2a8f             	DW	W_ERROR
8f67 :                  C_ID
8f67 : 7c85             	DW	E_COLON			;Interpret following word sequence
8f69 : 0f8c             	DW	C_COUNT			;Convert string at addr to addr + length
8f6b : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8f6d : 1f00             	DW	$001F			;Max length is 1Fh
8f6f : 0683             	DW	C_AND			;AND lenght with 1Fh
8f71 : 228c             	DW	C_TYPE			;Output n bytes from addr
8f73 : ea89             	DW	C_SPACE			;Output space
8f75 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8f77 :                  C_XXX1
8f77 : 7c85             	DW	E_COLON			;Interpret following word sequence
8f79 : fa8e             	DW	C_MFIND			;Find name returns PFA,length,true or false
8f7b : c880             	DW	C_0BRANCH		;Branch if name not found
8f7d : 1000             	DW	B0021-$			;0010h
8f7f : 8684             	DW	C_DROP			;Drop length
8f81 : 638a             	DW	C_NFA			;Convert PFA to NFA
8f83 : 678f             	DW	C_ID			;Print definition name from name field addr
8f85 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8f87 : 0400             	DW	$0004			;Message 4, name defined twice
8f89 : 6493             	DW	C_MESSAGE		;Output message
8f8b : ea89             	DW	C_SPACE			;Output space
8f8d :                  B0021
8f8d : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8f8f : af84             	DW	C_DUP			;Duplicate top value on stack
8f91 : 1185             	DW	C_CFETCH		;Get byte from addr on stack
8f93 : 8a86             	DW	C_WIDTH
8f95 : 0285             	DW	C_FETCH			;Get word from addr on stack
8f97 : 4192             	DW	C_MIN
8f99 : e388             	DW	C_1PLUS			;1 plus
8f9b : 2789             	DW	C_ALLOT			;Which ever is smallest width or namelength
8f9d : af84             	DW	C_DUP			;Duplicate top value on stack
8f9f : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8fa1 : a000             	DW	$00A0
8fa3 : f484             	DW	C_TOGGLE		;XOR (addr) with byte
8fa5 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8fa7 : fb85             	DW	C_1			;Put 1 on stack
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   44
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

8fa9 : 5489             	DW	C_MINUS
8fab : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8fad : 8000             	DW	$0080
8faf : f484             	DW	C_TOGGLE		;XOR (addr) with byte
8fb1 : 358a             	DW	C_LATEST		;Push top words NFA
8fb3 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
8fb5 : 0d87             	DW	C_CURRENT
8fb7 : 0285             	DW	C_FETCH			;Get word from addr on stack
8fb9 : 3985             	DW	C_STORE			;Store word at addr
8fbb : 1789             	DW	C_HERE			;Dictionary pointer onto stack
8fbd : ef88             	DW	C_2PLUS			;2 plus
8fbf : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
8fc1 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8fc3 :                  W_CCOMPILE
8fc3 : 895b434f4d5049.. 	DB	$89,'[COMPILE',']'+$80
8fcd : 618f             	DW	W_ID
8fcf :                  C_CCOMPILE
8fcf : 7c85             	DW	E_COLON			;Interpret following word sequence
8fd1 : fa8e             	DW	C_MFIND
8fd3 : e783             	DW	C_0EQUALS		;=0
8fd5 : f385             	DW	C_ZERO			;Put zero on stack
8fd7 : a18a             	DW	C_QERROR
8fd9 : 8684             	DW	C_DROP			;Drop top value from stack
8fdb : 558a             	DW	C_CFA			;Convert PFA to CFA
8fdd : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
8fdf : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8fe1 :                  W_LITERAL
8fe1 : c74c4954455241cc 	DB	$C7,'LITERA','L'+$80
8fe9 : c38f             	DW	W_CCOMPILE
8feb :                  C_LITERAL
8feb : 7c85             	DW	E_COLON			;Interpret following word sequence
8fed : 1987             	DW	C_STATE			;Push STATE addr
8fef : 0285             	DW	C_FETCH			;Get word from addr on stack
8ff1 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
8ff3 : 0800             	DW	B0022-$			;0008h
8ff5 : 348b             	DW	C_COMPILE		;Compile next word into dictionary
8ff7 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
8ff9 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
8ffb :                  B0022
8ffb : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
8ffd :                  W_DLITERAL
8ffd : c8444c49544552.. 	DB	$C8,'DLITERA','L'+$80
9006 : e18f             	DW	W_LITERAL
9008 :                  C_DLITERAL
9008 : 7c85             	DW	E_COLON			;Interpret following word sequence
900a : 1987             	DW	C_STATE			;Push STATE addr
900c : 0285             	DW	C_FETCH			;Get word from addr on stack
900e : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
9010 : 0800             	DW	B0023-$			;0008h
9012 : a284             	DW	C_SWAP			;Swap top 2 values on stack
9014 : eb8f             	DW	C_LITERAL
9016 : eb8f             	DW	C_LITERAL
9018 :                  B0023
9018 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
901a :                  W_QSTACK
901a : 863f53544143cb   	DB	$86,'?STAC','K'+$80
9021 : fd8f             	DW	W_DLITERAL
9023 :                  C_QSTACK
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   45
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9023 : 7c85             	DW	E_COLON			;Interpret following word sequence
9025 : 3e83             	DW	C_SPFETCH		;Stack pointer onto stack
9027 : 6b86             	DW	C_S0			;Push S0 (initial data stack pointer)
9029 : 0285             	DW	C_FETCH			;Get word from addr on stack
902b : a284             	DW	C_SWAP			;Swap top 2 values on stack
902d : 9789             	DW	C_ULESS			;IF stack-1 < stack_top leave true flag
902f : fb85             	DW	C_1			;Put 1 on stack
9031 : a18a             	DW	C_QERROR
9033 : 3e83             	DW	C_SPFETCH		;Stack pointer onto stack
9035 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
9037 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
9039 : 8000             	DW	$0080
903b : 1384             	DW	C_PLUS			;n1 + n2
903d : 9789             	DW	C_ULESS			;IF stack-1 < stack_top leave true flag
903f : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
9041 : 0700             	DW	$0007
9043 : a18a             	DW	C_QERROR
9045 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9047 :                  W_INTERPRET
9047 : 89494e54455250.. 	DB	$89,'INTERPRE','T'+$80
9051 : 1a90             	DW	W_QSTACK
9053 :                  C_INTERPRET
9053 : 7c85             	DW	E_COLON			;Interpret following word sequence
9055 :                  B002A
9055 : fa8e             	DW	C_MFIND			;Find name returns PFA,length,true or false
9057 : c880             	DW	C_0BRANCH		;Branch if name not found
9059 : 1e00             	DW	NO_NAME-$		;
905b : 1987             	DW	C_STATE			;STATE addr on stack
905d : 0285             	DW	C_FETCH			;Get STATE
905f : 7589             	DW	C_LESSTHAN		;Is it quit compile word ?
9061 : c880             	DW	C_0BRANCH		;If so then branch
9063 : 0a00             	DW	B0025-$			;
9065 : 558a             	DW	C_CFA			;Convert PFA to CFA
9067 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
9069 : b080             	DW	C_BRANCH		;Add following offset to BC
906b : 0600             	DW	B0026-$			;
906d :                  B0025
906d : 558a             	DW	C_CFA			;Convert PFA to CFA
906f : a180             	DW	C_EXECUTE		;Jump to address on stack
9071 :                  B0026
9071 : 2390             	DW	C_QSTACK		;Error message if stack underflow
9073 : b080             	DW	C_BRANCH		;Add following offset to BC
9075 : 1c00             	DW	B0027-$			;
9077 :                  NO_NAME
9077 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
9079 : a28e             	DW	C_NUMBER		;Convert string at addr to double
907b : 2e87             	DW	C_DPL			;
907d : 0285             	DW	C_FETCH			;Get word from addr on stack
907f : e388             	DW	C_1PLUS			;1 plus
9081 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
9083 : 0800             	DW	B0028-$			;
9085 : 0890             	DW	C_DLITERAL
9087 : b080             	DW	C_BRANCH		;Add following offset to BC
9089 : 0600             	DW	B0029-$			;
908b :                  B0028
908b : 8684             	DW	C_DROP			;Drop top value from stack
908d : eb8f             	DW	C_LITERAL
908f :                  B0029
908f : 2390             	DW	C_QSTACK		;Error message if stack underflow
9091 :                  B0027
9091 : b080             	DW	C_BRANCH		;Add following offset to BC
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   46
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9093 : c2ff             	DW	B002A-$			;FFC2h
                        
9095 :                  W_IMMEDIATE
9095 : 89494d4d454449.. 	DB	$89,'IMMEDIAT','E'+$80
909f : 4790             	DW	W_INTERPRET
90a1 :                  C_IMMEDIATE
90a1 : 7c85             	DW	E_COLON			;Interpret following word sequence
90a3 : 358a             	DW	C_LATEST		;Push top words NFA
90a5 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
90a7 : 4000             	DW	$0040
90a9 : f484             	DW	C_TOGGLE		;XOR (addr) with byte
90ab : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
90ad :                  W_VOCABULARY
90ad : 8a564f43414255.. 	DB	$8A,'VOCABULAR','Y'+$80
90b8 : 9590             	DW	W_IMMEDIATE
90ba :                  C_VOCABULARY
90ba : 7c85             	DW	E_COLON			;Interpret following word sequence
90bc : d88b             	DW	C_CREATE
90be : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
90c0 : 81a0             	DW	$A081
90c2 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
90c4 : 0d87             	DW	C_CURRENT
90c6 : 0285             	DW	C_FETCH			;Get word from addr on stack
90c8 : 558a             	DW	C_CFA			;Convert PFA to CFA
90ca : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
90cc : 1789             	DW	C_HERE			;Dictionary pointer onto stack
90ce : bc86             	DW	C_VOC_LINK
90d0 : 0285             	DW	C_FETCH			;Get word from addr on stack
90d2 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
90d4 : bc86             	DW	C_VOC_LINK
90d6 : 3985             	DW	C_STORE			;Store word at addr
90d8 : e88b             	DW	C_DOES
90da : ef88             	DW	C_2PLUS			;2 plus
90dc : ff86             	DW	C_CONTEXT
90de : 3985             	DW	C_STORE			;Store word at addr
90e0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
90e2 :                  C_LINK
90e2 : ef88             	DW	C_2PLUS			;2 plus
90e4 : 0285             	DW	C_FETCH			;Get word from addr on stack
90e6 : ff86             	DW	C_CONTEXT
90e8 : 3985             	DW	C_STORE			;Store word at addr
90ea : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
90ec :                  W_FORTH
90ec : c5464f5254c8     	DB	$C5,'FORT','H'+$80
90f2 : ad90             	DW	W_VOCABULARY
90f4 :                  C_FORTH
90f4 : f48b             	DW	X_DOES
90f6 : e290             	DW	C_LINK
                        
90f8 : 81a0             	DB	$81,' '+$80
90fa : 34fe             	DW	FLAST+2
90fc :                  E_FORTH
90fc : 0000             	DW	$0000
                        
90fe :                  W_DEFINITIONS	;Set CURRENT as CONTEXT vocabulary
90fe : 8b444546494e49.. 	DB	$8B,'DEFINITION','S'+$80
910a : ec90             	DW	W_FORTH
910c :                  C_DEFINITIONS
910c : 7c85             	DW	E_COLON			;Interpret following word sequence
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   47
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

910e : ff86             	DW	C_CONTEXT		;Get CONTEXT addr
9110 : 0285             	DW	C_FETCH			;Get word from addr on stack
9112 : 0d87             	DW	C_CURRENT		;Get CURRENT addr
9114 : 3985             	DW	C_STORE			;Set CURRENT as the context vocabulary
9116 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9118 :                  W_OPENBRKT
9118 : c1a8             	DB	$C1,'('+$80
911a : fe90             	DW	W_DEFINITIONS
911c :                  C_OPENBRKT
911c : 7c85             	DW	E_COLON			;Interpret following word sequence
911e : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
9120 : 2900             	DW	$0029
9122 : 058e             	DW	C_WORD
9124 : 8684             	DW	C_DROP			;Drop top value from stack
9126 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
                        ;		This it the last thing ever executed and is the interpreter
                        ;		outer loop. This NEVER quits.
                        
9128 :                  W_QUIT
9128 : 84515549d4       	DB	$84,'QUI','T'+$80
912d : 1891             	DW	W_OPENBRKT
912f :                  C_QUIT
912f : 7c85             	DW	E_COLON			;Interpret following word sequence
9131 : f385             	DW	C_ZERO			;Put zero on stack
9133 : c686             	DW	C_BLK			;Get current BLK pointer
9135 : 3985             	DW	C_STORE			;Set BLK to 0
9137 : 4a8b             	DW	C_LEFTBRKT		;Set STATE to execute
9139 :                  B002C
9139 : 7283             	DW	C_RPSTORE		;Set initial return stack pointer
913b : 4c82             	DW	C_CR			;Output [CR][LF]
913d : 458d             	DW	C_QUERY			;Get string from input, ends in CR
913f : 5390             	DW	C_INTERPRET		;Interpret input stream
9141 : 1987             	DW	C_STATE			;Push STATE addr
9143 : 0285             	DW	C_FETCH			;Get word from addr on stack
9145 : e783             	DW	C_0EQUALS		;=0
9147 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
9149 : 0700             	DW	S_END8-$		;0007h
914b : 838c             	DW	C_CQUOTE		;Output following string
914d : 02               	DB	S_END8-S_START8
914e :                  S_START8
914e : 4f4b             	DB	'OK'
9150 :                  S_END8
9150 : b080             	DW	C_BRANCH		;Add following offset to BC
9152 : e7ff             	DW	B002C-$			;FFE7h
                        
9154 :                  W_ABORT
9154 : 8541424f52d4     	DB	$85,'ABOR','T'+$80
915a : 2891             	DW	W_QUIT
915c :                  C_ABORT
915c : 7c85             	DW	E_COLON			;Interpret following word sequence
915e : de87             	DW	C_UABORT		;Put UABORT on stack
9160 : 0285             	DW	C_FETCH			;Get word from addr on stack
9162 : a180             	DW	C_EXECUTE		;Jump to address on stack
9164 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9166 :                  CF_UABORT
9166 : 7c85             	DW	E_COLON			;Interpret following word sequence
9168 : 4d83             	DW	C_SPSTORE		;Set initial stack pointer value
916a : 958b             	DW	C_DECIMAL		;Sets decimal mode
916c : 2390             	DW	C_QSTACK		;Error message if stack underflow
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   48
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

916e : 4c82             	DW	C_CR			;Output [CR][LF]
9170 : 838c             	DW	C_CQUOTE		;Output following string
9172 : 0e               	DB	S_END1-S_START1		;String length
9173 :                  S_START1
9173 : 0c2a205a383020.. 	DB	$0C,'* Z80 FORTH *'
9181 :                  S_END1
9181 : f490             	DW	C_FORTH
9183 : 0c91             	DW	C_DEFINITIONS			;Set CURRENT as CONTEXT vocabulary
9185 : 2f91             	DW	C_QUIT
                        
9187 :                  W_WARM
9187 : 84574152cd       	DB	$84,'WAR','M'+$80
918c : 5491             	DW	W_ABORT
918e :                  C_WARM
918e : 7c85             	DW	E_COLON					;Interpret following word sequence
9190 : 8c80             	DW	C_LIT					;Puts next 2 bytes on the stack
9192 : 2080             	DW	WORD1					;Start of detault table
9194 : 8c80             	DW	C_LIT					;Puts next 2 bytes on the stack
9196 : 06fe             	DW	S0						;S0 addr
9198 : 8c80             	DW	C_LIT					;Puts next 2 bytes on the stack
919a : 1000             	DW	START_TABLE-WORD1		;(000Ch) Table length
919c : 6e82             	DW	C_CMOVE					;Move block
919e : 5c91             	DW	C_ABORT
                        
91a0 :                  X_COLD
91a0 : 213080           	LD	HL,START_TABLE			;Copy table to ram
91a3 : 1132fe           	LD	DE,FLAST				;Where the table's going
91a6 : 013400           	LD	BC,NEXTS2-START_TABLE	;Bytes to copy
91a9 : edb0             	LDIR						;
91ab : 21619a           	LD	HL,W_TASK				;Copy TASK to ram
91ae : 1100f0           	LD	DE,VOCAB_BASE			;Where it's going
91b1 : 010b00           	LD	BC,W_TASKEND-W_TASK		;Bytes to copy
91b4 : edb0             	LDIR						;
91b6 : 01c091           	LD	BC,FIRSTWORD			;BC to first forth word
91b9 : 2a2080           	LD	HL,(WORD1)				;Get stack pointer
91bc : f9               	LD	SP,HL					;Set it
91bd : c36680           	JP	NEXT
                        
91c0 :                  FIRSTWORD
91c0 : cb91             	DW	C_COLD
                        
91c2 :                  W_COLD
91c2 : 84434f4cc4       	DB	$84,'COL','D'+$80
91c7 : 8791             	DW	W_WARM
91c9 : a091             	DW	X_COLD
91cb :                  C_COLD
91cb : 7c85             	DW	E_COLON					;Interpret following word sequence
91cd : f993             	DW	C_EBUFFERS				;Clear pseudo disk buffer
91cf : f385             	DW	C_ZERO					;Put zero on stack
91d1 : f186             	DW	C_OFFSET				;Put disk block offset on stack
91d3 : 3985             	DW	C_STORE					;Clear disk block offset
91d5 : 8c80             	DW	C_LIT					;Puts next 2 bytes on the stack
91d7 : 2080             	DW	WORD1					;Start of default table
91d9 : 8c80             	DW	C_LIT					;Puts next 2 bytes on the stack
91db : 06fe             	DW	S0						;S0 addr
91dd : 8c80             	DW	C_LIT					;Puts next 2 bytes on the stack
91df : 1000             	DW	START_TABLE-WORD1		;Block length on stack (0010h)
91e1 : 6e82             	DW	C_CMOVE					;Move block
91e3 : 5c91             	DW	C_ABORT
                        
91e5 :                  W_SINGTODUB						;Change single number to double
91e5 : 84532d3ec4       	DB	$84,'S->','D'+$80
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   49
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

91ea : c291             	DW	W_COLD
91ec :                  C_SINGTODUB
91ec : ee91             	DW	2+$						;Vector to code
91ee : d1               	POP	DE						;Get number
91ef : 210000           	LD	HL,$0000				;Assume +ve extend
91f2 : 7a               	LD	A,D						;Check sign
91f3 : e680             	AND	$80						;
91f5 : 2801             	JR	Z,IS_POS				;Really +ve so jump
91f7 : 2b               	DEC	HL						;Make -ve extension
91f8 :                  IS_POS	
91f8 : c36480           	JP	NEXTS2					;Save both & NEXT
                        
91fb :                  W_PLUSMINUS
91fb : 822bad           	DB	$82,'+','-'+$80
91fe : e591             	DW	W_SINGTODUB
9200 :                  C_PLUSMINUS
9200 : 7c85             	DW	E_COLON					;Interpret following word sequence
9202 : 0284             	DW	C_0LESS					;Less than 0
9204 : c880             	DW	C_0BRANCH				;Add offset to BC if stack top = 0
9206 : 0400             	DW	B002D-$					;$0004
9208 : 4384             	DW	C_NEGATE				;Form 2s complement of n
920a :                  B002D		
920a : 8a83             	DW	C_STOP					;Pop BC from return stack (=next)
                        
920c :                  W_DPLUSMINUS					;Add sign of n to double
920c : 83442bad         	DB	$83,'D+','-'+$80
9210 : fb91             	DW	W_PLUSMINUS
9212 :                  C_DPLUSMINUS
9212 : 7c85             	DW	E_COLON					;Interpret following word sequence
9214 : 0284             	DW	C_0LESS					;Less than 0
9216 : c880             	DW	C_0BRANCH				;Add offset to BC if stack top = 0
9218 : 0400             	DW	B002E-$					;$0004
921a : 5a84             	DW	C_DNEGATE		
921c :                  B002E		
921c : 8a83             	DW	C_STOP					;Pop BC from return stack (=next)
                        
921e :                  W_ABS
921e : 834142d3         	DB	$83,'AB','S'+$80
9222 : 0c92             	DW	W_DPLUSMINUS
9224 :                  C_ABS
9224 : 7c85             	DW	E_COLON					;Interpret following word sequence
9226 : af84             	DW	C_DUP					;Duplicate top value on stack
9228 : 0092             	DW	C_PLUSMINUS
922a : 8a83             	DW	C_STOP					;Pop BC from return stack (=next)
                        
922c :                  W_DABS
922c : 84444142d3       	DB	$84,'DAB','S'+$80
9231 : 1e92             	DW	W_ABS
9233 :                  C_DABS
9233 : 7c85             	DW	E_COLON					;Interpret following word sequence
9235 : af84             	DW	C_DUP					;Duplicate top value on stack
9237 : 1292             	DW	C_DPLUSMINUS			;Add sign of n to double
9239 : 8a83             	DW	C_STOP					;Pop BC from return stack (=next)
                        
923b :                  W_MIN
923b : 834d49ce         	DB	$83,'MI','N'+$80
923f : 2c92             	DW	W_DABS
9241 :                  C_MIN
9241 : 7c85             	DW	E_COLON					;Interpret following word sequence
9243 : bd84             	DW	C_2DUP					;Dup top 2 values on stack
9245 : b789             	DW	C_GREATER		
9247 : c880             	DW	C_0BRANCH				;Add offset to BC if stack top = 0
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   50
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9249 : 0400             	DW	B002F-$					;$0004
924b : a284             	DW	C_SWAP					;Swap top 2 values on stack
924d :                  B002F		
924d : 8684             	DW	C_DROP					;Drop top value from stack
924f : 8a83             	DW	C_STOP					;Pop BC from return stack (=next)
                        
9251 :                  W_MAX
9251 : 834d41d8         	DB	$83,'MA','X'+$80
9255 : 3b92             	DW	W_MIN
9257 :                  C_MAX
9257 : 7c85             	DW	E_COLON			;Interpret following word sequence
9259 : bd84             	DW	C_2DUP			;Dup top 2 values on stack
925b : 7589             	DW	C_LESSTHAN
925d : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
925f : 0400             	DW	B0030-$			;$0004
9261 : a284             	DW	C_SWAP			;Swap top 2 values on stack
9263 :                  B0030
9263 : 8684             	DW	C_DROP			;Drop top value from stack
9265 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9267 :                  W_MTIMES
9267 : 824daa           	DB	$82,'M','*'+$80
926a : 5192             	DW	W_MAX
926c :                  C_MTIMES
926c : 7c85             	DW	E_COLON			;Interpret following word sequence
926e : bd84             	DW	C_2DUP			;Dup top 2 values on stack
9270 : 2b83             	DW	C_XOR			;Works out sign of result
9272 : b583             	DW	C_MOVER			;Move value from data to return stack
9274 : 2492             	DW	C_ABS
9276 : a284             	DW	C_SWAP			;Swap top 2 values on stack
9278 : 2492             	DW	C_ABS
927a : 8482             	DW	C_USTAR
927c : cb83             	DW	C_RMOVE			;Move word from return to data stack
927e : 1292             	DW	C_DPLUSMINUS		;Add sign of n to double
9280 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9282 :                  W_MDIV
9282 : 824daf           	DB	$82,'M','/'+$80
9285 : 6792             	DW	W_MTIMES
9287 :                  C_MDIV
9287 : 7c85             	DW	E_COLON			;Interpret following word sequence
9289 : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
928b : b583             	DW	C_MOVER			;Move value from data to return stack
928d : b583             	DW	C_MOVER			;Move value from data to return stack
928f : 3392             	DW	C_DABS
9291 : e083             	DW	C_RFETCH		;Return stack top to data stack
9293 : 2492             	DW	C_ABS
9295 : b982             	DW	C_UMOD			;Unsigned divide & MOD
9297 : cb83             	DW	C_RMOVE			;Move word from return to data stack
9299 : e083             	DW	C_RFETCH		;Return stack top to data stack
929b : 2b83             	DW	C_XOR			;XOR
929d : 0092             	DW	C_PLUSMINUS
929f : a284             	DW	C_SWAP			;Swap top 2 values on stack
92a1 : cb83             	DW	C_RMOVE			;Move word from return to data stack
92a3 : 0092             	DW	C_PLUSMINUS
92a5 : a284             	DW	C_SWAP			;Swap top 2 values on stack
92a7 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
92a9 :                  W_TIMES
92a9 : 81aa             	DB	$81,'*'+$80
92ab : 8292             	DW	W_MDIV
92ad :                  C_TIMES
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   51
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

92ad : 7c85             	DW	E_COLON			;Interpret following word sequence
92af : 6c92             	DW	C_MTIMES
92b1 : 8684             	DW	C_DROP			;Drop top value from stack
92b3 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
92b5 :                  W_DIVMOD
92b5 : 842f4d4fc4       	DB	$84,'/MO','D'+$80
92ba : a992             	DW	W_TIMES
92bc :                  C_DIVMOD
92bc : 7c85             	DW	E_COLON			;Interpret following word sequence
92be : b583             	DW	C_MOVER			;Move value from data to return stack
92c0 : ec91             	DW	C_SINGTODUB		;Change single number to double
92c2 : cb83             	DW	C_RMOVE			;Move word from return to data stack
92c4 : 8792             	DW	C_MDIV
92c6 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
92c8 :                  W_DIV
92c8 : 81af             	DB	$81,'/'+$80
92ca : b592             	DW	W_DIVMOD
92cc :                  C_DIV
92cc : 7c85             	DW	E_COLON			;Interpret following word sequence
92ce : bc92             	DW	C_DIVMOD
92d0 : a284             	DW	C_SWAP			;Swap top 2 values on stack
92d2 : 8684             	DW	C_DROP			;Drop top value from stack
92d4 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
92d6 :                  W_MOD
92d6 : 834d4fc4         	DB	$83,'MO','D'+$80
92da : c892             	DW	W_DIV
92dc :                  C_MOD
92dc : 7c85             	DW	E_COLON			;Interpret following word sequence
92de : bc92             	DW	C_DIVMOD
92e0 : 8684             	DW	C_DROP			;Drop top value from stack
92e2 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
92e4 :                  W_TIMESDIVMOD
92e4 : 852a2f4d4fc4     	DB	$85,'*/MO','D'+$80
92ea : d692             	DW	W_MOD
92ec :                  C_TIMESDIVMOD
92ec : 7c85             	DW	E_COLON			;Interpret following word sequence
92ee : b583             	DW	C_MOVER			;Move value from data to return stack
92f0 : 6c92             	DW	C_MTIMES
92f2 : cb83             	DW	C_RMOVE			;Move word from return to data stack
92f4 : 8792             	DW	C_MDIV
92f6 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
92f8 :                  W_TIMESDIV
92f8 : 822aaf           	DB	$82,'*','/'+$80
92fb : e492             	DW	W_TIMESDIVMOD
92fd :                  C_TIMESDIV
92fd : 7c85             	DW	E_COLON			;Interpret following word sequence
92ff : ec92             	DW	C_TIMESDIVMOD
9301 : a284             	DW	C_SWAP			;Swap top 2 values on stack
9303 : 8684             	DW	C_DROP			;Drop top value from stack
9305 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9307 :                  W_MDIVMOD
9307 : 854d2f4d4fc4     	DB	$85,'M/MO','D'+$80
930d : f892             	DW	W_TIMESDIV
930f :                  C_MDIVMOD
930f : 7c85             	DW	E_COLON			;Interpret following word sequence
9311 : b583             	DW	C_MOVER			;Move value from data to return stack
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   52
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9313 : f385             	DW	C_ZERO			;Put zero on stack
9315 : e083             	DW	C_RFETCH		;Return stack top to data stack
9317 : b982             	DW	C_UMOD			;Unsigned divide & MOD
9319 : cb83             	DW	C_RMOVE			;Move word from return to data stack
931b : a284             	DW	C_SWAP			;Swap top 2 values on stack
931d : b583             	DW	C_MOVER			;Move value from data to return stack
931f : b982             	DW	C_UMOD			;Unsigned divide & MOD
9321 : cb83             	DW	C_RMOVE			;Move word from return to data stack
9323 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9325 :                  W_CLINE
9325 : 863c4c494e45be   	DB	$86,'<LINE','>'+$80
932c : 0793             	DW	W_MDIVMOD
932e :                  C_CLINE
932e : 7c85             	DW	E_COLON			;Interpret following word sequence
9330 : b583             	DW	C_MOVER			;Move value from data to return stack
9332 : 1e86             	DW	C_CL			;Put characters/line on stack
9334 : 4e86             	DW	C_BBUF			;Put bytes per block on stack
9336 : ec92             	DW	C_TIMESDIVMOD
9338 : cb83             	DW	C_RMOVE			;Move word from return to data stack
933a : 5e86             	DW	C_BSCR			;Number of buffers per block on stack
933c : ad92             	DW	C_TIMES
933e : 1384             	DW	C_PLUS			;n1 + n2
9340 : 1e94             	DW	C_BLOCK
9342 : 1384             	DW	C_PLUS			;n1 + n2
9344 : 1e86             	DW	C_CL			;Put characters/line on stack
9346 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9348 :                  W_DOTLINE
9348 : 852e4c494ec5     	DB	$85,'.LIN','E'+$80
934e : 2593             	DW	W_CLINE
9350 :                  C_DOTLINE
9350 : 7c85             	DW	E_COLON			;Interpret following word sequence
9352 : 2e93             	DW	C_CLINE
9354 : 508c             	DW	C_TRAILING
9356 : 228c             	DW	C_TYPE			;Output n bytes from addr
9358 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
935a :                  W_MESSAGE
935a : 874d4553534147c5 	DB	$87,'MESSAG','E'+$80
9362 : 4893             	DW	W_DOTLINE
9364 :                  C_MESSAGE
9364 : 7c85             	DW	E_COLON			;Interpret following word sequence
9366 : 9886             	DW	C_WARNING		;Put WARNING addr on stack
9368 : 0285             	DW	C_FETCH			;Get WARNING value
936a : c880             	DW	C_0BRANCH		;If WARNING = 0 output MSG # n
936c : 1e00             	DW	B0031-$			;001Eh
936e : f989             	DW	C_QUERYDUP
9370 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
9372 : 1400             	DW	B0032-$			;0014h
9374 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
9376 : 0400             	DW	$0004
9378 : f186             	DW	C_OFFSET		;Put disk block offset on stack
937a : 0285             	DW	C_FETCH			;Get word from addr on stack
937c : 5e86             	DW	C_BSCR			;Number of buffers per block on stack
937e : cc92             	DW	C_DIV
9380 : 5489             	DW	C_MINUS
9382 : 5093             	DW	C_DOTLINE		;Output line from screen
9384 : ea89             	DW	C_SPACE			;Output space
9386 :                  B0032
9386 : b080             	DW	C_BRANCH		;Add following offset to BC
9388 : 0d00             	DW	B0033-$			;000Dh
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   53
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

938a :                  B0031
938a : 838c             	DW	C_CQUOTE		;Output following string
938c : 06               		DB	S_END2-S_START2
938d :                  S_START2
938d : 4d5347202320     	DB	'MSG # '
9393 :                  S_END2
9393 : 5197             	DW	C_DOT
9395 :                  B0033
9395 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9397 :                  W_PORTIN	;Fetch data from port
9397 : 8250c0           	DB	$82,'P','@'+$80
939a : 5a93             	DW	W_MESSAGE
939c :                  C_PORTIN
939c : 9e93             	DW	2+$			;Vector to code
939e : d1               	POP	DE			;Get port addr
939f : 2141fe           	LD	HL,PAT+1		;Save in port in code
93a2 : 73               	LD	(HL),E			;
93a3 : cd40fe           	CALL	PAT			;Call port in routine
93a6 : 6f               	LD	L,A			;Save result
93a7 : 2600             	LD	H,$00			;
93a9 : c36580           	JP	NEXTS1			;Save & NEXT
                        
93ac :                  W_PORTOUT	;Save data to port
93ac : 8250a1           	DB	$82,'P','!'+$80
93af : 9793             	DW	W_PORTIN
93b1 :                  C_PORTOUT
93b1 : b393             	DW	2+$			;Vector to code
93b3 : d1               	POP	DE			;Get port addr
93b4 : 2144fe           	LD	HL,PST+1		;Save in port out code
93b7 : 73               	LD	(HL),E			;
93b8 : e1               	POP	HL			;
93b9 : 7d               	LD	A,L			;Byte to A
93ba : cd43fe           	CALL	PST			;Call port out routine
93bd : c36680           	JP	NEXT
                        
93c0 :                  W_USE
93c0 : 835553c5         	DB	$83,'US','E'+$80
93c4 : ac93             	DW	W_PORTOUT
93c6 :                  C_USE
93c6 : e385             	DW	X_USER			;Put next word on stack then do next
93c8 : 4800             	DW	USE-SYSTEM
                        
93ca :                  W_PREV
93ca : 84505245d6       	DB	$84,'PRE','V'+$80
93cf : c093             	DW	W_USE
93d1 :                  C_PREV
93d1 : e385             	DW	X_USER			;Put next word on stack then do next
93d3 : 4a00             	DW	PREV-SYSTEM
                        
93d5 :                  W_PLUSBUF
93d5 : 842b4255c6       	DB	$84,'+BU','F'+$80
93da : ca93             	DW	W_PREV
93dc :                  C_PLUSBUF
93dc : 6680             	DW	NEXT
                        
93de :                  W_UPDATE
93de : 865550444154c5   	DB	$86,'UPDAT','E'+$80
93e5 : d593             	DW	W_PLUSBUF
93e7 :                  C_UPDATE
93e7 : 6680             	DW	NEXT
                        
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   54
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

93e9 :                  W_EBUFFERS	;Clear pseudo disk buffer
93e9 : 8d454d5054592d.. 	DB	$8D,'EMPTY-BUFFER','S'+$80
93f7 : de93             	DW	W_UPDATE
93f9 :                  C_EBUFFERS
93f9 : 7c85             	DW	E_COLON			;Interpret following word sequence
93fb : 2e86             	DW	C_FIRST			;Start of pseudo disk onto stack
93fd : 3e86             	DW	C_LIMIT			;End of pseudo disk onto stack
93ff : 7784             	DW	C_OVER			;Start to top of stack
9401 : 5489             	DW	C_MINUS			;Work out buffer length
9403 : ba8d             	DW	C_ERASE			;Fill addr & length from stack with 0
9405 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9407 :                  W_BUFFER
9407 : 864255464645d2   	DB	$86,'BUFFE','R'+$80
940e : e993             	DW	W_EBUFFERS
9410 :                  C_BUFFER
9410 : 7c85             	DW	E_COLON			;Interpret following word sequence
9412 : 1e94             	DW	C_BLOCK
9414 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9416 :                  W_BLOCK		;Put address of block n (+ offset) on stack
9416 : 85424c4f43cb     	DB	$85,'BLOC','K'+$80
941c : 0794             	DW	W_BUFFER
941e :                  C_BLOCK
941e : 7c85             	DW	E_COLON			;Interpret following word sequence
9420 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
9422 : 2800             	DW	DISK_END/BLOCK_SIZE-DISK_START/BLOCK_SIZE
                        					;Max number of blocks
9424 : dc92             	DW	C_MOD			;MOD to max number
9426 : f186             	DW	C_OFFSET		;Put address of disk block offset on stack
9428 : 0285             	DW	C_FETCH			;Get disk block offset
942a : 1384             	DW	C_PLUS			;Add offset to block #
942c : 4e86             	DW	C_BBUF			;Put bytes per block on stack
942e : ad92             	DW	C_TIMES			;Bytes times block number
9430 : 2e86             	DW	C_FIRST			;Put address of first block on stack
9432 : 1384             	DW	C_PLUS			;Add address of first to byte offset
9434 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9436 :                  W_RW
9436 : 83522fd7         	DB	$83,'R/','W'+$80
943a : 1694             	DW	W_BLOCK
943c :                  C_RW
943c : 7c85             	DW	E_COLON			;Interpret following word sequence
943e : d187             	DW	C_URW			;
9440 : 0285             	DW	C_FETCH			;Get word from addr on stack
9442 : a180             	DW	C_EXECUTE		;Jump to address on stack
9444 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
9446 :                  CF_URW
9446 : 7c85             	DW	E_COLON			;Interpret following word sequence
9448 : 8684             	DW	C_DROP			;Drop top value from stack
944a : 8684             	DW	C_DROP			;Drop top value from stack
944c : 8684             	DW	C_DROP			;Drop top value from stack
944e : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9450 :                  W_FLUSH
9450 : 85464c5553c8     	DB	$85,'FLUS','H'+$80
9456 : 3694             	DW	W_RW
9458 :                  C_FLUSH
9458 : 7c85             	DW	E_COLON			;Interpret following word sequence
945a : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
945c :                  W_DUMP
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   55
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

945c : 8444554dd0       	DB	$84,'DUM','P'+$80
9461 : 5094             	DW	W_FLUSH
9463 :                  C_DUMP
9463 : 7c85             	DW	E_COLON			;Interpret following word sequence
9465 : f385             	DW	C_ZERO			;Put zero on stack
9467 : 2281             	DW	C_LDO			;Put start & end loop values on RPP
9469 :                  B0051
9469 : 4c82             	DW	C_CR			;Output [CR][LF]
946b : af84             	DW	C_DUP			;Duplicate top value on stack
946d : f385             	DW	C_ZERO			;Put zero on stack
946f : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
9471 : 0500             	DW	$0005
9473 : 0f97             	DW	C_DDOTR
9475 : ea89             	DW	C_SPACE			;Output space
9477 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
9479 : 0400             	DW	$0004
947b : a284             	DW	C_SWAP			;Swap top 2 values on stack
947d : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
947f : f385             	DW	C_ZERO			;Put zero on stack
9481 : 2281             	DW	C_LDO			;Put start & end loop values on RPP
9483 :                  B0050
9483 : af84             	DW	C_DUP			;Duplicate top value on stack
9485 : 1185             	DW	C_CFETCH		;Get byte from addr on stack
9487 : 0b86             	DW	C_3
9489 : 3297             	DW	C_DOTR
948b : e388             	DW	C_1PLUS			;1 plus
948d : dd80             	DW	C_LLOOP			;Increment loop & branch if not done
948f : f4ff             	DW	B0050-$			;FFF4h
9491 : a284             	DW	C_SWAP			;Swap top 2 values on stack
9493 : 1681             	DW	C_PLOOP			;Loop + stack & branch if not done
9495 : d4ff             	DW	B0051-$			;FFD4h
9497 : 8684             	DW	C_DROP			;Drop top value from stack
9499 : 4c82             	DW	C_CR			;Output [CR][LF]
949b : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
949d :                  W_LOAD
949d : 844c4f41c4       	DB	$84,'LOA','D'+$80
94a2 : 5c94             	DW	W_DUMP
94a4 :                  C_LOAD
94a4 : 7c85             	DW	E_COLON			;Interpret following word sequence
94a6 : c686             	DW	C_BLK			;Get current block number (0 = keyboard)
94a8 : 0285             	DW	C_FETCH			;Get word from addr on stack
94aa : b583             	DW	C_MOVER			;Save it for now
94ac : d086             	DW	C_TOIN			;Current input buffer offset
94ae : 0285             	DW	C_FETCH			;Get word from addr on stack
94b0 : b583             	DW	C_MOVER			;Save it for now
94b2 : f385             	DW	C_ZERO			;Put zero on stack
94b4 : d086             	DW	C_TOIN			;Current input buffer offset
94b6 : 3985             	DW	C_STORE			;Set to zero
94b8 : 5e86             	DW	C_BSCR			;Number of buffers per block on stack
94ba : ad92             	DW	C_TIMES			;Multiply block to load by buffers/block
94bc : c686             	DW	C_BLK			;Get BLK pointer
94be : 3985             	DW	C_STORE			;Make load block current input stream
94c0 : 5390             	DW	C_INTERPRET		;Interpret input stream
94c2 : cb83             	DW	C_RMOVE			;Move word from return to data stack
94c4 : d086             	DW	C_TOIN			;Current input buffer offset
94c6 : 3985             	DW	C_STORE			;Store word at addr
94c8 : cb83             	DW	C_RMOVE			;Move word from return to data stack
94ca : c686             	DW	C_BLK			;Current block
94cc : 3985             	DW	C_STORE			;Store word at addr
94ce : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   56
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

94d0 :                  W_NEXTSCREEN
94d0 : c32d2dbe         	DB	$C3,'--','>'+$80
94d4 : 9d94             	DW	W_LOAD
94d6 :                  C_NEXTSCREEN
94d6 : 7c85             	DW	E_COLON			;Interpret following word sequence
94d8 : 1a8b             	DW	C_QLOADING
94da : f385             	DW	C_ZERO			;Put zero on stack
94dc : d086             	DW	C_TOIN			;Current input buffer offset
94de : 3985             	DW	C_STORE			;Store word at addr
94e0 : 5e86             	DW	C_BSCR			;Number of buffers per block on stack
94e2 : c686             	DW	C_BLK
94e4 : 0285             	DW	C_FETCH			;Get word from addr on stack
94e6 : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
94e8 : dc92             	DW	C_MOD
94ea : 5489             	DW	C_MINUS
94ec : c686             	DW	C_BLK
94ee : dd84             	DW	C_PLUSSTORE		;Add n1 to addr
94f0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
94f2 :                  W_TICK
94f2 : 81ac             	DB	$81,$2C+$80
94f4 : d094             	DW	W_NEXTSCREEN
94f6 :                  C_TICK
94f6 : 7c85             	DW	E_COLON			;Interpret following word sequence
94f8 : fa8e             	DW	C_MFIND			;Find name returns PFA,length,true or false
94fa : e783             	DW	C_0EQUALS		;=0
94fc : f385             	DW	C_ZERO			;Put zero on stack
94fe : a18a             	DW	C_QERROR
9500 : 8684             	DW	C_DROP			;Drop top value from stack
9502 : eb8f             	DW	C_LITERAL
9504 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9506 :                  W_FORGET
9506 : 86464f524745d4   	DB	$86,'FORGE','T'+$80
950d : f294             	DW	W_TICK
950f :                  C_FORGET
950f : 7c85             	DW	E_COLON			;Interpret following word sequence
9511 : 0d87             	DW	C_CURRENT
9513 : 0285             	DW	C_FETCH			;Get word from addr on stack
9515 : ff86             	DW	C_CONTEXT
9517 : 0285             	DW	C_FETCH			;Get word from addr on stack
9519 : 5489             	DW	C_MINUS
951b : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
951d : 1800             	DW	$0018
951f : a18a             	DW	C_QERROR
9521 : f694             	DW	C_TICK
9523 : af84             	DW	C_DUP			;Duplicate top value on stack
9525 : a486             	DW	C_FENCE
9527 : 0285             	DW	C_FETCH			;Get word from addr on stack
9529 : 7589             	DW	C_LESSTHAN
952b : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
952d : 1500             	DW	$0015
952f : a18a             	DW	C_QERROR
9531 : af84             	DW	C_DUP			;Duplicate top value on stack
9533 : 638a             	DW	C_NFA			;Convert PFA to NFA
9535 : ad86             	DW	C_DP			;Dictionary pointer addr on stack
9537 : 3985             	DW	C_STORE			;Store word at addr
9539 : 458a             	DW	C_LFA
953b : 0285             	DW	C_FETCH			;Get word from addr on stack
953d : ff86             	DW	C_CONTEXT
953f : 0285             	DW	C_FETCH			;Get word from addr on stack
9541 : 3985             	DW	C_STORE			;Store word at addr
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   57
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9543 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9545 :                  W_BACK
9545 : 84424143cb       	DB	$84,'BAC','K'+$80
954a : 0695             	DW	W_FORGET
954c :                  C_BACK
954c : 7c85             	DW	E_COLON			;Interpret following word sequence
954e : 1789             	DW	C_HERE			;Dictionary pointer onto stack
9550 : 5489             	DW	C_MINUS
9552 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
9554 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9556 :                  W_BEGIN
9556 : c542454749ce     	DB	$C5,'BEGI','N'+$80
955c : 4595             	DW	W_BACK
955e :                  C_BEGIN
955e : 7c85             	DW	E_COLON			;Interpret following word sequence
9560 : bb8a             	DW	C_QCOMP			;Error if not in compile mode
9562 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
9564 : fb85             	DW	C_1			;Put 1 on stack
9566 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9568 :                  W_ENDIF
9568 : c5454e4449c6     	DB	$C5,'ENDI','F'+$80
956e : 5695             	DW	W_BEGIN
9570 :                  C_ENDIF
9570 : 7c85             	DW	E_COLON			;Interpret following word sequence
9572 : bb8a             	DW	C_QCOMP			;Error if not in compile mode
9574 : 0386             	DW	C_2
9576 : ea8a             	DW	C_QPAIRS
9578 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
957a : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
957c : 5489             	DW	C_MINUS
957e : a284             	DW	C_SWAP			;Swap top 2 values on stack
9580 : 3985             	DW	C_STORE			;Store word at addr
9582 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9584 :                  W_THEN
9584 : c4544845ce       	DB	$C4,'THE','N'+$80
9589 : 6895             	DW	W_ENDIF
958b :                  C_THEN
958b : 7c85             	DW	E_COLON			;Interpret following word sequence
958d : 7095             	DW	C_ENDIF
958f : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9591 :                  W_DO
9591 : c244cf           	DB	$C2,'D','O'+$80
9594 : 8495             	DW	W_THEN
9596 :                  C_DO
9596 : 7c85             	DW	E_COLON			;Interpret following word sequence
9598 : 348b             	DW	C_COMPILE		;Compile next word into dictionary
959a : 2281             	DW	C_LDO			;Put start & end loop values on RPP
959c : 1789             	DW	C_HERE			;Dictionary pointer onto stack
959e : 0b86             	DW	C_3
95a0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
95a2 :                  W_LOOP
95a2 : c44c4f4fd0       	DB	$C4,'LOO','P'+$80
95a7 : 9195             	DW	W_DO
95a9 :                  C_LOOP
95a9 : 7c85             	DW	E_COLON			;Interpret following word sequence
95ab : 0b86             	DW	C_3
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   58
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

95ad : ea8a             	DW	C_QPAIRS
95af : 348b             	DW	C_COMPILE		;Compile next word into dictionary
95b1 : dd80             	DW	C_LLOOP			;Increment loop & branch if not done
95b3 : 4c95             	DW	C_BACK
95b5 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
95b7 :                  W_PLUSLOOP
95b7 : c52b4c4f4fd0     	DB	$C5,'+LOO','P'+$80
95bd : a295             	DW	W_LOOP
95bf :                  C_PLUSLOOP
95bf : 7c85             	DW	E_COLON			;Interpret following word sequence
95c1 : 0b86             	DW	C_3
95c3 : ea8a             	DW	C_QPAIRS
95c5 : 348b             	DW	C_COMPILE		;Compile next word into dictionary
95c7 : 1681             	DW	C_PLOOP			;Loop + stack & branch if not done
95c9 : 4c95             	DW	C_BACK
95cb : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
95cd :                  W_UNTIL
95cd : c5554e5449cc     	DB	$C5,'UNTI','L'+$80
95d3 : b795             	DW	W_PLUSLOOP
95d5 :                  C_UNTIL
95d5 : 7c85             	DW	E_COLON			;Interpret following word sequence
95d7 : fb85             	DW	C_1			;Put 1 on stack
95d9 : ea8a             	DW	C_QPAIRS
95db : 348b             	DW	C_COMPILE		;Compile next word into dictionary
95dd : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
95df : 4c95             	DW	C_BACK
95e1 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
95e3 :                  W_END
95e3 : c3454ec4         	DB	$C3,'EN','D'+$80
95e7 : cd95             	DW	W_UNTIL
95e9 :                  C_END
95e9 : 7c85             	DW	E_COLON			;Interpret following word sequence
95eb : d595             	DW	C_UNTIL
95ed : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
95ef :                  W_AGAIN
95ef : c541474149ce     	DB	$C5,'AGAI','N'+$80
95f5 : e395             	DW	W_END
95f7 :                  C_AGAIN
95f7 : 7c85             	DW	E_COLON			;Interpret following word sequence
95f9 : fb85             	DW	C_1			;Put 1 on stack
95fb : ea8a             	DW	C_QPAIRS
95fd : 348b             	DW	C_COMPILE		;Compile next word into dictionary
95ff : b080             	DW	C_BRANCH		;Add following offset to BC
9601 : 4c95             	DW	C_BACK
9603 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9605 :                  W_REPEAT
9605 : c65245504541d4   	DB	$C6,'REPEA','T'+$80
960c : ef95             	DW	W_AGAIN
960e :                  C_REPEAT
960e : 7c85             	DW	E_COLON			;Interpret following word sequence
9610 : b583             	DW	C_MOVER			;Move value from data to return stack
9612 : b583             	DW	C_MOVER			;Move value from data to return stack
9614 : f795             	DW	C_AGAIN
9616 : cb83             	DW	C_RMOVE			;Move word from return to data stack
9618 : cb83             	DW	C_RMOVE			;Move word from return to data stack
961a : 0386             	DW	C_2
961c : 5489             	DW	C_MINUS
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   59
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

961e : 7095             	DW	C_ENDIF
9620 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9622 :                  W_IF
9622 : c249c6           	DB	$C2,'I','F'+$80
9625 : 0596             	DW	W_REPEAT
9627 :                  C_IF
9627 : 7c85             	DW	E_COLON			;Interpret following word sequence
9629 : 348b             	DW	C_COMPILE		;Compile next word into dictionary
962b : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
962d : 1789             	DW	C_HERE			;Dictionary pointer onto stack
962f : f385             	DW	C_ZERO			;Put zero on stack
9631 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
9633 : 0386             	DW	C_2
9635 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9637 :                  W_ELSE
9637 : c4454c53c5       	DB	$C4,'ELS','E'+$80
963c : 2296             	DW	W_IF
963e :                  C_ELSE
963e : 7c85             	DW	E_COLON			;Interpret following word sequence
9640 : 0386             	DW	C_2
9642 : ea8a             	DW	C_QPAIRS
9644 : 348b             	DW	C_COMPILE		;Compile next word into dictionary
9646 : b080             	DW	C_BRANCH		;Add following offset to BC
9648 : 1789             	DW	C_HERE			;Dictionary pointer onto stack
964a : f385             	DW	C_ZERO			;Put zero on stack
964c : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
964e : a284             	DW	C_SWAP			;Swap top 2 values on stack
9650 : 0386             	DW	C_2
9652 : 7095             	DW	C_ENDIF
9654 : 0386             	DW	C_2
9656 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9658 :                  W_WHILE
9658 : c55748494cc5     	DB	$C5,'WHIL','E'+$80
965e : 3796             	DW	W_ELSE
9660 :                  C_WHILE
9660 : 7c85             	DW	E_COLON			;Interpret following word sequence
9662 : 2796             	DW	C_IF
9664 : ef88             	DW	C_2PLUS			;2 plus
9666 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9668 :                  W_SPACES
9668 : 865350414345d3   	DB	$86,'SPACE','S'+$80
966f : 5896             	DW	W_WHILE
9671 :                  C_SPACES
9671 : 7c85             	DW	E_COLON			;Interpret following word sequence
9673 : f385             	DW	C_ZERO			;Put zero on stack
9675 : 5792             	DW	C_MAX
9677 : f989             	DW	C_QUERYDUP
9679 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
967b : 0c00             	DW	B0034-$			;000Ch
967d : f385             	DW	C_ZERO			;Put zero on stack
967f : 2281             	DW	C_LDO			;Put start & end loop values on RPP
9681 :                  B0035
9681 : ea89             	DW	C_SPACE			;Output space
9683 : dd80             	DW	C_LLOOP			;Increment loop & branch if not done
9685 : fcff             	DW	B0035-$			;FFFCh
9687 :                  B0034
9687 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   60
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9689 :                  W_LESSHARP
9689 : 823ca3           	DB	$82,'<','#'+$80
968c : 6896             	DW	W_SPACES
968e :                  C_LESSHARP
968e : 7c85             	DW	E_COLON			;Interpret following word sequence
9690 : f28d             	DW	C_PAD			;Save intermediate string address
9692 : 5587             	DW	C_HLD
9694 : 3985             	DW	C_STORE			;Store word at addr
9696 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9698 :                  W_SHARPGT
9698 : 8223be           	DB	$82,'#','>'+$80
969b : 8996             	DW	W_LESSHARP
969d :                  C_SHARPGT
969d : 7c85             	DW	E_COLON			;Interpret following word sequence
969f : 8684             	DW	C_DROP			;Drop top value from stack
96a1 : 8684             	DW	C_DROP			;Drop top value from stack
96a3 : 5587             	DW	C_HLD
96a5 : 0285             	DW	C_FETCH			;Get word from addr on stack
96a7 : f28d             	DW	C_PAD			;Save intermediate string address
96a9 : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
96ab : 5489             	DW	C_MINUS
96ad : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
96af :                  W_SIGN
96af : 84534947ce       	DB	$84,'SIG','N'+$80
96b4 : 9896             	DW	W_SHARPGT
96b6 :                  C_SIGN
96b6 : 7c85             	DW	E_COLON			;Interpret following word sequence
96b8 : c589             	DW	C_ROT			;3rd valu down to top of stack
96ba : 0284             	DW	C_0LESS			;Less than 0
96bc : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
96be : 0800             	DW	B0036-$			;0008h
96c0 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
96c2 : 2d00             	DW	$002D
96c4 : da8d             	DW	C_HOLD
96c6 :                  B0036
96c6 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
96c8 :                  W_SHARP
96c8 : 81a3             	DB	$81,'#'+$80
96ca : af96             	DW	W_SIGN
96cc :                  C_SHARP
96cc : 7c85             	DW	E_COLON			;Interpret following word sequence
96ce : 2487             	DW	C_BASE			;Put BASE addr on stack
96d0 : 0285             	DW	C_FETCH			;Get word from addr on stack
96d2 : 0f93             	DW	C_MDIVMOD
96d4 : c589             	DW	C_ROT			;3rd valu down to top of stack
96d6 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
96d8 : 0900             	DW	$0009
96da : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
96dc : 7589             	DW	C_LESSTHAN
96de : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
96e0 : 0800             	DW	B0037-$			;0008h
96e2 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
96e4 : 0700             	DW	$0007
96e6 : 1384             	DW	C_PLUS			;n1 + n2
96e8 :                  B0037
96e8 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
96ea : 3000             	DW	$0030
96ec : 1384             	DW	C_PLUS			;n1 + n2
96ee : da8d             	DW	C_HOLD
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   61
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

96f0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
96f2 :                  W_SHARPS
96f2 : 8223d3           	DB	$82,'#','S'+$80
96f5 : c896             	DW	W_SHARP
96f7 :                  C_SHARPS
96f7 : 7c85             	DW	E_COLON			;Interpret following word sequence
96f9 :                  B0038
96f9 : cc96             	DW	C_SHARP
96fb : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
96fd : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
96ff : 1883             	DW	C_OR			;OR
9701 : e783             	DW	C_0EQUALS		;=0
9703 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
9705 : f4ff             	DW	B0038-$			;FFF4h
9707 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9709 :                  W_DDOTR
9709 : 83442ed2         	DB	$83,'D.','R'+$80
970d : f296             	DW	W_SHARPS
970f :                  C_DDOTR
970f : 7c85             	DW	E_COLON			;Interpret following word sequence
9711 : b583             	DW	C_MOVER			;Move value from data to return stack
9713 : a284             	DW	C_SWAP			;Swap top 2 values on stack
9715 : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
9717 : 3392             	DW	C_DABS
9719 : 8e96             	DW	C_LESSHARP
971b : f796             	DW	C_SHARPS
971d : b696             	DW	C_SIGN
971f : 9d96             	DW	C_SHARPGT
9721 : cb83             	DW	C_RMOVE			;Move word from return to data stack
9723 : 7784             	DW	C_OVER			;Copy 2nd down to top of stack
9725 : 5489             	DW	C_MINUS
9727 : 7196             	DW	C_SPACES
9729 : 228c             	DW	C_TYPE			;Output n bytes from addr
972b : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
972d :                  W_DOTR
972d : 822ed2           	DB	$82,'.','R'+$80
9730 : 0997             	DW	W_DDOTR
9732 :                  C_DOTR
9732 : 7c85             	DW	E_COLON			;Interpret following word sequence
9734 : b583             	DW	C_MOVER			;Move value from data to return stack
9736 : ec91             	DW	C_SINGTODUB		;Change single number to double
9738 : cb83             	DW	C_RMOVE			;Move word from return to data stack
973a : 0f97             	DW	C_DDOTR
973c : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
973e :                  W_DDOT
973e : 8244ae           	DB	$82,'D','.'+$80
9741 : 2d97             	DW	W_DOTR
9743 :                  C_DDOT
9743 : 7c85             	DW	E_COLON			;Interpret following word sequence
9745 : f385             	DW	C_ZERO			;Put zero on stack
9747 : 0f97             	DW	C_DDOTR
9749 : ea89             	DW	C_SPACE			;Output space
974b : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
974d :                  W_DOT
974d : 81ae             	DB	$81,'.'+$80
974f : 3e97             	DW	W_DDOT
9751 :                  C_DOT
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   62
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9751 : 7c85             	DW	E_COLON			;Interpret following word sequence
9753 : ec91             	DW	C_SINGTODUB		;Change single number to double
9755 : 4397             	DW	C_DDOT
9757 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9759 :                  W_QUESTION
9759 : 81bf             	DB	$81,'?'+$80
975b : 4d97             	DW	W_DOT
975d :                  C_QUESTION
975d : 7c85             	DW	E_COLON			;Interpret following word sequence
975f : 0285             	DW	C_FETCH			;Get word from addr on stack
9761 : 5197             	DW	C_DOT
9763 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9765 :                  W_UDOT					;Output as unsigned value
9765 : 8255ae           	DB	$82,'U','.'+$80
9768 : 5997             	DW	W_QUESTION
976a :                  C_UDOT
976a : 7c85             	DW	E_COLON			;Interpret following word sequence
976c : f385             	DW	C_ZERO			;Put zero on stack
976e : 4397             	DW	C_DDOT			;Output double value
9770 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9772 :                  W_VLIST
9772 : 85564c4953d4     	DB	$85,'VLIS','T'+$80
9778 : 6597             	DW	W_UDOT
977a :                  C_VLIST
977a : 7c85             	DW	E_COLON			;Interpret following word sequence
977c : ff86             	DW	C_CONTEXT		;Leave vocab pointer on stack
977e : 0285             	DW	C_FETCH			;Get word from addr on stack
9780 : 0285             	DW	C_FETCH			;Get word from addr on stack
9782 : 4c82             	DW	C_CR			;Output [CR][LF]
9784 :                  B0039
9784 : af84             	DW	C_DUP			;Duplicate top value on stack
9786 : 798a             	DW	C_PFA			;Convert NFA to PFA
9788 : a284             	DW	C_SWAP			;Swap top 2 values on stack
978a : 678f             	DW	C_ID			;Print definition name from name field addr
978c : 458a             	DW	C_LFA			;Convert param addr to link addr
978e : 0285             	DW	C_FETCH			;Get word from addr on stack
9790 : af84             	DW	C_DUP			;Duplicate top value on stack
9792 : e783             	DW	C_0EQUALS		;=0
9794 : 3d82             	DW	C_TERMINAL		;Check for break key
9796 : 1883             	DW	C_OR			;OR
9798 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
979a : eaff             	DW	B0039-$			;FFE2h
979c : 8684             	DW	C_DROP			;Drop top value from stack
979e : 4c82             	DW	C_CR			;Output [CR][LF]
97a0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
97a2 :                  W_LIST
97a2 : 844c4953d4       	DB	$84,'LIS','T'+$80
97a7 : 7297             	DW	W_VLIST
97a9 :                  C_LIST
97a9 : 7c85             	DW	E_COLON			;Interpret following word sequence
97ab : 2487             	DW	C_BASE			;Put BASE addr on stack
97ad : 0285             	DW	C_FETCH			;Put current base on stack
97af : a284             	DW	C_SWAP			;Get number of list screen to top
97b1 : 958b             	DW	C_DECIMAL		;Sets decimal mode
97b3 : 4c82             	DW	C_CR			;Output [CR][LF]
97b5 : af84             	DW	C_DUP			;Duplicate top value on stack
97b7 : e486             	DW	C_SCR			;Set most recently listed
97b9 : 3985             	DW	C_STORE			;Store word at addr
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   63
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

97bb : 838c             	DW	C_CQUOTE		;Output following string
97bd : 06               	DB	S_END3-S_START3
97be :                  S_START3
97be : 534352202320     	DB	'SCR # '
97c4 :                  S_END3
97c4 : 5197             	DW	C_DOT			;Output the screen number
97c6 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
97c8 : 1000             	DW	$0010			;16 lines to do
97ca : f385             	DW	C_ZERO			;From 0 to 15
97cc : 2281             	DW	C_LDO			;Put start & end loop values on RPP
97ce :                  DO_LINE
97ce : 4c82             	DW	C_CR			;Output [CR][LF]
97d0 : 3e81             	DW	C_I			;Line number onto data stack
97d2 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
97d4 : 0300             	DW	$0003			;Fromat right justified 3 characters
97d6 : 3297             	DW	C_DOTR			;Output formatted
97d8 : ea89             	DW	C_SPACE			;Output space
97da : 3e81             	DW	C_I			;Line number onto data stack
97dc : e486             	DW	C_SCR			;Get screen number
97de : 0285             	DW	C_FETCH			;Get word from addr on stack
97e0 : 5093             	DW	C_DOTLINE		;Output line from screen
97e2 : 3d82             	DW	C_TERMINAL		;Check for break key
97e4 : c880             	DW	C_0BRANCH		;Jump if no break key
97e6 : 0400             	DW	NO_BRK-$		;
97e8 : a183             	DW	C_LEAVE			;Else set loop index to limit (quit loop)
97ea :                  NO_BRK
97ea : dd80             	DW	C_LLOOP			;Increment loop & branch if not done
97ec : e2ff             	DW	DO_LINE-$		;
97ee : 4c82             	DW	C_CR			;Output [CR][LF]
97f0 : 2487             	DW	C_BASE			;Put BASE addr on stack
97f2 : 3985             	DW	C_STORE			;Restore original base
97f4 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
97f6 :                  W_INDEX
97f6 : 85494e4445d8     	DB	$85,'INDE','X'+$80
97fc : a297             	DW	W_LIST
97fe :                  C_INDEX
97fe : 7c85             	DW	E_COLON			;Interpret following word sequence
9800 : e388             	DW	C_1PLUS			;1 plus
9802 : a284             	DW	C_SWAP			;Swap top 2 values on stack
9804 : 2281             	DW	C_LDO			;Put start & end loop values on RPP
9806 :                  B003D
9806 : 4c82             	DW	C_CR			;Output [CR][LF]
9808 : 3e81             	DW	C_I			;Copy LOOP index to data stack
980a : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
980c : 0300             	DW	$0003
980e : 3297             	DW	C_DOTR
9810 : ea89             	DW	C_SPACE			;Output space
9812 : f385             	DW	C_ZERO			;Put zero on stack
9814 : 3e81             	DW	C_I			;Copy LOOP index to data stack
9816 : 5093             	DW	C_DOTLINE		;Output line from screen
9818 : 3d82             	DW	C_TERMINAL		;Check for break key
981a : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
981c : 0400             	DW	B003C-$			;$0004
981e : a183             	DW	C_LEAVE			;Quit loop by making index = limit
9820 :                  B003C
9820 : dd80             	DW	C_LLOOP			;Increment loop & branch if not done
9822 : e4ff             	DW	B003D-$			;FFE4h
9824 : 4c82             	DW	C_CR			;Output [CR][LF]
9826 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9828 :                  W_INT
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   64
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9828 : c43b494ed4       	DB	$C4,';IN','T'+$80
982d : f697             	DW	W_INDEX
982f :                  C_INT
982f : 7c85             	DW	E_COLON			;Interpret following word sequence
9831 : fd8a             	DW	C_WHATSTACK		;Check stack pointer, error if not ok
9833 : 348b             	DW	C_COMPILE		;Compile next word into dictionary
9835 : 3d98             	DW	X_INT
9837 : 4a8b             	DW	C_LEFTBRKT		;Set STATE to execute
9839 : 6d8b             	DW	C_SMUDGE
983b : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
983d :                  X_INT
983d : 3f98             	DW	2+$			;Vector to code
983f : 214cfe           	LD	HL,INTFLAG
9842 : cbb6             	RES	6,(HL)
9844 : fb               	EI
9845 : c38c83           	JP	X_STOP
                        
9848 :                  W_INTFLAG
9848 : 87494e54464c41c7 	DB	$87,'INTFLA','G'+$80
9850 : 2898             	DW	W_INT
9852 :                  C_INTFLAG
9852 : e385             	DW	X_USER			;Put next word on stack then do next
9854 : 4c00             	DW	INTFLAG-SYSTEM
                        
9856 :                  W_INTVECT
9856 : 87494e54564543d4 	DB	$87,'INTVEC','T'+$80
985e : 4898             	DW	W_INTFLAG
9860 :                  C_INTVECT
9860 : e385             	DW	X_USER			;Put next word on stack then do next
9862 : 4e00             	DW	INTVECT-SYSTEM
                        
9864 :                  W_CPU
9864 : 842e4350d5       	DB	$84,'.CP','U'+$80
9869 : 5698             	DW	W_INTVECT
986b :                  C_CPU
986b : 7c85             	DW	E_COLON			;Interpret following word sequence
986d : 838c             	DW	C_CQUOTE		;Output following string
986f : 04               	DB	S_END4-S_START4
9870 :                  S_START4
9870 : 5a383020         	DB	'Z80 '
9874 :                  S_END4
9874 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9876 :                  W_2SWAP
9876 : 8532535741d0     	DB	$85,'2SWA','P'+$80
987c : 6498             	DW	W_CPU
987e :                  C_2SWAP
987e : 7c85             	DW	E_COLON			;Interpret following word sequence
9880 : c589             	DW	C_ROT			;3rd valu down to top of stack
9882 : b583             	DW	C_MOVER			;Move value from data to return stack
9884 : c589             	DW	C_ROT			;3rd valu down to top of stack
9886 : cb83             	DW	C_RMOVE			;Move word from return to data stack
9888 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
988a :                  W_2OVER
988a : 85324f5645d2     	DB	$85,'2OVE','R'+$80
9890 : 7698             	DW	W_2SWAP
9892 :                  C_2OVER
9892 : 7c85             	DW	E_COLON			;Interpret following word sequence
9894 : b583             	DW	C_MOVER			;Move value from data to return stack
9896 : b583             	DW	C_MOVER			;Move value from data to return stack
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   65
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9898 : bd84             	DW	C_2DUP			;Dup top 2 values on stack
989a : cb83             	DW	C_RMOVE			;Move word from return to data stack
989c : cb83             	DW	C_RMOVE			;Move word from return to data stack
989e : 7e98             	DW	C_2SWAP
98a0 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
98a2 :                  W_EXIT
98a2 : 84455849d4       	DB	$84,'EXI','T'+$80
98a7 : 8a98             	DW	W_2OVER
98a9 :                  C_EXIT
98a9 : 8c83             	DW	X_STOP
                        
98ab :                  W_J		;Push outer loop value on stack
98ab : 81ca             	DB	$81,'J'+$80
98ad : a298             	DW	W_EXIT
98af :                  C_J
98af : b198             	DW	2+$			;Vector to code
98b1 : 2a46fe           	LD	HL,(RPP)		;Get return stack pointer
98b4 : 23               	INC	HL			;Skip inner loop values
98b5 : 23               	INC	HL			;
98b6 : 23               	INC	HL			;
98b7 : 23               	INC	HL			;
98b8 : c34381           	JP	X_I2
                        
98bb :                  W_ROLL
98bb : 84524f4ccc       	DB	$84,'ROL','L'+$80
98c0 : ab98             	DW	W_J
98c2 :                  C_ROLL
98c2 : 7c85             	DW	E_COLON			;Interpret following word sequence
98c4 : af84             	DW	C_DUP			;Duplicate top value on stack
98c6 : f385             	DW	C_ZERO			;Put zero on stack
98c8 : b789             	DW	C_GREATER
98ca : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
98cc : 2c00             	DW	B003E-$			;002Ch
98ce : af84             	DW	C_DUP			;Duplicate top value on stack
98d0 : b583             	DW	C_MOVER			;Move value from data to return stack
98d2 : d489             	DW	C_PICK
98d4 : cb83             	DW	C_RMOVE			;Move word from return to data stack
98d6 : f385             	DW	C_ZERO			;Put zero on stack
98d8 : a284             	DW	C_SWAP			;Swap top 2 values on stack
98da : 2281             	DW	C_LDO			;Put start & end loop values on RPP
98dc :                  B003F
98dc : 3e83             	DW	C_SPFETCH		;Stack pointer onto stack
98de : 3e81             	DW	C_I			;Copy LOOP index to data stack
98e0 : af84             	DW	C_DUP			;Duplicate top value on stack
98e2 : 1384             	DW	C_PLUS			;n1 + n2
98e4 : 1384             	DW	C_PLUS			;n1 + n2
98e6 : af84             	DW	C_DUP			;Duplicate top value on stack
98e8 : 0889             	DW	C_2MINUS		;2 minus
98ea : 0285             	DW	C_FETCH			;Get word from addr on stack
98ec : a284             	DW	C_SWAP			;Swap top 2 values on stack
98ee : 3985             	DW	C_STORE			;Store word at addr
98f0 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
98f2 : ffff             	DW	$FFFF
98f4 : 1681             	DW	C_PLOOP			;Loop + stack & branch if not done
98f6 : e6ff             	DW	B003F-$			;FFE6h
98f8 :                  B003E
98f8 : 8684             	DW	C_DROP			;Drop top value from stack
98fa : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
98fc :                  W_DEPTH
98fc : 8544455054c8     	DB	$85,'DEPT','H'+$80
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   66
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9902 : bb98             	DW	W_ROLL
9904 :                  C_DEPTH
9904 : 7c85             	DW	E_COLON			;Interpret following word sequence
9906 : 6b86             	DW	C_S0			;Push S0 (initial data stack pointer)
9908 : 0285             	DW	C_FETCH			;Get word from addr on stack
990a : 3e83             	DW	C_SPFETCH		;Stack pointer onto stack
990c : 5489             	DW	C_MINUS
990e : 0386             	DW	C_2
9910 : cc92             	DW	C_DIV
9912 : fc88             	DW	C_1MINUS		;1 minus
9914 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9916 :                  W_DLESSTHAN
9916 : 8244bc           	DB	$82,'D','<'+$80
9919 : fc98             	DW	W_DEPTH
991b :                  C_DLESSTHAN
991b : 7c85             	DW	E_COLON			;Interpret following word sequence
991d : c589             	DW	C_ROT			;3rd valu down to top of stack
991f : bd84             	DW	C_2DUP			;Dup top 2 values on stack
9921 : 6989             	DW	C_EQUALS
9923 : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
9925 : 0a00             	DW	B0040-$			;000Ah
9927 : 9484             	DW	C_2DROP			;Drop top two values from stack
9929 : 9789             	DW	C_ULESS			;IF stack-1 < stack_top leave true flag
992b : b080             	DW	C_BRANCH		;Add following offset to BC
992d : 0800             	DW	B0041-$			;0008h
992f :                  B0040
992f : 7e98             	DW	C_2SWAP
9931 : 9484             	DW	C_2DROP			;Drop top two values from stack
9933 : b789             	DW	C_GREATER
9935 :                  B0041
9935 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9937 :                  W_0GREATER
9937 : 8230be           	DB	$82,'0','>'+$80
993a : 1699             	DW	W_DLESSTHAN
993c :                  C_0GREATER
993c : 7c85             	DW	E_COLON			;Interpret following word sequence
993e : f385             	DW	C_ZERO			;Put zero on stack
9940 : b789             	DW	C_GREATER
9942 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9944 :                  W_DOTS
9944 : 822ed3           	DB	$82,'.','S'+$80
9947 : 3799             	DW	W_0GREATER
9949 :                  C_DOTS
9949 : 7c85             	DW	E_COLON			;Interpret following word sequence
994b : 4c82             	DW	C_CR			;Output [CR][LF]
994d : 0499             	DW	C_DEPTH
994f : c880             	DW	C_0BRANCH		;Add offset to BC if stack top = 0
9951 : 2000             	DW	B0042-$			;0020h
9953 : 3e83             	DW	C_SPFETCH		;Stack pointer onto stack
9955 : 0889             	DW	C_2MINUS		;2 minus
9957 : 6b86             	DW	C_S0			;Push S0 (initial data stack pointer)
9959 : 0285             	DW	C_FETCH			;Get word from addr on stack
995b : 0889             	DW	C_2MINUS		;2 minus
995d : 2281             	DW	C_LDO			;Put start & end loop values on RPP
995f :                  B0043
995f : 3e81             	DW	C_I			;Copy LOOP index to data stack
9961 : 0285             	DW	C_FETCH			;Get word from addr on stack
9963 : 5197             	DW	C_DOT
9965 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   67
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9967 : feff             	DW	$FFFE
9969 : 1681             	DW	C_PLOOP			;Loop + stack & branch if not done
996b : f4ff             	DW	B0043-$			;FFF4h
996d : b080             	DW	C_BRANCH		;Add following offset to BC
996f : 1100             	DW	S_END5-$		;0011h
9971 :                  B0042
9971 : 838c             	DW	C_CQUOTE		;Output following string
9973 : 0c               	DB	S_END5-S_START5
9974 :                  S_START5
9974 : 535441434b2045.. 	DB	'STACK EMPTY '
9980 :                  S_END5
9980 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9982 :                  W_CODE
9982 : 84434f44c5       	DB	$84,'COD','E'+$80
9987 : 4499             	DW	W_DOTS
9989 :                  C_CODE
9989 : 7c85             	DW	E_COLON			;Interpret following word sequence
998b : d38a             	DW	C_QEXEC			;Error not if not in execute mode
998d : 778f             	DW	C_XXX1
998f : 4d83             	DW	C_SPSTORE		;Set initial stack pointer value
9991 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9993 :                  W_ENDCODE
9993 : 88454e442d434f.. 	DB	$88,'END-COD','E'+$80
999c : 8299             	DW	W_CODE
999e :                  C_ENDCODE
999e : 7c85             	DW	E_COLON			;Interpret following word sequence
99a0 : 0d87             	DW	C_CURRENT
99a2 : 0285             	DW	C_FETCH			;Get word from addr on stack
99a4 : ff86             	DW	C_CONTEXT
99a6 : 3985             	DW	C_STORE			;Store word at addr
99a8 : d38a             	DW	C_QEXEC			;Error not if not in execute mode
99aa : fd8a             	DW	C_WHATSTACK		;Check stack pointer, error if not ok
99ac : 6d8b             	DW	C_SMUDGE
99ae : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
99b0 :                  W_NEXT
99b0 : c44e4558d4       	DB	$C4,'NEX','T'+$80
99b5 : 9399             	DW	W_ENDCODE
99b7 :                  C_NEXT
99b7 : 7c85             	DW	E_COLON			;Interpret following word sequence
99b9 : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
99bb : c300             	DW	$00C3			;Jump instruction
99bd : 4489             	DW	C_CCOMMA		;Save as 8 bit value
99bf : 8c80             	DW	C_LIT			;Puts next 2 bytes on the stack
99c1 : 6680             	DW	NEXT			;The address of NEXT
99c3 : 3389             	DW	C_COMMA			;Reserve 2 bytes and save n
99c5 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
99c7 :                  W_IM2		;Set interrupt mode 2
99c7 : 83494db2         	DB	$83,'IM','2'+$80
99cb : b099             	DW	W_NEXT
99cd :                  C_IM2
99cd : cf99             	DW	2+$			;Vector to code
99cf : ed5e             	IM	2			;Mode 2
99d1 : c36680           	JP	NEXT
                        
99d4 :                  W_IM1		;Set interrupt mode 1
99d4 : 83494db1         	DB	$83,'IM','1'+$80
99d8 : c799             	DW	W_IM2
99da :                  C_IM1
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   68
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

99da : dc99             	DW	2+$			;Vector to code
99dc : ed56             	IM	1			;Mode 1
99de : c36680           	JP	NEXT
                        
99e1 :                  W_IM0		;Set interrupt mode 0
99e1 : 83494db0         	DB	$83,'IM','0'+$80
99e5 : d499             	DW	W_IM1
99e7 :                  C_IM0
99e7 : e999             	DW	2+$			;Vector to code
99e9 : ed46             	IM	0			;Mode 0
99eb : c36680           	JP	NEXT
                        
99ee :                  W_DI		;Disable interrupt
99ee : 8244c9           	DB	$82,'D','I'+$80
99f1 : e199             	DW	W_IM0
99f3 :                  C_DI
99f3 : f599             	DW	2+$			;Vector to code
99f5 : f3               	DI				;Disable interrupt
99f6 : c36680           	JP	NEXT
                        
99f9 :                  W_EI		;Enable interrupt
99f9 : 8245c9           	DB	$82,'E','I'+$80
99fc : ee99             	DW	W_DI
99fe :                  C_EI
99fe : 009a             	DW	2+$			;Vector to code
9a00 : fb               	EI				;Enable interrupt
9a01 : c36680           	JP	NEXT
                        
9a04 :                  W_MON		;Jump to m/c monitor
9a04 : 834d4fce         	DB	$83,'MO','N'+$80
9a08 : f999             	DW	W_EI
9a0a :                  C_MON
9a0a : 0c9a             	DW 	2+$
9a0c : c30000           	JP	MONSTART
                        
9a0f :                  W_LLOAD
9a0f : 854c4c4f41c4     	DB	$85,'LLOA','D'+$80
9a15 : 049a             	DW	W_MON
9a17 :                  C_LLOAD
9a17 : 7c85             	DW	E_COLON			;Interpret following word sequence
9a19 : 1e94             	DW	C_BLOCK			;Get block address
9a1b : 8c80             	DW	C_LIT			;Enter loop with null
9a1d : 0000             	DW	$0000			;
9a1f :                  LL_BEGIN
9a1f : af84             	DW	C_DUP			;Dup key
9a21 : c880             	DW	C_0BRANCH		;If null then don't store
9a23 : 2800             	DW	LL_NULL-$		;
9a25 : af84             	DW	C_DUP			;Dup key again
9a27 : 8c80             	DW	C_LIT			;Compare to [CR]
9a29 : 0d00             	DW	$000D			;
9a2b : 6989             	DW	C_EQUALS		;
9a2d : c880             	DW	C_0BRANCH		;If not [CR] then jump
9a2f : 1200             	DW	LL_STORE-$		;
9a31 : 8684             	DW	C_DROP			;Drop the [CR]
9a33 : 1e86             	DW	C_CL			;Get characters per line
9a35 : 1384             	DW	C_PLUS			;Add to current addr
9a37 : 1e86             	DW	C_CL			;Make CL MOD value
9a39 : 4384             	DW	C_NEGATE		;Form 2s complement of n
9a3b : 0683             	DW	C_AND			;Mask out bits
9a3d : b080             	DW	C_BRANCH		;Done this bit so jump
9a3f : 0600             	DW	NO_STORE-$
9a41 :                  LL_STORE
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   69
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9a41 : 7784             	DW	C_OVER			;Get address to store at
9a43 : 3985             	DW	C_STORE			;Save chr
9a45 :                  NO_STORE
9a45 : e388             	DW	C_1PLUS			;Next addres
9a47 : b080             	DW	C_BRANCH		;Done so jump
9a49 : 0400             	DW	LL_CHAR-$		;
9a4b :                  LL_NULL
9a4b : 8684             	DW	C_DROP			;Was null so drop it
9a4d :                  LL_CHAR
9a4d : 2b82             	DW	C_KEY			;Get key
9a4f : af84             	DW	C_DUP			;Duplicate it
9a51 : 8c80             	DW	C_LIT			;Compare with [CTRL] Z
9a53 : 1a00             	DW	$001A			;
9a55 : 6989             	DW	C_EQUALS		;
9a57 : c880             	DW	C_0BRANCH		;If not EOF then jump
9a59 : c6ff             	DW	LL_BEGIN-$		;
9a5b : 8684             	DW	C_DROP			;Drop EOF character
9a5d : 8684             	DW	C_DROP			;Drop next address
9a5f : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9a61 :                  W_TASK
9a61 : 84544153cb       	DB	$84,'TAS','K'+$80
9a66 : 0f9a             	DW	W_LLOAD
9a68 :                  C_TASK
9a68 : 7c85             	DW	E_COLON			;Interpret following word sequence
9a6a : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
9a6c :                  W_TASKEND
                        
9a6c :                  W_EDITI
                        
9a6c :                  W_CLEAR		;Clear block n
9a6c : 85434c4541d2     	DB	$85,'CLEA','R'+$80
9a72 : 619a             	DW	W_TASK
9a74 :                  C_CLEAR
9a74 : 7c85             	DW	E_COLON			;Interpret following word sequence
9a76 : af84             	DW	C_DUP			;Duplicate number
9a78 : e486             	DW	C_SCR			;Get SCR addr
9a7a : 3985             	DW	C_STORE			;Store screen number
9a7c : 1e94             	DW	C_BLOCK			;Get the address of the block
9a7e : 4e86             	DW	C_BBUF			;Put number of bytes/block on stack
9a80 : ba8d             	DW	C_ERASE			;Clear the block
9a82 : 8a83             	DW	C_STOP			;Pop BC from return stack (=next)
                        
9a84 :                  CF_UKEY					;Get key onto stack
9a84 : 869a             	DW	2+$			;Vector to code
9a86 : cdbf9a           	CALL	CHR_RD			;User key in routine
9a89 : 6f               	LD	L,A			;Put key on stack
9a8a : 2600             	LD	H,$00			;
9a8c : c36580           	JP	NEXTS1			;Save & NEXT
                        
9a8f :                  CF_UEMIT				;Chr from stack to output
9a8f : 919a             	DW	2+$			;Vector to code
9a91 : e1               	POP	HL			;Get CHR to output
9a92 : 7d               	LD	A,L			;Put in A
9a93 : c5               	PUSH	BC			;Save regs
9a94 : d5               	PUSH	DE			;
9a95 : cdf39a           	CALL	CHR_WR			;User output routine
9a98 : d1               	POP	DE			;Restore regs
9a99 : c1               	POP	BC			;
9a9a : c36680           	JP	NEXT			;
                        
9a9d :                  CF_UCR					;CR output
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   70
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9a9d : 9f9a             	DW	2+$			;Vector to code
9a9f : c5               	PUSH	BC			;Save regs
9aa0 : d5               	PUSH	DE			;Just in case
9aa1 : 3e0d             	LD	A,$0D			;Carrage return
9aa3 : cdf39a           	CALL	CHR_WR			;User output routine
9aa6 : 3e0a             	LD	A,$0A			;Line feed
9aa8 : cdf39a           	CALL	CHR_WR			;User output routine
9aab : d1               	POP	DE			;Get regs back
9aac : c1               	POP	BC			;
9aad : c36680           	JP	NEXT			;Next
                        
9ab0 :                  CF_UQTERMINAL				;Test for user break
9ab0 : b29a             	DW	2+$			;Vector to code
9ab2 : c5               	PUSH	BC			;Save regs
9ab3 : d5               	PUSH	DE			;Just in case
9ab4 : cdd99a           	CALL	BREAKKEY		;User break test routine
9ab7 : d1               	POP	DE			;Get regs back
9ab8 : c1               	POP	BC			;
9ab9 : 2600             	LD	H,$00			;Clear H
9abb : 6f               	LD	L,A			;Result in L
9abc : c36580           	JP	NEXTS1			;Store it & Next
                        
                        	;Serial I/O routines
                        
                        ; Change these to suit your target system .....
                        
9abf :                  CHR_RD					;8251 Character in
9abf : 3a66fe           	LD	A,(KEYBUF)		;Get key buffer
9ac2 : b7               	OR	A			;Set flags
9ac3 : 280b             	JR	Z,NO_BUF_KEY		;If empty go wait for key
9ac5 : 3267fe           	LD	(KEYBUF+1),A		;Save key
9ac8 : af               	XOR	A			;Clear buffer
9ac9 : 3266fe           	LD	(KEYBUF),A		;
9acc : 3a67fe           	LD	A,(KEYBUF+1)		;Get key back
9acf : c9               	RET
9ad0 :                  NO_BUF_KEY
9ad0 : db61             	IN	A,(URTCNT)		;Get status byte
9ad2 : cb4f             	BIT	1,A			;Check buffer full bit
9ad4 : 28fa             	JR	Z,NO_BUF_KEY		;Not full so wait
9ad6 : db60             	IN	A,(URTDA)		;Get byte from buffer
9ad8 : c9               	RET				;
                        
9ad9 :                  BREAKKEY
9ad9 : 3a66fe           	LD	A,(KEYBUF)		;Get buffer contents
9adc : b7               	OR	A			;Set the flags
9add : 200f             	JR	NZ,NO_KEY		;If buffer is full then exit
9adf : db61             	IN	A,(URTCNT)		;Get status byte
9ae1 : cb4f             	BIT	1,A			;Check buffer full bit
9ae3 : 2809             	JR	Z,NO_KEY		;Not full so go on
9ae5 : db60             	IN	A,(URTDA)		;Get byte from buffer
9ae7 : fe03             	CP	$03			;Is it break
9ae9 : 2805             	JR	Z,WAS_BRK
9aeb : 3266fe           	LD	(KEYBUF),A		;Not break so save key
9aee :                  NO_KEY
9aee : af               	XOR	A			;Wasn't break, or no key, so clear
9aef : c9               	RET
9af0 :                  WAS_BRK
9af0 : 3e01             	LD	A,$01			;Was break so set flag
9af2 : c9               	RET
                        
9af3 :                  CHR_WR					;8251 Character out
9af3 : e67f             	AND	$7F			;Mask off top bit
AS80 Assembler for i8080-Z180 [1.09].  Copyright 1994-95, Frank A. Vorstenbosch                                                                                           Page   71
------------------------------------------------------------------------------------ FORTH.ASM ------------------------------------------------------------------------------------

9af5 : f5               	PUSH	AF			;Save byte for now
9af6 :                  WAIT1
9af6 : db61             	IN	A,(URTCNT)
9af8 : cb47             	BIT	0,A			;Check buffer full bit
9afa : 28fa             	JR	Z,WAIT1			;Out buffer full so wait
9afc : f1               	POP	AF			;Get byte back
9afd : d360             	OUT	(URTDA),A		;Send byte
9aff : c9               	RET				;
                        
                        	END
No errors in pass 2.
